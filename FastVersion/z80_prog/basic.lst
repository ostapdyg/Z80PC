# file opened: basic.asm
   1  0000              ;==================================================================================
   2  0000              ; The updates to the original BASIC within this file are copyright Grant Searle
   3  0000              ;
   4  0000              ; You have permission to use this for NON COMMERCIAL USE ONLY
   5  0000              ; If you wish to use it elsewhere, please include an acknowledgement to myself.
   6  0000              ;
   7  0000              ; http://searle.hostei.com/grant/index.html
   8  0000              ;
   9  0000              ; eMail: home.micros01@btinternet.com
  10  0000              ;
  11  0000              ; If the above don't work, please perform an Internet search to see if I have
  12  0000              ; updated the web page hosting service.
  13  0000              ;
  14  0000              ;==================================================================================
  15  0000
  16  0000              ; NASCOM ROM BASIC Ver 4.7, (C) 1978 Microsoft
  17  0000              ; Scanned from source published in 80-BUS NEWS from Vol 2, Issue 3
  18  0000              ; (May-June 1983) to Vol 3, Issue 3 (May-June 1984)
  19  0000              ; Adapted for the freeware Zilog Macro Assembler 2.10 to produce
  20  0000              ; the original ROM code (checksum A934H). PA
  21  0000
  22  0000              ; GENERAL EQUATES
  23  0000
  24  0000
  25  0000              CTRLC   .EQU    03H             ; Control "C"
  26  0000              CTRLG   .EQU    07H             ; Control "G"
  27  0000              BKSP    .EQU    08H             ; Back space
  28  0000              LF1      .EQU    0AH             ; Line feed
  29  0000              CS1      .EQU    0CH             ; Clear screen
  30  0000              CR1      .EQU    0DH             ; Carriage return
  31  0000              CTRLO   .EQU    0FH             ; Control "O"
  32  0000              CTRLQ	.EQU	11H		        ; Control "Q"
  33  0000              CTRLR   .EQU    12H             ; Control "R"
  34  0000              CTRLS   .EQU    13H             ; Control "S"
  35  0000              CTRLU   .EQU    15H             ; Control "U"
  36  0000              ESC     .EQU    1BH             ; Escape
  37  0000              DEL     .EQU    7FH             ; Delete
  38  0000
  39  0000              ; BASIC WORK SPACE LOCATIONS
  40  0000
  41  0000              WRKSPC  .EQU    2045H             ; BASIC Work space
  42  0000              USR     .EQU    WRKSPC+3H           ; "USR (x)" jump
  43  0000              OUTSUB  .EQU    WRKSPC+6H           ; "OUT p,n"
  44  0000              OTPORT  .EQU    WRKSPC+7H           ; Port (p)
  45  0000              DIVSUP  .EQU    WRKSPC+9H           ; Division support routine
  46  0000              DIV1    .EQU    WRKSPC+0AH           ; <- Values
  47  0000              DIV2    .EQU    WRKSPC+0EH           ; <-   to
  48  0000              DIV3    .EQU    WRKSPC+12H           ; <-   be
  49  0000              DIV4    .EQU    WRKSPC+15H           ; <-inserted
  50  0000              SEED    .EQU    WRKSPC+17H           ; Random number seed
  51  0000              LSTRND  .EQU    WRKSPC+3AH           ; Last random number
  52  0000              INPSUB  .EQU    WRKSPC+3EH           ; #INP (x)" Routine
  53  0000              INPORT  .EQU    WRKSPC+3FH           ; PORT (x)
  54  0000              NULLS   .EQU    WRKSPC+41H           ; Number of nulls
  55  0000              LWIDTH  .EQU    WRKSPC+42H           ; Terminal width
  56  0000              COMMAN  .EQU    WRKSPC+43H           ; Width for commas
  57  0000              NULFLG  .EQU    WRKSPC+44H           ; Null after input byte flag
  58  0000              CTLOFG  .EQU    WRKSPC+45H           ; Control "O" flag
  59  0000              LINESC  .EQU    WRKSPC+46H           ; Lines counter
  60  0000              LINESN  .EQU    WRKSPC+48H           ; Lines number
  61  0000              CHKSUM  .EQU    WRKSPC+4AH           ; Array load/save check sum
  62  0000              NMIFLG  .EQU    WRKSPC+4CH           ; Flag for NMI break routine
  63  0000              BRKFLG  .EQU    WRKSPC+4DH           ; Break flag
  64  0000              RINPUT  .EQU    WRKSPC+4EH           ; Input reflection
  65  0000              POINT   .EQU    WRKSPC+51H           ; "POINT" reflection (unused)
  66  0000              PSET    .EQU    WRKSPC+54H           ; "SET"   reflection
  67  0000              RESET   .EQU    WRKSPC+57H           ; "RESET" reflection
  68  0000              STRSPC  .EQU    WRKSPC+5AH           ; Bottom of string space
  69  0000              LINEAT  .EQU    WRKSPC+5CH           ; Current line number
  70  0000              BASTXT  .EQU    WRKSPC+5EH           ; Pointer to start of program
  71  0000              BUFFER  .EQU    WRKSPC+61H           ; Input buffer
  72  0000              STACK   .EQU    WRKSPC+66H           ; Initial stack
  73  0000              CURPOS  .EQU    WRKSPC+0ABH          ; Character position on line
  74  0000              LCRFLG  .EQU    WRKSPC+0ACH          ; Locate/Create flag
  75  0000              TYPE    .EQU    WRKSPC+0ADH          ; Data type flag
  76  0000              DATFLG  .EQU    WRKSPC+0AEH          ; Literal statement flag
  77  0000              LSTRAM  .EQU    WRKSPC+0AFH          ; Last available RAM
  78  0000              TMSTPT  .EQU    WRKSPC+0B1H          ; Temporary string pointer
  79  0000              TMSTPL  .EQU    WRKSPC+0B3H          ; Temporary string pool
  80  0000              TMPSTR  .EQU    WRKSPC+0BFH          ; Temporary string
  81  0000              STRBOT  .EQU    WRKSPC+0C3H          ; Bottom of string space
  82  0000              CUROPR  .EQU    WRKSPC+0C5H          ; Current operator in EVAL
  83  0000              LOOPST  .EQU    WRKSPC+0C7H          ; First statement of loop
  84  0000              DATLIN  .EQU    WRKSPC+0C9H          ; Line of current DATA item
  85  0000              FORFLG  .EQU    WRKSPC+0CBH          ; "FOR" loop flag
  86  0000              LSTBIN  .EQU    WRKSPC+0CCH          ; Last byte entered
  87  0000              READFG  .EQU    WRKSPC+0CDH          ; Read/Input flag
  88  0000              BRKLIN  .EQU    WRKSPC+0CEH          ; Line of break
  89  0000              NXTOPR  .EQU    WRKSPC+0D0H          ; Next operator in EVAL
  90  0000              ERRLIN  .EQU    WRKSPC+0D2H          ; Line of error
  91  0000              CONTAD  .EQU    WRKSPC+0D4H          ; Where to CONTinue
  92  0000              PROGND  .EQU    WRKSPC+0D6H          ; End of program
  93  0000              VAREND  .EQU    WRKSPC+0D8H          ; End of variables
  94  0000              ARREND  .EQU    WRKSPC+0DAH          ; End of arrays
  95  0000              NXTDAT  .EQU    WRKSPC+0DCH          ; Next data item
  96  0000              FNRGNM  .EQU    WRKSPC+0DEH          ; Name of FN argument
  97  0000              FNARG   .EQU    WRKSPC+0E0H          ; FN argument value
  98  0000              FPREG   .EQU    WRKSPC+0E4H          ; Floating point register
  99  0000              FPEXP   .EQU    FPREG+3         ; Floating point exponent
 100  0000              SGNRES  .EQU    WRKSPC+0E8H     ; Sign of result
 101  0000              PBUFF   .EQU    WRKSPC+0E9H     ; Number print buffer
 102  0000              MULVAL  .EQU    WRKSPC+0F6H     ; Multiplier
 103  0000              PROGST  .EQU    WRKSPC+0F9H     ; Start of program text area
 104  0000              STLOOK  .EQU    WRKSPC+15DH     ; Start of memory test
 105  0000
 106  0000              ; BASIC ERROR CODE VALUES
 107  0000
 108  0000              NF      .EQU    00H             ; NEXT without FOR
 109  0000              SN      .EQU    02H             ; Syntax error
 110  0000              RG      .EQU    04H             ; RETURN without GOSUB
 111  0000              OD      .EQU    06H             ; Out of DATA
 112  0000              FC      .EQU    08H             ; Function call error
 113  0000              OV      .EQU    0AH             ; Overflow
 114  0000              OM      .EQU    0CH             ; Out of memory
 115  0000              UL      .EQU    0EH             ; Undefined line number
 116  0000              BS      .EQU    10H             ; Bad subscript
 117  0000              DD      .EQU    12H             ; Re-DIMensioned array
 118  0000              DZ      .EQU    14H             ; Division by zero (/0)
 119  0000              ID      .EQU    16H             ; Illegal direct
 120  0000              TM      .EQU    18H             ; Type miss-match
 121  0000              OS      .EQU    1AH             ; Out of string space
 122  0000              LS      .EQU    1CH             ; String too long
 123  0000              ST      .EQU    1EH             ; String formula too complex
 124  0000              CN      .EQU    20H             ; Can't CONTinue
 125  0000              UF      .EQU    22H             ; UnDEFined FN function
 126  0000              MO      .EQU    24H             ; Missing operand
 127  0000              HX      .EQU    26H             ; HEX error
 128  0000              BN      .EQU    28H             ; BIN error
 129  0000                  output "basic.bin", t
 130  0000
 131  0000                      .ORG    00150H
 132  0150
 133  0150 C3 56 01     COLD:   JP      STARTB          ; Jump for cold start
 134  0153 C3 F4 01     WARM:   JP      WARMST          ; Jump for warm start
 135  0156              STARTB:
 136  0156 DD 21 00 00          LD      IX,0            ; Flag cold start
 137  015A C3 61 01             JP      CSTART          ; Jump to initialise
 138  015D
 139  015D 07 0A                .WORD   DEINT           ; Get integer -32768 to 32767
 140  015F 7D 11                .WORD   ABPASS          ; Return integer in AB
 141  0161
 142  0161
 143  0161 21 45 20     CSTART: LD      HL,WRKSPC       ; Start of workspace RAM
 144  0164 F9                   LD      SP,HL           ; Set up a temporary stack
 145  0165 C3 9C 1D             JP      INITST          ; Go to initialise
 146  0168
 147  0168 11 2E 04     INIT1:   LD      DE,INITAB       ; Initialise workspace
 148  016B 06 63                LD      B,INITBE-INITAB+3; Bytes to copy
 149  016D 21 45 20             LD      HL,WRKSPC       ; Into workspace RAM
 150  0170 1A           COPY:   LD      A,(DE)          ; Get source
 151  0171 77                   LD      (HL),A          ; To destination
 152  0172 23                   INC     HL              ; Next destination
 153  0173 13                   INC     DE              ; Next source
 154  0174 05                   DEC     B               ; Count bytes
 155  0175 C2 70 01             JP      NZ,COPY         ; More to move
 156  0178 F9                   LD      SP,HL           ; Temporary stack
 157  0179 CD 2F 06             CALL    CLREG           ; Clear registers and stack
 158  017C CD FD 0B             CALL    PRNTCRLF        ; Output CRLF
 159  017F 32 EF 20             LD      (BUFFER+72+1),A ; Mark end of buffer
 160  0182 32 3E 21             LD      (PROGST),A      ; Initialise program area
 161  0185 21 43 02     MSIZE:  LD      HL,MEMMSG       ; Point to message
 162  0188 CD 9B 12             CALL    PRS             ; Output "Memory size"
 163  018B CD 4C 06             CALL    PROMPT          ; Get input with '?'
 164  018E CD 55 09             CALL    GETCHR          ; Get next character
 165  0191 B7                   OR      A               ; Set flags
 166  0192 C2 AA 01             JP      NZ,TSTMEM       ; If number - Test if RAM there
 167  0195 21 A2 21             LD      HL,STLOOK       ; Point to start of RAM
 168  0198 23           MLOOP:  INC     HL              ; Next byte
 169  0199 7C                   LD      A,H             ; Above address FFFF ?
 170  019A B5                   OR      L
 171  019B CA BC 01             JP      Z,SETTOP        ; Yes - 64K RAM
 172  019E 7E                   LD      A,(HL)          ; Get contents
 173  019F 47                   LD      B,A             ; Save it
 174  01A0 2F                   CPL                     ; Flip all bits
 175  01A1 77                   LD      (HL),A          ; Put it back
 176  01A2 BE                   CP      (HL)            ; RAM there if same
 177  01A3 70                   LD      (HL),B          ; Restore old contents
 178  01A4 CA 98 01             JP      Z,MLOOP         ; If RAM - test next byte
 179  01A7 C3 BC 01             JP      SETTOP          ; Top of RAM found
 180  01AA
 181  01AA CD 21 0A     TSTMEM: CALL    ATOH            ; Get high memory into DE
 182  01AD B7                   OR      A               ; Set flags on last byte
 183  01AE C2 FD 04             JP      NZ,SNERR        ; ?SN Error if bad character
 184  01B1 EB                   EX      DE,HL           ; Address into HL
 185  01B2 2B                   DEC     HL              ; Back one byte
 186  01B3 3E D9                LD      A,11011001B     ; Test byte
 187  01B5 46                   LD      B,(HL)          ; Get old contents
 188  01B6 77                   LD      (HL),A          ; Load test byte
 189  01B7 BE                   CP      (HL)            ; RAM there if same
 190  01B8 70                   LD      (HL),B          ; Restore old contents
 191  01B9 C2 85 01             JP      NZ,MSIZE        ; Ask again if no RAM
 192  01BC
 193  01BC 2B           SETTOP: DEC     HL              ; Back one byte
 194  01BD 11 A1 21             LD      DE,STLOOK-1     ; See if enough RAM
 195  01C0 CD C5 07             CALL    CPDEHL          ; Compare DE with HL
 196  01C3 DA 85 01             JP      C,MSIZE         ; Ask again if not enough RAM
 197  01C6 11 CE FF             LD      DE,0-50         ; 50 Bytes string space
 198  01C9 22 F4 20             LD      (LSTRAM),HL     ; Save last available RAM
 199  01CC 19                   ADD     HL,DE           ; Allocate string space
 200  01CD 22 9F 20             LD      (STRSPC),HL     ; Save string space
 201  01D0 CD 0A 06             CALL    CLRPTR          ; Clear program area
 202  01D3 2A 9F 20             LD      HL,(STRSPC)     ; Get end of memory
 203  01D6 11 EF FF             LD      DE,0-17         ; Offset for free bytes
 204  01D9 19                   ADD     HL,DE           ; Adjust HL
 205  01DA 11 3E 21             LD      DE,PROGST       ; Start of program text
 206  01DD 7D                   LD      A,L             ; Get LSB
 207  01DE 93                   SUB     E               ; Adjust it
 208  01DF 6F                   LD      L,A             ; Re-save
 209  01E0 7C                   LD      A,H             ; Get MSB
 210  01E1 9A                   SBC     A,D             ; Adjust it
 211  01E2 67                   LD      H,A             ; Re-save
 212  01E3 E5                   PUSH    HL              ; Save bytes free
 213  01E4 21 0C 02             LD      HL,SIGNON       ; Sign-on message
 214  01E7 CD 9B 12             CALL    PRS             ; Output string
 215  01EA E1                   POP     HL              ; Get bytes free back
 216  01EB CD 3E 19             CALL    PRNTHL          ; Output amount of free memory
 217  01EE 21 FD 01             LD      HL,BFREE        ; " Bytes free" message
 218  01F1 CD 9B 12             CALL    PRS             ; Output string
 219  01F4
 220  01F4 31 AB 20     WARMST: LD      SP,STACK        ; Temporary stack
 221  01F7 CD 2F 06     BRKRET: CALL    CLREG           ; Clear registers and stack
 222  01FA C3 48 05             JP      PRNTOK          ; Go to get command line
 223  01FD
 224  01FD 20 42 79 74  BFREE:  .BYTE   " Bytes free",CR,LF,0,0
 224  0201 65 73 20 66
 224  0205 72 65 65 0D
 224  0209 0A 00 00
 225  020C
 226  020C 5A 38 30 20  SIGNON: .BYTE   "Z80 BASIC Ver 4.7b",CR,LF
 226  0210 42 41 53 49
 226  0214 43 20 56 65
 226  0218 72 20 34 2E
 226  021C 37 62 0D 0A
 227  0220 43 6F 70 79          .BYTE   "Copyright ",40,"C",41
 227  0224 72 69 67 68
 227  0228 74 20 28 43
 227  022C 29
 228  022D 20 31 39 37          .BYTE   " 1978 by Microsoft",CR,LF,0,0
 228  0231 38 20 62 79
 228  0235 20 4D 69 63
 228  0239 72 6F 73 6F
 228  023D 66 74 0D 0A
 228  0241 00 00
 229  0243
 230  0243 4D 65 6D 6F  MEMMSG: .BYTE   "Memory top",0
 230  0247 72 79 20 74
 230  024B 6F 70 00
 231  024E
 232  024E              ; FUNCTION ADDRESS TABLE
 233  024E
 234  024E B3 17        FNCTAB: .WORD   SGN
 235  0250 77 18                .WORD   INT
 236  0252 C9 17                .WORD   ABS
 237  0254 48 20                .WORD   USR
 238  0256 5B 11                .WORD   FRE
 239  0258 E0 14                .WORD   INP
 240  025A 89 11                .WORD   POS
 241  025C 3D 1A                .WORD   SQR
 242  025E 1C 1B                .WORD   RND
 243  0260 58 16                .WORD   LOG
 244  0262 8B 1A                .WORD   EXP
 245  0264 91 1B                .WORD   COS
 246  0266 97 1B                .WORD   SIN
 247  0268 F8 1B                .WORD   TAN
 248  026A 0D 1C                .WORD   ATN
 249  026C 34 15                .WORD   PEEK
 250  026E 78 1C                .WORD   DEEK
 251  0270 96 20                .WORD   POINT
 252  0272 0D 14                .WORD   LEN
 253  0274 25 12                .WORD   STR
 254  0276 A7 14                .WORD   VAL
 255  0278 1C 14                .WORD   ASC
 256  027A 2D 14                .WORD   CHR
 257  027C 9A 1C                .WORD   HEX
 258  027E 2D 1D                .WORD   BIN
 259  0280 3D 14                .WORD   LEFT
 260  0282 6D 14                .WORD   RIGHT
 261  0284 77 14                .WORD   MID
 262  0286
 263  0286              ; RESERVED WORD LIST
 264  0286
 265  0286 C5 4E 44     WORDS:  .BYTE   'E'+80H,"ND"
 266  0289 C6 4F 52             .BYTE   'F'+80H,"OR"
 267  028C CE 45 58 54          .BYTE   'N'+80H,"EXT"
 268  0290 C4 41 54 41          .BYTE   'D'+80H,"ATA"
 269  0294 C9 4E 50 55          .BYTE   'I'+80H,"NPUT"
 269  0298 54
 270  0299 C4 49 4D             .BYTE   'D'+80H,"IM"
 271  029C D2 45 41 44          .BYTE   'R'+80H,"EAD"
 272  02A0 CC 45 54             .BYTE   'L'+80H,"ET"
 273  02A3 C7 4F 54 4F          .BYTE   'G'+80H,"OTO"
 274  02A7 D2 55 4E             .BYTE   'R'+80H,"UN"
 275  02AA C9 46                .BYTE   'I'+80H,"F"
 276  02AC D2 45 53 54          .BYTE   'R'+80H,"ESTORE"
 276  02B0 4F 52 45
 277  02B3 C7 4F 53 55          .BYTE   'G'+80H,"OSUB"
 277  02B7 42
 278  02B8 D2 45 54 55          .BYTE   'R'+80H,"ETURN"
 278  02BC 52 4E
 279  02BE D2 45 4D             .BYTE   'R'+80H,"EM"
 280  02C1 D3 54 4F 50          .BYTE   'S'+80H,"TOP"
 281  02C5 CF 55 54             .BYTE   'O'+80H,"UT"
 282  02C8 CF 4E                .BYTE   'O'+80H,"N"
 283  02CA CE 55 4C 4C          .BYTE   'N'+80H,"ULL"
 284  02CE D7 41 49 54          .BYTE   'W'+80H,"AIT"
 285  02D2 C4 45 46             .BYTE   'D'+80H,"EF"
 286  02D5 D0 4F 4B 45          .BYTE   'P'+80H,"OKE"
 287  02D9 C4 4F 4B 45          .BYTE   'D'+80H,"OKE"
 288  02DD D3 43 52 45          .BYTE   'S'+80H,"CREEN"
 288  02E1 45 4E
 289  02E3 CC 49 4E 45          .BYTE   'L'+80H,"INES"
 289  02E7 53
 290  02E8 C3 4C 53             .BYTE   'C'+80H,"LS"
 291  02EB D7 49 44 54          .BYTE   'W'+80H,"IDTH"
 291  02EF 48
 292  02F0 CD 4F 4E 49          .BYTE   'M'+80H,"ONITOR"
 292  02F4 54 4F 52
 293  02F7 D3 45 54             .BYTE   'S'+80H,"ET"
 294  02FA D2 45 53 45          .BYTE   'R'+80H,"ESET"
 294  02FE 54
 295  02FF D0 52 49 4E          .BYTE   'P'+80H,"RINT"
 295  0303 54
 296  0304 C3 4F 4E 54          .BYTE   'C'+80H,"ONT"
 297  0308 CC 49 53 54          .BYTE   'L'+80H,"IST"
 298  030C C3 4C 45 41          .BYTE   'C'+80H,"LEAR"
 298  0310 52
 299  0311 C3 4C 4F 41          .BYTE   'C'+80H,"LOAD"
 299  0315 44
 300  0316 C3 53 41 56          .BYTE   'C'+80H,"SAVE"
 300  031A 45
 301  031B CE 45 57             .BYTE   'N'+80H,"EW"
 302  031E
 303  031E D4 41 42 28          .BYTE   'T'+80H,"AB("
 304  0322 D4 4F                .BYTE   'T'+80H,"O"
 305  0324 C6 4E                .BYTE   'F'+80H,"N"
 306  0326 D3 50 43 28          .BYTE   'S'+80H,"PC("
 307  032A D4 48 45 4E          .BYTE   'T'+80H,"HEN"
 308  032E CE 4F 54             .BYTE   'N'+80H,"OT"
 309  0331 D3 54 45 50          .BYTE   'S'+80H,"TEP"
 310  0335
 311  0335 AB                   .BYTE   '+'+80H
 312  0336 AD                   .BYTE   '-'+80H
 313  0337 AA                   .BYTE   '*'+80H
 314  0338 AF                   .BYTE   '/'+80H
 315  0339 DE                   .BYTE   '^'+80H
 316  033A C1 4E 44             .BYTE   'A'+80H,"ND"
 317  033D CF 52                .BYTE   'O'+80H,"R"
 318  033F BE                   .BYTE   '>'+80H
 319  0340 BD                   .BYTE   '='+80H
 320  0341 BC                   .BYTE   '<'+80H
 321  0342
 322  0342 D3 47 4E             .BYTE   'S'+80H,"GN"
 323  0345 C9 4E 54             .BYTE   'I'+80H,"NT"
 324  0348 C1 42 53             .BYTE   'A'+80H,"BS"
 325  034B D5 53 52             .BYTE   'U'+80H,"SR"
 326  034E C6 52 45             .BYTE   'F'+80H,"RE"
 327  0351 C9 4E 50             .BYTE   'I'+80H,"NP"
 328  0354 D0 4F 53             .BYTE   'P'+80H,"OS"
 329  0357 D3 51 52             .BYTE   'S'+80H,"QR"
 330  035A D2 4E 44             .BYTE   'R'+80H,"ND"
 331  035D CC 4F 47             .BYTE   'L'+80H,"OG"
 332  0360 C5 58 50             .BYTE   'E'+80H,"XP"
 333  0363 C3 4F 53             .BYTE   'C'+80H,"OS"
 334  0366 D3 49 4E             .BYTE   'S'+80H,"IN"
 335  0369 D4 41 4E             .BYTE   'T'+80H,"AN"
 336  036C C1 54 4E             .BYTE   'A'+80H,"TN"
 337  036F D0 45 45 4B          .BYTE   'P'+80H,"EEK"
 338  0373 C4 45 45 4B          .BYTE   'D'+80H,"EEK"
 339  0377 D0 4F 49 4E          .BYTE   'P'+80H,"OINT"
 339  037B 54
 340  037C CC 45 4E             .BYTE   'L'+80H,"EN"
 341  037F D3 54 52 24          .BYTE   'S'+80H,"TR$"
 342  0383 D6 41 4C             .BYTE   'V'+80H,"AL"
 343  0386 C1 53 43             .BYTE   'A'+80H,"SC"
 344  0389 C3 48 52 24          .BYTE   'C'+80H,"HR$"
 345  038D C8 45 58 24          .BYTE   'H'+80H,"EX$"
 346  0391 C2 49 4E 24          .BYTE   'B'+80H,"IN$"
 347  0395 CC 45 46 54          .BYTE   'L'+80H,"EFT$"
 347  0399 24
 348  039A D2 49 47 48          .BYTE   'R'+80H,"IGHT$"
 348  039E 54 24
 349  03A0 CD 49 44 24          .BYTE   'M'+80H,"ID$"
 350  03A4 80                   .BYTE   80H             ; End of list marker
 351  03A5
 352  03A5              ; KEYWORD ADDRESS TABLE
 353  03A5
 354  03A5 9F 09        WORDTB: .WORD   PEND
 355  03A7 9C 08                .WORD   FOR
 356  03A9 77 0D                .WORD   NEXT
 357  03AB EC 0A                .WORD   DATA
 358  03AD 7E 0C                .WORD   INPUT
 359  03AF B3 0F                .WORD   DIM
 360  03B1 AD 0C                .WORD   READ
 361  03B3 03 0B                .WORD   LET
 362  03B5 A9 0A                .WORD   GOTO
 363  03B7 8C 0A                .WORD   RUN
 364  03B9 7B 0B                .WORD   IF
 365  03BB 65 09                .WORD   RESTOR
 366  03BD 98 0A                .WORD   GOSUB
 367  03BF C7 0A                .WORD   RETURN
 368  03C1 EE 0A                .WORD   REM
 369  03C3 9D 09                .WORD   STOP
 370  03C5 EC 14                .WORD   POUT
 371  03C7 5D 0B                .WORD   ON
 372  03C9 DE 09                .WORD   NULL
 373  03CB F2 14                .WORD   WAIT
 374  03CD 91 11                .WORD   DEF
 375  03CF 3B 15                .WORD   POKE
 376  03D1 83 1C                .WORD   DOKE
 377  03D3 EE 0A                .WORD   REM
 378  03D5 69 1C                .WORD   LINES
 379  03D7 5C 1C                .WORD   CLS
 380  03D9 61 1C                .WORD   WIDTH
 381  03DB 99 1D                .WORD   MONITR
 382  03DD 99 20                .WORD   PSET
 383  03DF 9C 20                .WORD   RESET
 384  03E1 A0 00                .WORD   PRINT
 385  03E3 CB 09                .WORD   CONT
 386  03E5 11 08                .WORD   LIST
 387  03E7 46 0A                .WORD   CLEAR
 388  03E9 EE 0A                .WORD   REM
 389  03EB EE 0A                .WORD   REM
 390  03ED 09 06                .WORD   NEW
 391  03EF
 392  03EF              ; RESERVED WORD TOKEN VALUES
 393  03EF
 394  03EF              ZEND    .EQU    080H            ; END
 395  03EF              ZFOR    .EQU    081H            ; FOR
 396  03EF              ZDATA   .EQU    083H            ; DATA
 397  03EF              ZGOTO   .EQU    088H            ; GOTO
 398  03EF              ZGOSUB  .EQU    08CH            ; GOSUB
 399  03EF              ZREM    .EQU    08EH            ; REM
 400  03EF              ZPRINT  .EQU    09EH            ; PRINT
 401  03EF              ZNEW    .EQU    0A4H            ; NEW
 402  03EF
 403  03EF              ZTAB    .EQU    0A5H            ; TAB
 404  03EF              ZTO     .EQU    0A6H            ; TO
 405  03EF              ZFN     .EQU    0A7H            ; FN
 406  03EF              ZSPC    .EQU    0A8H            ; SPC
 407  03EF              ZTHEN   .EQU    0A9H            ; THEN
 408  03EF              ZNOT    .EQU    0AAH            ; NOT
 409  03EF              ZSTEP   .EQU    0ABH            ; STEP
 410  03EF
 411  03EF              ZPLUS   .EQU    0ACH            ; +
 412  03EF              ZMINUS  .EQU    0ADH            ; -
 413  03EF              ZTIMES  .EQU    0AEH            ; *
 414  03EF              ZDIV    .EQU    0AFH            ; /
 415  03EF              ZOR     .EQU    0B2H            ; OR
 416  03EF              ZGTR    .EQU    0B3H            ; >
 417  03EF              ZEQUAL  .EQU    0B4H            ; M
 418  03EF              ZLTH    .EQU    0B5H            ; <
 419  03EF              ZSGN    .EQU    0B6H            ; SGN
 420  03EF              ZPOINT  .EQU    0C7H            ; POINT
 421  03EF              ZLEFT   .EQU    0CDH +2         ; LEFT$
 422  03EF
 423  03EF              ; ARITHMETIC PRECEDENCE TABLE
 424  03EF
 425  03EF 79           PRITAB: .BYTE   79H             ; Precedence value
 426  03F0 25 19                .WORD   PADD            ; FPREG = <last> + FPREG
 427  03F2
 428  03F2 79                   .BYTE   79H             ; Precedence value
 429  03F3 59 15                .WORD   PSUB            ; FPREG = <last> - FPREG
 430  03F5
 431  03F5 7C                   .BYTE   7CH             ; Precedence value
 432  03F6 97 16                .WORD   MULT            ; PPREG = <last> * FPREG
 433  03F8
 434  03F8 7C                   .BYTE   7CH             ; Precedence value
 435  03F9 F8 16                .WORD   DIV             ; FPREG = <last> / FPREG
 436  03FB
 437  03FB 7F                   .BYTE   7FH             ; Precedence value
 438  03FC 46 1A                .WORD   POWER           ; FPREG = <last> ^ FPREG
 439  03FE
 440  03FE 50                   .BYTE   50H             ; Precedence value
 441  03FF 0C 0F                .WORD   PAND            ; FPREG = <last> AND FPREG
 442  0401
 443  0401 46                   .BYTE   46H             ; Precedence value
 444  0402 0B 0F                .WORD   POR             ; FPREG = <last> OR FPREG
 445  0404
 446  0404              ; BASIC ERROR CODE LIST
 447  0404
 448  0404 4E 46        ERRORS: .BYTE   "NF"            ; NEXT without FOR
 449  0406 53 4E                .BYTE   "SN"            ; Syntax error
 450  0408 52 47                .BYTE   "RG"            ; RETURN without GOSUB
 451  040A 4F 44                .BYTE   "OD"            ; Out of DATA
 452  040C 46 43                .BYTE   "FC"            ; Illegal function call
 453  040E 4F 56                .BYTE   "OV"            ; Overflow error
 454  0410 4F 4D                .BYTE   "OM"            ; Out of memory
 455  0412 55 4C                .BYTE   "UL"            ; Undefined line
 456  0414 42 53                .BYTE   "BS"            ; Bad subscript
 457  0416 44 44                .BYTE   "DD"            ; Re-DIMensioned array
 458  0418 2F 30                .BYTE   "/0"            ; Division by zero
 459  041A 49 44                .BYTE   "ID"            ; Illegal direct
 460  041C 54 4D                .BYTE   "TM"            ; Type mis-match
 461  041E 4F 53                .BYTE   "OS"            ; Out of string space
 462  0420 4C 53                .BYTE   "LS"            ; String too long
 463  0422 53 54                .BYTE   "ST"            ; String formula too complex
 464  0424 43 4E                .BYTE   "CN"            ; Can't CONTinue
 465  0426 55 46                .BYTE   "UF"            ; Undefined FN function
 466  0428 4D 4F                .BYTE   "MO"            ; Missing operand
 467  042A 48 58                .BYTE   "HX"            ; HEX error
 468  042C 42 4E                .BYTE   "BN"            ; BIN error
 469  042E
 470  042E              ; INITIALISATION TABLE -------------------------------------------------------
 471  042E
 472  042E C3 F4 01     INITAB: JP      WARMST          ; Warm start jump
 473  0431 C3 1C 0A             JP      FCERR           ; "USR (X)" jump (Set to Error)
 474  0434 D3 00                OUT     (0),A           ; "OUT p,n" skeleton
 475  0436 C9                   RET
 476  0437 D6 00                SUB     0               ; Division support routine
 477  0439 6F                   LD      L,A
 478  043A 7C                   LD      A,H
 479  043B DE 00                SBC     A,0
 480  043D 67                   LD      H,A
 481  043E 78                   LD      A,B
 482  043F DE 00                SBC     A,0
 483  0441 47                   LD      B,A
 484  0442 3E 00                LD      A,0
 485  0444 C9                   RET
 486  0445 00 00 00             .BYTE   0,0,0                   ; Random number seed table used by RND
 487  0448 35 4A CA 99          .BYTE   035H,04AH,0CAH,099H     ;-2.65145E+07
 488  044C 39 1C 76 98          .BYTE   039H,01CH,076H,098H     ; 1.61291E+07
 489  0450 22 95 B3 98          .BYTE   022H,095H,0B3H,098H     ;-1.17691E+07
 490  0454 0A DD 47 98          .BYTE   00AH,0DDH,047H,098H     ; 1.30983E+07
 491  0458 53 D1 99 99          .BYTE   053H,0D1H,099H,099H     ;-2-01612E+07
 492  045C 0A 1A 9F 98          .BYTE   00AH,01AH,09FH,098H     ;-1.04269E+07
 493  0460 65 BC CD 98          .BYTE   065H,0BCH,0CDH,098H     ;-1.34831E+07
 494  0464 D6 77 3E 98          .BYTE   0D6H,077H,03EH,098H     ; 1.24825E+07
 495  0468 52 C7 4F 80          .BYTE   052H,0C7H,04FH,080H     ; Last random number
 496  046C DB 00                IN      A,(0)           ; INP (x) skeleton
 497  046E C9                   RET
 498  046F 01                   .BYTE   1               ; POS (x) number (1)
 499  0470 FF                   .BYTE   255             ; Terminal width (255 = no auto CRLF)
 500  0471 1C                   .BYTE   28              ; Width for commas (3 columns)
 501  0472 00                   .BYTE   0               ; No nulls after input bytes
 502  0473 00                   .BYTE   0               ; Output enabled (^O off)
 503  0474 14 00                .WORD   20              ; Initial lines counter
 504  0476 14 00                .WORD   20              ; Initial lines number
 505  0478 00 00                .WORD   0               ; Array load/save check sum
 506  047A 00                   .BYTE   0               ; Break not by NMI
 507  047B 00                   .BYTE   0               ; Break flag
 508  047C C3 42 07             JP      TTYLIN          ; Input reflection (set to TTY)
 509  047F C3 00 00             JP      $0000           ; POINT reflection unused
 510  0482 C3 00 00             JP      $0000           ; SET reflection
 511  0485 C3 00 00             JP      $0000          	; RESET reflection
 512  0488 A2 21                .WORD   STLOOK          ; Temp string space
 513  048A FE FF                .WORD   -2              ; Current line number (cold)
 514  048C 3F 21                .WORD   PROGST+1        ; Start of program text
 515  048E              INITBE:
 516  048E
 517  048E              ; END OF INITIALISATION TABLE ---------------------------------------------------
 518  048E
 519  048E 20 45 72 72  ERRMSG: .BYTE   " Error",0
 519  0492 6F 72 00
 520  0495 20 69 6E 20  INMSG:  .BYTE   " in ",0
 520  0499 00
 521  049A              ZERBYT  .EQU    $-1             ; A zero byte
 522  049A 4F 6B 0D 0A  OKMSG:  .BYTE   "Ok",CR,LF,0,0
 522  049E 00 00
 523  04A0 42 72 65 61  BRKMSG: .BYTE   "Break",0
 523  04A4 6B 00
 524  04A6
 525  04A6 21 04 00     BAKSTK: LD      HL,4            ; Look for "FOR" block with
 526  04A9 39                   ADD     HL,SP           ; same index as specified
 527  04AA 7E           LOKFOR: LD      A,(HL)          ; Get block ID
 528  04AB 23                   INC     HL              ; Point to index address
 529  04AC FE 81                CP      ZFOR            ; Is it a "FOR" token
 530  04AE C0                   RET     NZ              ; No - exit
 531  04AF 4E                   LD      C,(HL)          ; BC = Address of "FOR" index
 532  04B0 23                   INC     HL
 533  04B1 46                   LD      B,(HL)
 534  04B2 23                   INC     HL              ; Point to sign of STEP
 535  04B3 E5                   PUSH    HL              ; Save pointer to sign
 536  04B4 69                   LD      L,C             ; HL = address of "FOR" index
 537  04B5 60                   LD      H,B
 538  04B6 7A                   LD      A,D             ; See if an index was specified
 539  04B7 B3                   OR      E               ; DE = 0 if no index specified
 540  04B8 EB                   EX      DE,HL           ; Specified index into HL
 541  04B9 CA C0 04             JP      Z,INDFND        ; Skip if no index given
 542  04BC EB                   EX      DE,HL           ; Index back into DE
 543  04BD CD C5 07             CALL    CPDEHL          ; Compare index with one given
 544  04C0 01 0D 00     INDFND: LD      BC,16-3         ; Offset to next block
 545  04C3 E1                   POP     HL              ; Restore pointer to sign
 546  04C4 C8                   RET     Z               ; Return if block found
 547  04C5 09                   ADD     HL,BC           ; Point to next block
 548  04C6 C3 AA 04             JP      LOKFOR          ; Keep on looking
 549  04C9
 550  04C9 CD E3 04     MOVUP:  CALL    ENFMEM          ; See if enough memory
 551  04CC C5           MOVSTR: PUSH    BC              ; Save end of source
 552  04CD E3                   EX      (SP),HL         ; Swap source and dest" end
 553  04CE C1                   POP     BC              ; Get end of destination
 554  04CF CD C5 07     MOVLP:  CALL    CPDEHL          ; See if list moved
 555  04D2 7E                   LD      A,(HL)          ; Get byte
 556  04D3 02                   LD      (BC),A          ; Move it
 557  04D4 C8                   RET     Z               ; Exit if all done
 558  04D5 0B                   DEC     BC              ; Next byte to move to
 559  04D6 2B                   DEC     HL              ; Next byte to move
 560  04D7 C3 CF 04             JP      MOVLP           ; Loop until all bytes moved
 561  04DA
 562  04DA E5           CHKSTK: PUSH    HL              ; Save code string address
 563  04DB 2A 1F 21             LD      HL,(ARREND)     ; Lowest free memory
 564  04DE 06 00                LD      B,0             ; BC = Number of levels to test
 565  04E0 09                   ADD     HL,BC           ; 2 Bytes for each level
 566  04E1 09                   ADD     HL,BC
 567  04E2 3E                   .BYTE   3EH             ; Skip "PUSH HL"
 568  04E3 E5           ENFMEM: PUSH    HL              ; Save code string address
 569  04E4 3E D0                LD      A,0D0H ;LOW -48 ; 48 Bytes minimum RAM
 570  04E6 95                   SUB     L
 571  04E7 6F                   LD      L,A
 572  04E8 3E FF                LD      A,0FFH; HIGH (-48) ; 48 Bytes minimum RAM
 573  04EA 9C                   SBC     A,H
 574  04EB DA F2 04             JP      C,OMERR         ; Not enough - ?OM Error
 575  04EE 67                   LD      H,A
 576  04EF 39                   ADD     HL,SP           ; Test if stack is overflowed
 577  04F0 E1                   POP     HL              ; Restore code string address
 578  04F1 D8                   RET     C               ; Return if enough mmory
 579  04F2 1E 0C        OMERR:  LD      E,OM            ; ?OM Error
 580  04F4 C3 11 05             JP      ERROR
 581  04F7
 582  04F7 2A 0E 21     DATSNR: LD      HL,(DATLIN)     ; Get line of current DATA item
 583  04FA 22 A1 20             LD      (LINEAT),HL     ; Save as current line
 584  04FD 1E 02        SNERR:  LD      E,SN            ; ?SN Error
 585  04FF 01                   .BYTE   01H             ; Skip "LD E,DZ"
 586  0500 1E 14        DZERR:  LD      E,DZ            ; ?/0 Error
 587  0502 01                   .BYTE   01H             ; Skip "LD E,NF"
 588  0503 1E 00        NFERR:  LD      E,NF            ; ?NF Error
 589  0505 01                   .BYTE   01H             ; Skip "LD E,DD"
 590  0506 1E 12        DDERR:  LD      E,DD            ; ?DD Error
 591  0508 01                   .BYTE   01H             ; Skip "LD E,UF"
 592  0509 1E 22        UFERR:  LD      E,UF            ; ?UF Error
 593  050B 01                   .BYTE   01H             ; Skip "LD E,OV
 594  050C 1E 0A        OVERR:  LD      E,OV            ; ?OV Error
 595  050E 01                   .BYTE   01H             ; Skip "LD E,TM"
 596  050F 1E 18        TMERR:  LD      E,TM            ; ?TM Error
 597  0511
 598  0511 CD 2F 06     ERROR:  CALL    CLREG           ; Clear registers and stack
 599  0514 32 8A 20             LD      (CTLOFG),A      ; Enable output (A is 0)
 600  0517 CD F0 0B             CALL    STTLIN          ; Start new line
 601  051A 21 04 04             LD      HL,ERRORS       ; Point to error codes
 602  051D 57                   LD      D,A             ; D = 0 (A is 0)
 603  051E 3E 3F                LD      A,'?'
 604  0520 CD D6 07             CALL    OUTC            ; Output '?'
 605  0523 19                   ADD     HL,DE           ; Offset to correct error code
 606  0524 7E                   LD      A,(HL)          ; First character
 607  0525 CD D6 07             CALL    OUTC            ; Output it
 608  0528 CD 55 09             CALL    GETCHR          ; Get next character
 609  052B CD D6 07             CALL    OUTC            ; Output it
 610  052E 21 8E 04             LD      HL,ERRMSG       ; "Error" message
 611  0531 CD 9B 12     ERRIN:  CALL    PRS             ; Output message
 612  0534 2A A1 20             LD      HL,(LINEAT)     ; Get line of error
 613  0537 11 FE FF             LD      DE,-2           ; Cold start error if -2
 614  053A CD C5 07             CALL    CPDEHL          ; See if cold start error
 615  053D CA 61 01             JP      Z,CSTART        ; Cold start error - Restart
 616  0540 7C                   LD      A,H             ; Was it a direct error?
 617  0541 A5                   AND     L               ; Line = -1 if direct error
 618  0542 3C                   INC     A
 619  0543 C4 36 19             CALL    NZ,LINEIN       ; No - output line of error
 620  0546 3E                   .BYTE   3EH             ; Skip "POP BC"
 621  0547 C1           POPNOK: POP     BC              ; Drop address in input buffer
 622  0548
 623  0548 AF           PRNTOK: XOR     A               ; Output "Ok" and get command
 624  0549 32 8A 20             LD      (CTLOFG),A      ; Enable output
 625  054C CD F0 0B             CALL    STTLIN          ; Start new line
 626  054F 21 9A 04             LD      HL,OKMSG        ; "Ok" message
 627  0552 CD 9B 12             CALL    PRS             ; Output "Ok"
 628  0555 21 FF FF     GETCMD: LD      HL,-1           ; Flag direct mode
 629  0558 22 A1 20             LD      (LINEAT),HL     ; Save as current line
 630  055B CD 42 07             CALL    GETLIN          ; Get an input line
 631  055E DA 55 05             JP      C,GETCMD        ; Get line again if break
 632  0561 CD 55 09             CALL    GETCHR          ; Get first character
 633  0564 3C                   INC     A               ; Test if end of line
 634  0565 3D                   DEC     A               ; Without affecting Carry
 635  0566 CA 55 05             JP      Z,GETCMD        ; Nothing entered - Get another
 636  0569 F5                   PUSH    AF              ; Save Carry status
 637  056A CD 21 0A             CALL    ATOH            ; Get line number into DE
 638  056D D5                   PUSH    DE              ; Save line number
 639  056E CD 59 06             CALL    CRUNCH          ; Tokenise rest of line
 640  0571 47                   LD      B,A             ; Length of tokenised line
 641  0572 D1                   POP     DE              ; Restore line number
 642  0573 F1                   POP     AF              ; Restore Carry
 643  0574 D2 35 09             JP      NC,EXCUTE       ; No line number - Direct mode
 644  0577 D5                   PUSH    DE              ; Save line number
 645  0578 C5                   PUSH    BC              ; Save length of tokenised line
 646  0579 AF                   XOR     A
 647  057A 32 11 21             LD      (LSTBIN),A      ; Clear last byte input
 648  057D CD 55 09             CALL    GETCHR          ; Get next character
 649  0580 B7                   OR      A               ; Set flags
 650  0581 F5                   PUSH    AF              ; And save them
 651  0582 CD E9 05             CALL    SRCHLN          ; Search for line number in DE
 652  0585 DA 8E 05             JP      C,LINFND        ; Jump if line found
 653  0588 F1                   POP     AF              ; Get status
 654  0589 F5                   PUSH    AF              ; And re-save
 655  058A CA C2 0A             JP      Z,ULERR         ; Nothing after number - Error
 656  058D B7                   OR      A               ; Clear Carry
 657  058E C5           LINFND: PUSH    BC              ; Save address of line in prog
 658  058F D2 A5 05             JP      NC,INEWLN       ; Line not found - Insert new
 659  0592 EB                   EX      DE,HL           ; Next line address in DE
 660  0593 2A 1B 21             LD      HL,(PROGND)     ; End of program
 661  0596 1A           SFTPRG: LD      A,(DE)          ; Shift rest of program down
 662  0597 02                   LD      (BC),A
 663  0598 03                   INC     BC              ; Next destination
 664  0599 13                   INC     DE              ; Next source
 665  059A CD C5 07             CALL    CPDEHL          ; All done?
 666  059D C2 96 05             JP      NZ,SFTPRG       ; More to do
 667  05A0 60                   LD      H,B             ; HL - New end of program
 668  05A1 69                   LD      L,C
 669  05A2 22 1B 21             LD      (PROGND),HL     ; Update end of program
 670  05A5
 671  05A5 D1           INEWLN: POP     DE              ; Get address of line,
 672  05A6 F1                   POP     AF              ; Get status
 673  05A7 CA CC 05             JP      Z,SETPTR        ; No text - Set up pointers
 674  05AA 2A 1B 21             LD      HL,(PROGND)     ; Get end of program
 675  05AD E3                   EX      (SP),HL         ; Get length of input line
 676  05AE C1                   POP     BC              ; End of program to BC
 677  05AF 09                   ADD     HL,BC           ; Find new end
 678  05B0 E5                   PUSH    HL              ; Save new end
 679  05B1 CD C9 04             CALL    MOVUP           ; Make space for line
 680  05B4 E1                   POP     HL              ; Restore new end
 681  05B5 22 1B 21             LD      (PROGND),HL     ; Update end of program pointer
 682  05B8 EB                   EX      DE,HL           ; Get line to move up in HL
 683  05B9 74                   LD      (HL),H          ; Save MSB
 684  05BA D1                   POP     DE              ; Get new line number
 685  05BB 23                   INC     HL              ; Skip pointer
 686  05BC 23                   INC     HL
 687  05BD 73                   LD      (HL),E          ; Save LSB of line number
 688  05BE 23                   INC     HL
 689  05BF 72                   LD      (HL),D          ; Save MSB of line number
 690  05C0 23                   INC     HL              ; To first byte in line
 691  05C1 11 A6 20             LD      DE,BUFFER       ; Copy buffer to program
 692  05C4 1A           MOVBUF: LD      A,(DE)          ; Get source
 693  05C5 77                   LD      (HL),A          ; Save destinations
 694  05C6 23                   INC     HL              ; Next source
 695  05C7 13                   INC     DE              ; Next destination
 696  05C8 B7                   OR      A               ; Done?
 697  05C9 C2 C4 05             JP      NZ,MOVBUF       ; No - Repeat
 698  05CC CD 15 06     SETPTR: CALL    RUNFST          ; Set line pointers
 699  05CF 23                   INC     HL              ; To LSB of pointer
 700  05D0 EB                   EX      DE,HL           ; Address to DE
 701  05D1 62           PTRLP:  LD      H,D             ; Address to HL
 702  05D2 6B                   LD      L,E
 703  05D3 7E                   LD      A,(HL)          ; Get LSB of pointer
 704  05D4 23                   INC     HL              ; To MSB of pointer
 705  05D5 B6                   OR      (HL)            ; Compare with MSB pointer
 706  05D6 CA 55 05             JP      Z,GETCMD        ; Get command line if end
 707  05D9 23                   INC     HL              ; To LSB of line number
 708  05DA 23                   INC     HL              ; Skip line number
 709  05DB 23                   INC     HL              ; Point to first byte in line
 710  05DC AF                   XOR     A               ; Looking for 00 byte
 711  05DD BE           FNDEND: CP      (HL)            ; Found end of line?
 712  05DE 23                   INC     HL              ; Move to next byte
 713  05DF C2 DD 05             JP      NZ,FNDEND       ; No - Keep looking
 714  05E2 EB                   EX      DE,HL           ; Next line address to HL
 715  05E3 73                   LD      (HL),E          ; Save LSB of pointer
 716  05E4 23                   INC     HL
 717  05E5 72                   LD      (HL),D          ; Save MSB of pointer
 718  05E6 C3 D1 05             JP      PTRLP           ; Do next line
 719  05E9
 720  05E9 2A A3 20     SRCHLN: LD      HL,(BASTXT)     ; Start of program text
 721  05EC 44           SRCHLP: LD      B,H             ; BC = Address to look at
 722  05ED 4D                   LD      C,L
 723  05EE 7E                   LD      A,(HL)          ; Get address of next line
 724  05EF 23                   INC     HL
 725  05F0 B6                   OR      (HL)            ; End of program found?
 726  05F1 2B                   DEC     HL
 727  05F2 C8                   RET     Z               ; Yes - Line not found
 728  05F3 23                   INC     HL
 729  05F4 23                   INC     HL
 730  05F5 7E                   LD      A,(HL)          ; Get LSB of line number
 731  05F6 23                   INC     HL
 732  05F7 66                   LD      H,(HL)          ; Get MSB of line number
 733  05F8 6F                   LD      L,A
 734  05F9 CD C5 07             CALL    CPDEHL          ; Compare with line in DE
 735  05FC 60                   LD      H,B             ; HL = Start of this line
 736  05FD 69                   LD      L,C
 737  05FE 7E                   LD      A,(HL)          ; Get LSB of next line address
 738  05FF 23                   INC     HL
 739  0600 66                   LD      H,(HL)          ; Get MSB of next line address
 740  0601 6F                   LD      L,A             ; Next line to HL
 741  0602 3F                   CCF
 742  0603 C8                   RET     Z               ; Lines found - Exit
 743  0604 3F                   CCF
 744  0605 D0                   RET     NC              ; Line not found,at line after
 745  0606 C3 EC 05             JP      SRCHLP          ; Keep looking
 746  0609
 747  0609 C0           NEW:    RET     NZ              ; Return if any more on line
 748  060A 2A A3 20     CLRPTR: LD      HL,(BASTXT)     ; Point to start of program
 749  060D AF                   XOR     A               ; Set program area to empty
 750  060E 77                   LD      (HL),A          ; Save LSB = 00
 751  060F 23                   INC     HL
 752  0610 77                   LD      (HL),A          ; Save MSB = 00
 753  0611 23                   INC     HL
 754  0612 22 1B 21             LD      (PROGND),HL     ; Set program end
 755  0615
 756  0615 2A A3 20     RUNFST: LD      HL,(BASTXT)     ; Clear all variables
 757  0618 2B                   DEC     HL
 758  0619
 759  0619 22 13 21     INTVAR: LD      (BRKLIN),HL     ; Initialise RUN variables
 760  061C 2A F4 20             LD      HL,(LSTRAM)     ; Get end of RAM
 761  061F 22 08 21             LD      (STRBOT),HL     ; Clear string space
 762  0622 AF                   XOR     A
 763  0623 CD 65 09             CALL    RESTOR          ; Reset DATA pointers
 764  0626 2A 1B 21             LD      HL,(PROGND)     ; Get end of program
 765  0629 22 1D 21             LD      (VAREND),HL     ; Clear variables
 766  062C 22 1F 21             LD      (ARREND),HL     ; Clear arrays
 767  062F
 768  062F C1           CLREG:  POP     BC              ; Save return address
 769  0630 2A 9F 20             LD      HL,(STRSPC)     ; Get end of working RAN
 770  0633 F9                   LD      SP,HL           ; Set stack
 771  0634 21 F8 20             LD      HL,TMSTPL       ; Temporary string pool
 772  0637 22 F6 20             LD      (TMSTPT),HL     ; Reset temporary string ptr
 773  063A AF                   XOR     A               ; A = 00
 774  063B 6F                   LD      L,A             ; HL = 0000
 775  063C 67                   LD      H,A
 776  063D 22 19 21             LD      (CONTAD),HL     ; No CONTinue
 777  0640 32 10 21             LD      (FORFLG),A      ; Clear FOR flag
 778  0643 22 23 21             LD      (FNRGNM),HL     ; Clear FN argument
 779  0646 E5                   PUSH    HL              ; HL = 0000
 780  0647 C5                   PUSH    BC              ; Put back return
 781  0648 2A 13 21     DOAGN:  LD      HL,(BRKLIN)     ; Get address of code to RUN
 782  064B C9                   RET                     ; Return to execution driver
 783  064C
 784  064C 3E 3F        PROMPT: LD      A,'?'           ; '?'
 785  064E CD D6 07             CALL    OUTC            ; Output character
 786  0651 3E 20                LD      A,' '           ; Space
 787  0653 CD D6 07             CALL    OUTC            ; Output character
 788  0656 C3 93 20             JP      RINPUT          ; Get input line
 789  0659
 790  0659 AF           CRUNCH: XOR     A               ; Tokenise line @ HL to BUFFER
 791  065A 32 F3 20             LD      (DATFLG),A      ; Reset literal flag
 792  065D 0E 05                LD      C,2+3           ; 2 byte number and 3 nulls
 793  065F 11 A6 20             LD      DE,BUFFER       ; Start of input buffer
 794  0662 7E           CRNCLP: LD      A,(HL)          ; Get byte
 795  0663 FE 20                CP      ' '             ; Is it a space?
 796  0665 CA E1 06             JP      Z,MOVDIR        ; Yes - Copy direct
 797  0668 47                   LD      B,A             ; Save character
 798  0669 FE 22                CP      '"'             ; Is it a quote?
 799  066B CA 01 07             JP      Z,CPYLIT        ; Yes - Copy literal string
 800  066E B7                   OR      A               ; Is it end of buffer?
 801  066F CA 08 07             JP      Z,ENDBUF        ; Yes - End buffer
 802  0672 3A F3 20             LD      A,(DATFLG)      ; Get data type
 803  0675 B7                   OR      A               ; Literal?
 804  0676 7E                   LD      A,(HL)          ; Get byte to copy
 805  0677 C2 E1 06             JP      NZ,MOVDIR       ; Literal - Copy direct
 806  067A FE 3F                CP      '?'             ; Is it '?' short for PRINT
 807  067C 3E 9E                LD      A,ZPRINT        ; "PRINT" token
 808  067E CA E1 06             JP      Z,MOVDIR        ; Yes - replace it
 809  0681 7E                   LD      A,(HL)          ; Get byte again
 810  0682 FE 30                CP      '0'             ; Is it less than '0'
 811  0684 DA 8C 06             JP      C,FNDWRD        ; Yes - Look for reserved words
 812  0687 FE 3C                CP      60; ";"+1           ; Is it "0123456789:;" ?
 813  0689 DA E1 06             JP      C,MOVDIR        ; Yes - copy it direct
 814  068C D5           FNDWRD: PUSH    DE              ; Look for reserved words
 815  068D 11 85 02             LD      DE,WORDS-1      ; Point to table
 816  0690 C5                   PUSH    BC              ; Save count
 817  0691 01 DD 06             LD      BC,RETNAD       ; Where to return to
 818  0694 C5                   PUSH    BC              ; Save return address
 819  0695 06 7F                LD      B,ZEND-1        ; First token value -1
 820  0697 7E                   LD      A,(HL)          ; Get byte
 821  0698 FE 61                CP      'a'             ; Less than 'a' ?
 822  069A DA A5 06             JP      C,SEARCH        ; Yes - search for words
 823  069D FE 7B                CP      'z'+1           ; Greater than 'z' ?
 824  069F D2 A5 06             JP      NC,SEARCH       ; Yes - search for words
 825  06A2 E6 5F                AND     01011111B       ; Force upper case
 826  06A4 77                   LD      (HL),A          ; Replace byte
 827  06A5 4E           SEARCH: LD      C,(HL)          ; Search for a word
 828  06A6 EB                   EX      DE,HL
 829  06A7 23           GETNXT: INC     HL              ; Get next reserved word
 830  06A8 B6                   OR      (HL)            ; Start of word?
 831  06A9 F2 A7 06             JP      P,GETNXT        ; No - move on
 832  06AC 04                   INC     B               ; Increment token value
 833  06AD 7E                   LD      A, (HL)         ; Get byte from table
 834  06AE E6 7F                AND     01111111B       ; Strip bit 7
 835  06B0 C8                   RET     Z               ; Return if end of list
 836  06B1 B9                   CP      C               ; Same character as in buffer?
 837  06B2 C2 A7 06             JP      NZ,GETNXT       ; No - get next word
 838  06B5 EB                   EX      DE,HL
 839  06B6 E5                   PUSH    HL              ; Save start of word
 840  06B7
 841  06B7 13           NXTBYT: INC     DE              ; Look through rest of word
 842  06B8 1A                   LD      A,(DE)          ; Get byte from table
 843  06B9 B7                   OR      A               ; End of word ?
 844  06BA FA D9 06             JP      M,MATCH         ; Yes - Match found
 845  06BD 4F                   LD      C,A             ; Save it
 846  06BE 78                   LD      A,B             ; Get token value
 847  06BF FE 88                CP      ZGOTO           ; Is it "GOTO" token ?
 848  06C1 C2 C8 06             JP      NZ,NOSPC        ; No - Don't allow spaces
 849  06C4 CD 55 09             CALL    GETCHR          ; Get next character
 850  06C7 2B                   DEC     HL              ; Cancel increment from GETCHR
 851  06C8 23           NOSPC:  INC     HL              ; Next byte
 852  06C9 7E                   LD      A,(HL)          ; Get byte
 853  06CA FE 61                CP      'a'             ; Less than 'a' ?
 854  06CC DA D1 06             JP      C,NOCHNG        ; Yes - don't change
 855  06CF E6 5F                AND     01011111B       ; Make upper case
 856  06D1 B9           NOCHNG: CP      C               ; Same as in buffer ?
 857  06D2 CA B7 06             JP      Z,NXTBYT        ; Yes - keep testing
 858  06D5 E1                   POP     HL              ; Get back start of word
 859  06D6 C3 A5 06             JP      SEARCH          ; Look at next word
 860  06D9
 861  06D9 48           MATCH:  LD      C,B             ; Word found - Save token value
 862  06DA F1                   POP     AF              ; Throw away return
 863  06DB EB                   EX      DE,HL
 864  06DC C9                   RET                     ; Return to "RETNAD"
 865  06DD EB           RETNAD: EX      DE,HL           ; Get address in string
 866  06DE 79                   LD      A,C             ; Get token value
 867  06DF C1                   POP     BC              ; Restore buffer length
 868  06E0 D1                   POP     DE              ; Get destination address
 869  06E1 23           MOVDIR: INC     HL              ; Next source in buffer
 870  06E2 12                   LD      (DE),A          ; Put byte in buffer
 871  06E3 13                   INC     DE              ; Move up buffer
 872  06E4 0C                   INC     C               ; Increment length of buffer
 873  06E5 D6 3A                SUB     ':'             ; End of statement?
 874  06E7 CA EF 06             JP      Z,SETLIT        ; Jump if multi-statement line
 875  06EA FE 49                CP      ZDATA-3AH       ; Is it DATA statement ?
 876  06EC C2 F2 06             JP      NZ,TSTREM       ; No - see if REM
 877  06EF 32 F3 20     SETLIT: LD      (DATFLG),A      ; Set literal flag
 878  06F2 D6 54        TSTREM: SUB     ZREM-3AH        ; Is it REM?
 879  06F4 C2 62 06             JP      NZ,CRNCLP       ; No - Leave flag
 880  06F7 47                   LD      B,A             ; Copy rest of buffer
 881  06F8 7E           NXTCHR: LD      A,(HL)          ; Get byte
 882  06F9 B7                   OR      A               ; End of line ?
 883  06FA CA 08 07             JP      Z,ENDBUF        ; Yes - Terminate buffer
 884  06FD B8                   CP      B               ; End of statement ?
 885  06FE CA E1 06             JP      Z,MOVDIR        ; Yes - Get next one
 886  0701 23           CPYLIT: INC     HL              ; Move up source string
 887  0702 12                   LD      (DE),A          ; Save in destination
 888  0703 0C                   INC     C               ; Increment length
 889  0704 13                   INC     DE              ; Move up destination
 890  0705 C3 F8 06             JP      NXTCHR          ; Repeat
 891  0708
 892  0708 21 A5 20     ENDBUF: LD      HL,BUFFER-1     ; Point to start of buffer
 893  070B 12                   LD      (DE),A          ; Mark end of buffer (A = 00)
 894  070C 13                   INC     DE
 895  070D 12                   LD      (DE),A          ; A = 00
 896  070E 13                   INC     DE
 897  070F 12                   LD      (DE),A          ; A = 00
 898  0710 C9                   RET
 899  0711
 900  0711 3A 89 20     DODEL:  LD      A,(NULFLG)      ; Get null flag status
 901  0714 B7                   OR      A               ; Is it zero?
 902  0715 3E 00                LD      A,0             ; Zero A - Leave flags
 903  0717 32 89 20             LD      (NULFLG),A      ; Zero null flag
 904  071A C2 25 07             JP      NZ,ECHDEL       ; Set - Echo it
 905  071D 05                   DEC     B               ; Decrement length
 906  071E CA 42 07             JP      Z,GETLIN        ; Get line again if empty
 907  0721 CD D6 07             CALL    OUTC            ; Output null character
 908  0724 3E                   .BYTE   3EH             ; Skip "DEC B"
 909  0725 05           ECHDEL: DEC     B               ; Count bytes in buffer
 910  0726 2B                   DEC     HL              ; Back space buffer
 911  0727 CA 39 07             JP      Z,OTKLN         ; No buffer - Try again
 912  072A 7E                   LD      A,(HL)          ; Get deleted byte
 913  072B CD D6 07             CALL    OUTC            ; Echo it
 914  072E C3 4B 07             JP      MORINP          ; Get more input
 915  0731
 916  0731 05           DELCHR: DEC     B               ; Count bytes in buffer
 917  0732 2B                   DEC     HL              ; Back space buffer
 918  0733 CD D6 07             CALL    OUTC            ; Output character in A
 919  0736 C2 4B 07             JP      NZ,MORINP       ; Not end - Get more
 920  0739 CD D6 07     OTKLN:  CALL    OUTC            ; Output character in A
 921  073C CD FD 0B     KILIN:  CALL    PRNTCRLF        ; Output CRLF
 922  073F C3 42 07             JP      TTYLIN          ; Get line again
 923  0742
 924  0742              GETLIN:
 925  0742 21 A6 20     TTYLIN: LD      HL,BUFFER       ; Get a line by character
 926  0745 06 01                LD      B,1             ; Set buffer as empty
 927  0747 AF                   XOR     A
 928  0748 32 89 20             LD      (NULFLG),A      ; Clear null flag
 929  074B CD 00 08     MORINP: CALL    CLOTST          ; Get character and test ^O
 930  074E 4F                   LD      C,A             ; Save character in C
 931  074F FE 7F                CP      DEL             ; Delete character?
 932  0751 CA 11 07             JP      Z,DODEL         ; Yes - Process it
 933  0754 3A 89 20             LD      A,(NULFLG)      ; Get null flag
 934  0757 B7                   OR      A               ; Test null flag status
 935  0758 CA 64 07             JP      Z,PROCES        ; Reset - Process character
 936  075B 3E 00                LD      A,0             ; Set a null
 937  075D CD D6 07             CALL    OUTC            ; Output null
 938  0760 AF                   XOR     A               ; Clear A
 939  0761 32 89 20             LD      (NULFLG),A      ; Reset null flag
 940  0764 79           PROCES: LD      A,C             ; Get character
 941  0765 FE 07                CP      CTRLG           ; Bell?
 942  0767 CA A8 07             JP      Z,PUTCTL        ; Yes - Save it
 943  076A FE 03                CP      CTRLC           ; Is it control "C"?
 944  076C CC FD 0B             CALL    Z,PRNTCRLF      ; Yes - Output CRLF
 945  076F 37                   SCF                     ; Flag break
 946  0770 C8                   RET     Z               ; Return if control "C"
 947  0771 FE 0D                CP      CR1              ; Is it enter?
 948  0773 CA F8 0B             JP      Z,ENDINP        ; Yes - Terminate input
 949  0776 FE 15                CP      CTRLU           ; Is it control "U"?
 950  0778 CA 3C 07             JP      Z,KILIN         ; Yes - Get another line
 951  077B FE 40                CP      '@'             ; Is it "kill line"?
 952  077D CA 39 07             JP      Z,OTKLN         ; Yes - Kill line
 953  0780 FE 5F                CP      '_'             ; Is it delete?
 954  0782 CA 31 07             JP      Z,DELCHR        ; Yes - Delete character
 955  0785 FE 08                CP      BKSP            ; Is it backspace?
 956  0787 CA 31 07             JP      Z,DELCHR        ; Yes - Delete character
 957  078A FE 12                CP      CTRLR           ; Is it control "R"?
 958  078C C2 A3 07             JP      NZ,PUTBUF       ; No - Put in buffer
 959  078F C5                   PUSH    BC              ; Save buffer length
 960  0790 D5                   PUSH    DE              ; Save DE
 961  0791 E5                   PUSH    HL              ; Save buffer address
 962  0792 36 00                LD      (HL),0          ; Mark end of buffer
 963  0794 CD AD 1D             CALL    OUTNCR          ; Output and do CRLF
 964  0797 21 A6 20             LD      HL,BUFFER       ; Point to buffer start
 965  079A CD 9B 12             CALL    PRS             ; Output buffer
 966  079D E1                   POP     HL              ; Restore buffer address
 967  079E D1                   POP     DE              ; Restore DE
 968  079F C1                   POP     BC              ; Restore buffer length
 969  07A0 C3 4B 07             JP      MORINP          ; Get another character
 970  07A3
 971  07A3 FE 20        PUTBUF: CP      ' '             ; Is it a control code?
 972  07A5 DA 4B 07             JP      C,MORINP        ; Yes - Ignore
 973  07A8 78           PUTCTL: LD      A,B             ; Get number of bytes in buffer
 974  07A9 FE 49                CP      72+1            ; Test for line overflow
 975  07AB 3E 07                LD      A,CTRLG         ; Set a bell
 976  07AD D2 BD 07             JP      NC,OUTNBS       ; Ring bell if buffer full
 977  07B0 79                   LD      A,C             ; Get character
 978  07B1 71                   LD      (HL),C          ; Save in buffer
 979  07B2 32 11 21             LD      (LSTBIN),A      ; Save last input byte
 980  07B5 23                   INC     HL              ; Move up buffer
 981  07B6 04                   INC     B               ; Increment length
 982  07B7 CD D6 07     OUTIT:  CALL    OUTC            ; Output the character entered
 983  07BA C3 4B 07             JP      MORINP          ; Get another character
 984  07BD
 985  07BD CD D6 07     OUTNBS: CALL    OUTC            ; Output bell and back over it
 986  07C0 3E 08                LD      A,BKSP          ; Set back space
 987  07C2 C3 B7 07             JP      OUTIT           ; Output it and get more
 988  07C5
 989  07C5 7C           CPDEHL: LD      A,H             ; Get H
 990  07C6 92                   SUB     D               ; Compare with D
 991  07C7 C0                   RET     NZ              ; Different - Exit
 992  07C8 7D                   LD      A,L             ; Get L
 993  07C9 93                   SUB     E               ; Compare with E
 994  07CA C9                   RET                     ; Return status
 995  07CB
 996  07CB 7E           CHKSYN: LD      A,(HL)          ; Check syntax of character
 997  07CC E3                   EX      (SP),HL         ; Address of test byte
 998  07CD BE                   CP      (HL)            ; Same as in code string?
 999  07CE 23                   INC     HL              ; Return address
1000  07CF E3                   EX      (SP),HL         ; Put it back
1001  07D0 CA 55 09             JP      Z,GETCHR        ; Yes - Get next character
1002  07D3 C3 FD 04             JP      SNERR           ; Different - ?SN Error
1003  07D6
1004  07D6 F5           OUTC:   PUSH    AF              ; Save character
1005  07D7 3A 8A 20             LD      A,(CTLOFG)      ; Get control "O" flag
1006  07DA B7                   OR      A               ; Is it set?
1007  07DB C2 D0 12             JP      NZ,POPAF        ; Yes - don't output
1008  07DE F1                   POP     AF              ; Restore character
1009  07DF C5                   PUSH    BC              ; Save buffer length
1010  07E0 F5                   PUSH    AF              ; Save character
1011  07E1 FE 20                CP      ' '             ; Is it a control code?
1012  07E3 DA FA 07             JP      C,DINPOS        ; Yes - Don't INC POS(X)
1013  07E6 3A 87 20             LD      A,(LWIDTH)      ; Get line width
1014  07E9 47                   LD      B,A             ; To B
1015  07EA 3A F0 20             LD      A,(CURPOS)      ; Get cursor position
1016  07ED 04                   INC     B               ; Width 255?
1017  07EE CA F6 07             JP      Z,INCLEN        ; Yes - No width limit
1018  07F1 05                   DEC     B               ; Restore width
1019  07F2 B8                   CP      B               ; At end of line?
1020  07F3 CC FD 0B             CALL    Z,PRNTCRLF      ; Yes - output CRLF
1021  07F6 3C           INCLEN: INC     A               ; Move on one character
1022  07F7 32 F0 20             LD      (CURPOS),A      ; Save new position
1023  07FA F1           DINPOS: POP     AF              ; Restore character
1024  07FB C1                   POP     BC              ; Restore buffer length
1025  07FC CD 96 1D             CALL    MONOUT          ; Send it
1026  07FF C9                   RET
1027  0800
1028  0800 CD 5A 1C     CLOTST: CALL    GETINP          ; Get input character
1029  0803 E6 7F                AND     01111111B       ; Strip bit 7
1030  0805 FE 0F                CP      CTRLO           ; Is it control "O"?
1031  0807 C0                   RET     NZ              ; No don't flip flag
1032  0808 3A 8A 20             LD      A,(CTLOFG)      ; Get flag
1033  080B 2F                   CPL                     ; Flip it
1034  080C 32 8A 20             LD      (CTLOFG),A      ; Put it back
1035  080F AF                   XOR     A               ; Null character
1036  0810 C9                   RET
1037  0811
1038  0811 CD 21 0A     LIST:   CALL    ATOH            ; ASCII number to DE
1039  0814 C0                   RET     NZ              ; Return if anything extra
1040  0815 C1                   POP     BC              ; Rubbish - Not needed
1041  0816 CD E9 05             CALL    SRCHLN          ; Search for line number in DE
1042  0819 C5                   PUSH    BC              ; Save address of line
1043  081A CD 67 08             CALL    SETLIN          ; Set up lines counter
1044  081D E1           LISTLP: POP     HL              ; Restore address of line
1045  081E 4E                   LD      C,(HL)          ; Get LSB of next line
1046  081F 23                   INC     HL
1047  0820 46                   LD      B,(HL)          ; Get MSB of next line
1048  0821 23                   INC     HL
1049  0822 78                   LD      A,B             ; BC = 0 (End of program)?
1050  0823 B1                   OR      C
1051  0824 CA 48 05             JP      Z,PRNTOK        ; Yes - Go to command mode
1052  0827 CD 70 08             CALL    COUNT           ; Count lines
1053  082A CD 80 09             CALL    TSTBRK          ; Test for break key
1054  082D C5                   PUSH    BC              ; Save address of next line
1055  082E CD FD 0B             CALL    PRNTCRLF        ; Output CRLF
1056  0831 5E                   LD      E,(HL)          ; Get LSB of line number
1057  0832 23                   INC     HL
1058  0833 56                   LD      D,(HL)          ; Get MSB of line number
1059  0834 23                   INC     HL
1060  0835 E5                   PUSH    HL              ; Save address of line start
1061  0836 EB                   EX      DE,HL           ; Line number to HL
1062  0837 CD 3E 19             CALL    PRNTHL          ; Output line number in decimal
1063  083A 3E 20                LD      A,' '           ; Space after line number
1064  083C E1                   POP     HL              ; Restore start of line address
1065  083D CD D6 07     LSTLP2: CALL    OUTC            ; Output character in A
1066  0840 7E           LSTLP3: LD      A,(HL)          ; Get next byte in line
1067  0841 B7                   OR      A               ; End of line?
1068  0842 23                   INC     HL              ; To next byte in line
1069  0843 CA 1D 08             JP      Z,LISTLP        ; Yes - get next line
1070  0846 F2 3D 08             JP      P,LSTLP2        ; No token - output it
1071  0849 D6 7F                SUB     ZEND-1          ; Find and output word
1072  084B 4F                   LD      C,A             ; Token offset+1 to C
1073  084C 11 86 02             LD      DE,WORDS        ; Reserved word list
1074  084F 1A           FNDTOK: LD      A,(DE)          ; Get character in list
1075  0850 13                   INC     DE              ; Move on to next
1076  0851 B7                   OR      A               ; Is it start of word?
1077  0852 F2 4F 08             JP      P,FNDTOK        ; No - Keep looking for word
1078  0855 0D                   DEC     C               ; Count words
1079  0856 C2 4F 08             JP      NZ,FNDTOK       ; Not there - keep looking
1080  0859 E6 7F        OUTWRD: AND     01111111B       ; Strip bit 7
1081  085B CD D6 07             CALL    OUTC            ; Output first character
1082  085E 1A                   LD      A,(DE)          ; Get next character
1083  085F 13                   INC     DE              ; Move on to next
1084  0860 B7                   OR      A               ; Is it end of word?
1085  0861 F2 59 08             JP      P,OUTWRD        ; No - output the rest
1086  0864 C3 40 08             JP      LSTLP3          ; Next byte in line
1087  0867
1088  0867 E5           SETLIN: PUSH    HL              ; Set up LINES counter
1089  0868 2A 8D 20             LD      HL,(LINESN)     ; Get LINES number
1090  086B 22 8B 20             LD      (LINESC),HL     ; Save in LINES counter
1091  086E E1                   POP     HL
1092  086F C9                   RET
1093  0870
1094  0870 E5           COUNT:  PUSH    HL              ; Save code string address
1095  0871 D5                   PUSH    DE
1096  0872 2A 8B 20             LD      HL,(LINESC)     ; Get LINES counter
1097  0875 11 FF FF             LD      DE,-1
1098  0878 ED 5A                ADC     HL,DE           ; Decrement
1099  087A 22 8B 20             LD      (LINESC),HL     ; Put it back
1100  087D D1                   POP     DE
1101  087E E1                   POP     HL              ; Restore code string address
1102  087F F0                   RET     P               ; Return if more lines to go
1103  0880 E5                   PUSH    HL              ; Save code string address
1104  0881 2A 8D 20             LD      HL,(LINESN)     ; Get LINES number
1105  0884 22 8B 20             LD      (LINESC),HL     ; Reset LINES counter
1106  0887 CD 5A 1C             CALL    GETINP          ; Get input character
1107  088A FE 03                CP      CTRLC           ; Is it control "C"?
1108  088C CA 93 08             JP      Z,RSLNBK        ; Yes - Reset LINES and break
1109  088F E1                   POP     HL              ; Restore code string address
1110  0890 C3 70 08             JP      COUNT           ; Keep on counting
1111  0893
1112  0893 2A 8D 20     RSLNBK: LD      HL,(LINESN)     ; Get LINES number
1113  0896 22 8B 20             LD      (LINESC),HL     ; Reset LINES counter
1114  0899 C3 F7 01             JP      BRKRET          ; Go and output "Break"
1115  089C
1116  089C 3E 64        FOR:    LD      A,64H           ; Flag "FOR" assignment
1117  089E 32 10 21             LD      (FORFLG),A      ; Save "FOR" flag
1118  08A1 CD 03 0B             CALL    LET             ; Set up initial index
1119  08A4 C1                   POP     BC              ; Drop RETurn address
1120  08A5 E5                   PUSH    HL              ; Save code string address
1121  08A6 CD EC 0A             CALL    DATA            ; Get next statement address
1122  08A9 22 0C 21             LD      (LOOPST),HL     ; Save it for start of loop
1123  08AC 21 02 00             LD      HL,2            ; Offset for "FOR" block
1124  08AF 39                   ADD     HL,SP           ; Point to it
1125  08B0 CD AA 04     FORSLP: CALL    LOKFOR          ; Look for existing "FOR" block
1126  08B3 D1                   POP     DE              ; Get code string address
1127  08B4 C2 CC 08             JP      NZ,FORFND       ; No nesting found
1128  08B7 09                   ADD     HL,BC           ; Move into "FOR" block
1129  08B8 D5                   PUSH    DE              ; Save code string address
1130  08B9 2B                   DEC     HL
1131  08BA 56                   LD      D,(HL)          ; Get MSB of loop statement
1132  08BB 2B                   DEC     HL
1133  08BC 5E                   LD      E,(HL)          ; Get LSB of loop statement
1134  08BD 23                   INC     HL
1135  08BE 23                   INC     HL
1136  08BF E5                   PUSH    HL              ; Save block address
1137  08C0 2A 0C 21             LD      HL,(LOOPST)     ; Get address of loop statement
1138  08C3 CD C5 07             CALL    CPDEHL          ; Compare the FOR loops
1139  08C6 E1                   POP     HL              ; Restore block address
1140  08C7 C2 B0 08             JP      NZ,FORSLP       ; Different FORs - Find another
1141  08CA D1                   POP     DE              ; Restore code string address
1142  08CB F9                   LD      SP,HL           ; Remove all nested loops
1143  08CC
1144  08CC EB           FORFND: EX      DE,HL           ; Code string address to HL
1145  08CD 0E 08                LD      C,8
1146  08CF CD DA 04             CALL    CHKSTK          ; Check for 8 levels of stack
1147  08D2 E5                   PUSH    HL              ; Save code string address
1148  08D3 2A 0C 21             LD      HL,(LOOPST)     ; Get first statement of loop
1149  08D6 E3                   EX      (SP),HL         ; Save and restore code string
1150  08D7 E5                   PUSH    HL              ; Re-save code string address
1151  08D8 2A A1 20             LD      HL,(LINEAT)     ; Get current line number
1152  08DB E3                   EX      (SP),HL         ; Save and restore code string
1153  08DC CD C5 0D             CALL    TSTNUM          ; Make sure it's a number
1154  08DF CD CB 07             CALL    CHKSYN          ; Make sure "TO" is next
1155  08E2 A6                   .BYTE   ZTO          ; "TO" token
1156  08E3 CD C2 0D             CALL    GETNUM          ; Get "TO" expression value
1157  08E6 E5                   PUSH    HL              ; Save code string address
1158  08E7 CD F0 17             CALL    BCDEFP          ; Move "TO" value to BCDE
1159  08EA E1                   POP     HL              ; Restore code string address
1160  08EB C5                   PUSH    BC              ; Save "TO" value in block
1161  08EC D5                   PUSH    DE
1162  08ED 01 00 81             LD      BC,8100H        ; BCDE - 1 (default STEP)
1163  08F0 51                   LD      D,C             ; C=0
1164  08F1 5A                   LD      E,D             ; D=0
1165  08F2 7E                   LD      A,(HL)          ; Get next byte in code string
1166  08F3 FE AB                CP      ZSTEP           ; See if "STEP" is stated
1167  08F5 3E 01                LD      A,1             ; Sign of step = 1
1168  08F7 C2 08 09             JP      NZ,SAVSTP       ; No STEP given - Default to 1
1169  08FA CD 55 09             CALL    GETCHR          ; Jump over "STEP" token
1170  08FD CD C2 0D             CALL    GETNUM          ; Get step value
1171  0900 E5                   PUSH    HL              ; Save code string address
1172  0901 CD F0 17             CALL    BCDEFP          ; Move STEP to BCDE
1173  0904 CD A4 17             CALL    TSTSGN          ; Test sign of FPREG
1174  0907 E1                   POP     HL              ; Restore code string address
1175  0908 C5           SAVSTP: PUSH    BC              ; Save the STEP value in block
1176  0909 D5                   PUSH    DE
1177  090A F5                   PUSH    AF              ; Save sign of STEP
1178  090B 33                   INC     SP              ; Don't save flags
1179  090C E5                   PUSH    HL              ; Save code string address
1180  090D 2A 13 21             LD      HL,(BRKLIN)     ; Get address of index variable
1181  0910 E3                   EX      (SP),HL         ; Save and restore code string
1182  0911 06 81        PUTFID: LD      B,ZFOR          ; "FOR" block marker
1183  0913 C5                   PUSH    BC              ; Save it
1184  0914 33                   INC     SP              ; Don't save C
1185  0915
1186  0915 CD 80 09     RUNCNT: CALL    TSTBRK          ; Execution driver - Test break
1187  0918 22 13 21             LD      (BRKLIN),HL     ; Save code address for break
1188  091B 7E                   LD      A,(HL)          ; Get next byte in code string
1189  091C FE 3A                CP      ':'             ; Multi statement line?
1190  091E CA 35 09             JP      Z,EXCUTE        ; Yes - Execute it
1191  0921 B7                   OR      A               ; End of line?
1192  0922 C2 FD 04             JP      NZ,SNERR        ; No - Syntax error
1193  0925 23                   INC     HL              ; Point to address of next line
1194  0926 7E                   LD      A,(HL)          ; Get LSB of line pointer
1195  0927 23                   INC     HL
1196  0928 B6                   OR      (HL)            ; Is it zero (End of prog)?
1197  0929 CA A7 09             JP      Z,ENDPRG        ; Yes - Terminate execution
1198  092C 23                   INC     HL              ; Point to line number
1199  092D 5E                   LD      E,(HL)          ; Get LSB of line number
1200  092E 23                   INC     HL
1201  092F 56                   LD      D,(HL)          ; Get MSB of line number
1202  0930 EB                   EX      DE,HL           ; Line number to HL
1203  0931 22 A1 20             LD      (LINEAT),HL     ; Save as current line number
1204  0934 EB                   EX      DE,HL           ; Line number back to DE
1205  0935 CD 55 09     EXCUTE: CALL    GETCHR          ; Get key word
1206  0938 11 15 09             LD      DE,RUNCNT       ; Where to RETurn to
1207  093B D5                   PUSH    DE              ; Save for RETurn
1208  093C C8           IFJMP:  RET     Z               ; Go to RUNCNT if end of STMT
1209  093D D6 80        ONJMP:  SUB     ZEND            ; Is it a token?
1210  093F DA 03 0B             JP      C,LET           ; No - try to assign it
1211  0942 FE 25                CP      ZNEW+1-ZEND     ; END to NEW ?
1212  0944 D2 FD 04             JP      NC,SNERR        ; Not a key word - ?SN Error
1213  0947 07                   RLCA                    ; Double it
1214  0948 4F                   LD      C,A             ; BC = Offset into table
1215  0949 06 00                LD      B,0
1216  094B EB                   EX      DE,HL           ; Save code string address
1217  094C 21 A5 03             LD      HL,WORDTB       ; Keyword address table
1218  094F 09                   ADD     HL,BC           ; Point to routine address
1219  0950 4E                   LD      C,(HL)          ; Get LSB of routine address
1220  0951 23                   INC     HL
1221  0952 46                   LD      B,(HL)          ; Get MSB of routine address
1222  0953 C5                   PUSH    BC              ; Save routine address
1223  0954 EB                   EX      DE,HL           ; Restore code string address
1224  0955
1225  0955 23           GETCHR: INC     HL              ; Point to next character
1226  0956 7E                   LD      A,(HL)          ; Get next code string byte
1227  0957 FE 3A                CP      ':'             ; Z if ':'
1228  0959 D0                   RET     NC              ; NC if > "9"
1229  095A FE 20                CP      ' '
1230  095C CA 55 09             JP      Z,GETCHR        ; Skip over spaces
1231  095F FE 30                CP      '0'
1232  0961 3F                   CCF                     ; NC if < '0'
1233  0962 3C                   INC     A               ; Test for zero - Leave carry
1234  0963 3D                   DEC     A               ; Z if Null
1235  0964 C9                   RET
1236  0965
1237  0965 EB           RESTOR: EX      DE,HL           ; Save code string address
1238  0966 2A A3 20             LD      HL,(BASTXT)     ; Point to start of program
1239  0969 CA 7A 09             JP      Z,RESTNL        ; Just RESTORE - reset pointer
1240  096C EB                   EX      DE,HL           ; Restore code string address
1241  096D CD 21 0A             CALL    ATOH            ; Get line number to DE
1242  0970 E5                   PUSH    HL              ; Save code string address
1243  0971 CD E9 05             CALL    SRCHLN          ; Search for line number in DE
1244  0974 60                   LD      H,B             ; HL = Address of line
1245  0975 69                   LD      L,C
1246  0976 D1                   POP     DE              ; Restore code string address
1247  0977 D2 C2 0A             JP      NC,ULERR        ; ?UL Error if not found
1248  097A 2B           RESTNL: DEC     HL              ; Byte before DATA statement
1249  097B 22 21 21     UPDATA: LD      (NXTDAT),HL     ; Update DATA pointer
1250  097E EB                   EX      DE,HL           ; Restore code string address
1251  097F C9                   RET
1252  0980
1253  0980
1254  0980 DF           TSTBRK: RST     18H             ; Check input status
1255  0981 C8                   RET     Z               ; No key, go back
1256  0982 D7                   RST     10H             ; Get the key into A
1257  0983 FE 1B                CP      ESC             ; Escape key?
1258  0985 28 11                JR      Z,BRK           ; Yes, break
1259  0987 FE 03                CP      CTRLC           ; <Ctrl-C>
1260  0989 28 0D                JR      Z,BRK           ; Yes, break
1261  098B FE 13                CP      CTRLS           ; Stop scrolling?
1262  098D C0                   RET     NZ              ; Other key, ignore
1263  098E
1264  098E
1265  098E D7           STALL:  RST     10H             ; Wait for key
1266  098F FE 11                CP      CTRLQ           ; Resume scrolling?
1267  0991 C8                   RET      Z              ; Release the chokehold
1268  0992 FE 03                CP      CTRLC           ; Second break?
1269  0994 28 07                JR      Z,STOP          ; Break during hold exits prog
1270  0996 18 F6                JR      STALL           ; Loop until <Ctrl-Q> or <brk>
1271  0998
1272  0998 3E FF        BRK     LD      A,$FF           ; Set BRKFLG
1273  099A 32 92 20             LD      (BRKFLG),A      ; Store it
1274  099D
1275  099D
1276  099D C0           STOP:   RET     NZ              ; Exit if anything else
1277  099E F6                   .BYTE   0F6H            ; Flag "STOP"
1278  099F C0           PEND:   RET     NZ              ; Exit if anything else
1279  09A0 22 13 21             LD      (BRKLIN),HL     ; Save point of break
1280  09A3 21                   .BYTE   21H             ; Skip "OR 11111111B"
1281  09A4 F6 FF        INPBRK: OR      11111111B       ; Flag "Break" wanted
1282  09A6 C1                   POP     BC              ; Return not needed and more
1283  09A7 2A A1 20     ENDPRG: LD      HL,(LINEAT)     ; Get current line number
1284  09AA F5                   PUSH    AF              ; Save STOP / END status
1285  09AB 7D                   LD      A,L             ; Is it direct break?
1286  09AC A4                   AND     H
1287  09AD 3C                   INC     A               ; Line is -1 if direct break
1288  09AE CA BA 09             JP      Z,NOLIN         ; Yes - No line number
1289  09B1 22 17 21             LD      (ERRLIN),HL     ; Save line of break
1290  09B4 2A 13 21             LD      HL,(BRKLIN)     ; Get point of break
1291  09B7 22 19 21             LD      (CONTAD),HL     ; Save point to CONTinue
1292  09BA AF           NOLIN:  XOR     A
1293  09BB 32 8A 20             LD      (CTLOFG),A      ; Enable output
1294  09BE CD F0 0B             CALL    STTLIN          ; Start a new line
1295  09C1 F1                   POP     AF              ; Restore STOP / END status
1296  09C2 21 A0 04             LD      HL,BRKMSG       ; "Break" message
1297  09C5 C2 31 05             JP      NZ,ERRIN        ; "in line" wanted?
1298  09C8 C3 48 05             JP      PRNTOK          ; Go to command mode
1299  09CB
1300  09CB 2A 19 21     CONT:   LD      HL,(CONTAD)     ; Get CONTinue address
1301  09CE 7C                   LD      A,H             ; Is it zero?
1302  09CF B5                   OR      L
1303  09D0 1E 20                LD      E,CN            ; ?CN Error
1304  09D2 CA 11 05             JP      Z,ERROR         ; Yes - output "?CN Error"
1305  09D5 EB                   EX      DE,HL           ; Save code string address
1306  09D6 2A 17 21             LD      HL,(ERRLIN)     ; Get line of last break
1307  09D9 22 A1 20             LD      (LINEAT),HL     ; Set up current line number
1308  09DC EB                   EX      DE,HL           ; Restore code string address
1309  09DD C9                   RET                     ; CONTinue where left off
1310  09DE
1311  09DE CD 23 15     NULL:   CALL    GETINT          ; Get integer 0-255
1312  09E1 C0                   RET     NZ              ; Return if bad value
1313  09E2 32 86 20             LD      (NULLS),A       ; Set nulls number
1314  09E5 C9                   RET
1315  09E6
1316  09E6
1317  09E6 E5           ACCSUM: PUSH    HL              ; Save address in array
1318  09E7 2A 8F 20             LD      HL,(CHKSUM)     ; Get check sum
1319  09EA 06 00                LD      B,0             ; BC - Value of byte
1320  09EC 4F                   LD      C,A
1321  09ED 09                   ADD     HL,BC           ; Add byte to check sum
1322  09EE 22 8F 20             LD      (CHKSUM),HL     ; Re-save check sum
1323  09F1 E1                   POP     HL              ; Restore address in array
1324  09F2 C9                   RET
1325  09F3
1326  09F3 7E           CHKLTR: LD      A,(HL)          ; Get byte
1327  09F4 FE 41                CP      'A'             ; < 'a' ?
1328  09F6 D8                   RET     C               ; Carry set if not letter
1329  09F7 FE 5B                CP      'Z'+1           ; > 'z' ?
1330  09F9 3F                   CCF
1331  09FA C9                   RET                     ; Carry set if not letter
1332  09FB
1333  09FB CD 55 09     FPSINT: CALL    GETCHR          ; Get next character
1334  09FE CD C2 0D     POSINT: CALL    GETNUM          ; Get integer 0 to 32767
1335  0A01 CD A4 17     DEPINT: CALL    TSTSGN          ; Test sign of FPREG
1336  0A04 FA 1C 0A             JP      M,FCERR         ; Negative - ?FC Error
1337  0A07 3A 2C 21     DEINT:  LD      A,(FPEXP)       ; Get integer value to DE
1338  0A0A FE 90                CP      80H+16          ; Exponent in range (16 bits)?
1339  0A0C DA 4C 18             JP      C,FPINT         ; Yes - convert it
1340  0A0F 01 80 90             LD      BC,9080H        ; BCDE = -32768
1341  0A12 11 00 00             LD      DE,0000
1342  0A15 E5                   PUSH    HL              ; Save code string address
1343  0A16 CD 1F 18             CALL    CMPNUM          ; Compare FPREG with BCDE
1344  0A19 E1                   POP     HL              ; Restore code string address
1345  0A1A 51                   LD      D,C             ; MSB to D
1346  0A1B C8                   RET     Z               ; Return if in range
1347  0A1C 1E 08        FCERR:  LD      E,FC            ; ?FC Error
1348  0A1E C3 11 05             JP      ERROR           ; Output error-
1349  0A21
1350  0A21 2B           ATOH:   DEC     HL              ; ASCII number to DE binary
1351  0A22 11 00 00     GETLN:  LD      DE,0            ; Get number to DE
1352  0A25 CD 55 09     GTLNLP: CALL    GETCHR          ; Get next character
1353  0A28 D0                   RET     NC              ; Exit if not a digit
1354  0A29 E5                   PUSH    HL              ; Save code string address
1355  0A2A F5                   PUSH    AF              ; Save digit
1356  0A2B 21 98 19             LD      HL,65529/10     ; Largest number 65529
1357  0A2E CD C5 07             CALL    CPDEHL          ; Number in range?
1358  0A31 DA FD 04             JP      C,SNERR         ; No - ?SN Error
1359  0A34 62                   LD      H,D             ; HL = Number
1360  0A35 6B                   LD      L,E
1361  0A36 19                   ADD     HL,DE           ; Times 2
1362  0A37 29                   ADD     HL,HL           ; Times 4
1363  0A38 19                   ADD     HL,DE           ; Times 5
1364  0A39 29                   ADD     HL,HL           ; Times 10
1365  0A3A F1                   POP     AF              ; Restore digit
1366  0A3B D6 30                SUB     '0'             ; Make it 0 to 9
1367  0A3D 5F                   LD      E,A             ; DE = Value of digit
1368  0A3E 16 00                LD      D,0
1369  0A40 19                   ADD     HL,DE           ; Add to number
1370  0A41 EB                   EX      DE,HL           ; Number to DE
1371  0A42 E1                   POP     HL              ; Restore code string address
1372  0A43 C3 25 0A             JP      GTLNLP          ; Go to next character
1373  0A46
1374  0A46 CA 19 06     CLEAR:  JP      Z,INTVAR        ; Just "CLEAR" Keep parameters
1375  0A49 CD FE 09             CALL    POSINT          ; Get integer 0 to 32767 to DE
1376  0A4C 2B                   DEC     HL              ; Cancel increment
1377  0A4D CD 55 09             CALL    GETCHR          ; Get next character
1378  0A50 E5                   PUSH    HL              ; Save code string address
1379  0A51 2A F4 20             LD      HL,(LSTRAM)     ; Get end of RAM
1380  0A54 CA 69 0A             JP      Z,STORED        ; No value given - Use stored
1381  0A57 E1                   POP     HL              ; Restore code string address
1382  0A58 CD CB 07             CALL    CHKSYN          ; Check for comma
1383  0A5B 2C                   .BYTE      ','
1384  0A5C D5                   PUSH    DE              ; Save number
1385  0A5D CD FE 09             CALL    POSINT          ; Get integer 0 to 32767
1386  0A60 2B                   DEC     HL              ; Cancel increment
1387  0A61 CD 55 09             CALL    GETCHR          ; Get next character
1388  0A64 C2 FD 04             JP      NZ,SNERR        ; ?SN Error if more on line
1389  0A67 E3                   EX      (SP),HL         ; Save code string address
1390  0A68 EB                   EX      DE,HL           ; Number to DE
1391  0A69 7D           STORED: LD      A,L             ; Get LSB of new RAM top
1392  0A6A 93                   SUB     E               ; Subtract LSB of string space
1393  0A6B 5F                   LD      E,A             ; Save LSB
1394  0A6C 7C                   LD      A,H             ; Get MSB of new RAM top
1395  0A6D 9A                   SBC     A,D             ; Subtract MSB of string space
1396  0A6E 57                   LD      D,A             ; Save MSB
1397  0A6F DA F2 04             JP      C,OMERR         ; ?OM Error if not enough mem
1398  0A72 E5                   PUSH    HL              ; Save RAM top
1399  0A73 2A 1B 21             LD      HL,(PROGND)     ; Get program end
1400  0A76 01 28 00             LD      BC,40           ; 40 Bytes minimum working RAM
1401  0A79 09                   ADD     HL,BC           ; Get lowest address
1402  0A7A CD C5 07             CALL    CPDEHL          ; Enough memory?
1403  0A7D D2 F2 04             JP      NC,OMERR        ; No - ?OM Error
1404  0A80 EB                   EX      DE,HL           ; RAM top to HL
1405  0A81 22 9F 20             LD      (STRSPC),HL     ; Set new string space
1406  0A84 E1                   POP     HL              ; End of memory to use
1407  0A85 22 F4 20             LD      (LSTRAM),HL     ; Set new top of RAM
1408  0A88 E1                   POP     HL              ; Restore code string address
1409  0A89 C3 19 06             JP      INTVAR          ; Initialise variables
1410  0A8C
1411  0A8C CA 15 06     RUN:    JP      Z,RUNFST        ; RUN from start if just RUN
1412  0A8F CD 19 06             CALL    INTVAR          ; Initialise variables
1413  0A92 01 15 09             LD      BC,RUNCNT       ; Execution driver loop
1414  0A95 C3 A8 0A             JP      RUNLIN          ; RUN from line number
1415  0A98
1416  0A98 0E 03        GOSUB:  LD      C,3             ; 3 Levels of stack needed
1417  0A9A CD DA 04             CALL    CHKSTK          ; Check for 3 levels of stack
1418  0A9D C1                   POP     BC              ; Get return address
1419  0A9E E5                   PUSH    HL              ; Save code string for RETURN
1420  0A9F E5                   PUSH    HL              ; And for GOSUB routine
1421  0AA0 2A A1 20             LD      HL,(LINEAT)     ; Get current line
1422  0AA3 E3                   EX      (SP),HL         ; Into stack - Code string out
1423  0AA4 3E 8C                LD      A,ZGOSUB        ; "GOSUB" token
1424  0AA6 F5                   PUSH    AF              ; Save token
1425  0AA7 33                   INC     SP              ; Don't save flags
1426  0AA8
1427  0AA8 C5           RUNLIN: PUSH    BC              ; Save return address
1428  0AA9 CD 21 0A     GOTO:   CALL    ATOH            ; ASCII number to DE binary
1429  0AAC CD EE 0A             CALL    REM             ; Get end of line
1430  0AAF E5                   PUSH    HL              ; Save end of line
1431  0AB0 2A A1 20             LD      HL,(LINEAT)     ; Get current line
1432  0AB3 CD C5 07             CALL    CPDEHL          ; Line after current?
1433  0AB6 E1                   POP     HL              ; Restore end of line
1434  0AB7 23                   INC     HL              ; Start of next line
1435  0AB8 DC EC 05             CALL    C,SRCHLP        ; Line is after current line
1436  0ABB D4 E9 05             CALL    NC,SRCHLN       ; Line is before current line
1437  0ABE 60                   LD      H,B             ; Set up code string address
1438  0ABF 69                   LD      L,C
1439  0AC0 2B                   DEC     HL              ; Incremented after
1440  0AC1 D8                   RET     C               ; Line found
1441  0AC2 1E 0E        ULERR:  LD      E,UL            ; ?UL Error
1442  0AC4 C3 11 05             JP      ERROR           ; Output error message
1443  0AC7
1444  0AC7 C0           RETURN: RET     NZ              ; Return if not just RETURN
1445  0AC8 16 FF                LD      D,-1            ; Flag "GOSUB" search
1446  0ACA CD A6 04             CALL    BAKSTK          ; Look "GOSUB" block
1447  0ACD F9                   LD      SP,HL           ; Kill all FORs in subroutine
1448  0ACE FE 8C                CP      ZGOSUB          ; Test for "GOSUB" token
1449  0AD0 1E 04                LD      E,RG            ; ?RG Error
1450  0AD2 C2 11 05             JP      NZ,ERROR        ; Error if no "GOSUB" found
1451  0AD5 E1                   POP     HL              ; Get RETURN line number
1452  0AD6 22 A1 20             LD      (LINEAT),HL     ; Save as current
1453  0AD9 23                   INC     HL              ; Was it from direct statement?
1454  0ADA 7C                   LD      A,H
1455  0ADB B5                   OR      L               ; Return to line
1456  0ADC C2 E6 0A             JP      NZ,RETLIN       ; No - Return to line
1457  0ADF 3A 11 21             LD      A,(LSTBIN)      ; Any INPUT in subroutine?
1458  0AE2 B7                   OR      A               ; If so buffer is corrupted
1459  0AE3 C2 47 05             JP      NZ,POPNOK       ; Yes - Go to command mode
1460  0AE6 21 15 09     RETLIN: LD      HL,RUNCNT       ; Execution driver loop
1461  0AE9 E3                   EX      (SP),HL         ; Into stack - Code string out
1462  0AEA 3E                   .BYTE      3EH             ; Skip "POP HL"
1463  0AEB E1           NXTDTA: POP     HL              ; Restore code string address
1464  0AEC
1465  0AEC 01 3A        DATA:   .BYTE      01H,3AH         ; ':' End of statement
1466  0AEE 0E 00        REM:    LD      C,0             ; 00  End of statement
1467  0AF0 06 00                LD      B,0
1468  0AF2 79           NXTSTL: LD      A,C             ; Statement and byte
1469  0AF3 48                   LD      C,B
1470  0AF4 47                   LD      B,A             ; Statement end byte
1471  0AF5 7E           NXTSTT: LD      A,(HL)          ; Get byte
1472  0AF6 B7                   OR      A               ; End of line?
1473  0AF7 C8                   RET     Z               ; Yes - Exit
1474  0AF8 B8                   CP      B               ; End of statement?
1475  0AF9 C8                   RET     Z               ; Yes - Exit
1476  0AFA 23                   INC     HL              ; Next byte
1477  0AFB FE 22                CP      '"'             ; Literal string?
1478  0AFD CA F2 0A             JP      Z,NXTSTL        ; Yes - Look for another '"'
1479  0B00 C3 F5 0A             JP      NXTSTT          ; Keep looking
1480  0B03
1481  0B03 CD B8 0F     LET:    CALL    GETVAR          ; Get variable name
1482  0B06 CD CB 07             CALL    CHKSYN          ; Make sure "=" follows
1483  0B09 B4                   .BYTE      ZEQUAL          ; "=" token
1484  0B0A D5                   PUSH    DE              ; Save address of variable
1485  0B0B 3A F2 20             LD      A,(TYPE)        ; Get data type
1486  0B0E F5                   PUSH    AF              ; Save type
1487  0B0F CD D4 0D             CALL    EVAL            ; Evaluate expression
1488  0B12 F1                   POP     AF              ; Restore type
1489  0B13 E3                   EX      (SP),HL         ; Save code - Get var addr
1490  0B14 22 13 21             LD      (BRKLIN),HL     ; Save address of variable
1491  0B17 1F                   RRA                     ; Adjust type
1492  0B18 CD C7 0D             CALL    CHKTYP          ; Check types are the same
1493  0B1B CA 56 0B             JP      Z,LETNUM        ; Numeric - Move value
1494  0B1E E5           LETSTR: PUSH    HL              ; Save address of string var
1495  0B1F 2A 29 21             LD      HL,(FPREG)      ; Pointer to string entry
1496  0B22 E5                   PUSH    HL              ; Save it on stack
1497  0B23 23                   INC     HL              ; Skip over length
1498  0B24 23                   INC     HL
1499  0B25 5E                   LD      E,(HL)          ; LSB of string address
1500  0B26 23                   INC     HL
1501  0B27 56                   LD      D,(HL)          ; MSB of string address
1502  0B28 2A A3 20             LD      HL,(BASTXT)     ; Point to start of program
1503  0B2B CD C5 07             CALL    CPDEHL          ; Is string before program?
1504  0B2E D2 45 0B             JP      NC,CRESTR       ; Yes - Create string entry
1505  0B31 2A 9F 20             LD      HL,(STRSPC)     ; Point to string space
1506  0B34 CD C5 07             CALL    CPDEHL          ; Is string literal in program?
1507  0B37 D1                   POP     DE              ; Restore address of string
1508  0B38 D2 4D 0B             JP      NC,MVSTPT       ; Yes - Set up pointer
1509  0B3B 21 04 21             LD      HL,TMPSTR       ; Temporary string pool
1510  0B3E CD C5 07             CALL    CPDEHL          ; Is string in temporary pool?
1511  0B41 D2 4D 0B             JP      NC,MVSTPT       ; No - Set up pointer
1512  0B44 3E                   .BYTE   3EH             ; Skip "POP DE"
1513  0B45 D1           CRESTR: POP     DE              ; Restore address of string
1514  0B46 CD FC 13             CALL    BAKTMP          ; Back to last tmp-str entry
1515  0B49 EB                   EX      DE,HL           ; Address of string entry
1516  0B4A CD 35 12             CALL    SAVSTR          ; Save string in string area
1517  0B4D CD FC 13     MVSTPT: CALL    BAKTMP          ; Back to last tmp-str entry
1518  0B50 E1                   POP     HL              ; Get string pointer
1519  0B51 CD FF 17             CALL    DETHL4          ; Move string pointer to var
1520  0B54 E1                   POP     HL              ; Restore code string address
1521  0B55 C9                   RET
1522  0B56
1523  0B56 E5           LETNUM: PUSH    HL              ; Save address of variable
1524  0B57 CD FC 17             CALL    FPTHL           ; Move value to variable
1525  0B5A D1                   POP     DE              ; Restore address of variable
1526  0B5B E1                   POP     HL              ; Restore code string address
1527  0B5C C9                   RET
1528  0B5D
1529  0B5D CD 23 15     ON:     CALL    GETINT          ; Get integer 0-255
1530  0B60 7E                   LD      A,(HL)          ; Get "GOTO" or "GOSUB" token
1531  0B61 47                   LD      B,A             ; Save in B
1532  0B62 FE 8C                CP      ZGOSUB          ; "GOSUB" token?
1533  0B64 CA 6C 0B             JP      Z,ONGO          ; Yes - Find line number
1534  0B67 CD CB 07             CALL    CHKSYN          ; Make sure it's "GOTO"
1535  0B6A 88                   .BYTE   ZGOTO           ; "GOTO" token
1536  0B6B 2B                   DEC     HL              ; Cancel increment
1537  0B6C 4B           ONGO:   LD      C,E             ; Integer of branch value
1538  0B6D 0D           ONGOLP: DEC     C               ; Count branches
1539  0B6E 78                   LD      A,B             ; Get "GOTO" or "GOSUB" token
1540  0B6F CA 3D 09             JP      Z,ONJMP         ; Go to that line if right one
1541  0B72 CD 22 0A             CALL    GETLN           ; Get line number to DE
1542  0B75 FE 2C                CP      ','             ; Another line number?
1543  0B77 C0                   RET     NZ              ; No - Drop through
1544  0B78 C3 6D 0B             JP      ONGOLP          ; Yes - loop
1545  0B7B
1546  0B7B CD D4 0D     IF:     CALL    EVAL            ; Evaluate expression
1547  0B7E 7E                   LD      A,(HL)          ; Get token
1548  0B7F FE 88                CP      ZGOTO           ; "GOTO" token?
1549  0B81 CA 89 0B             JP      Z,IFGO          ; Yes - Get line
1550  0B84 CD CB 07             CALL    CHKSYN          ; Make sure it's "THEN"
1551  0B87 A9                   .BYTE      ZTHEN           ; "THEN" token
1552  0B88 2B                   DEC     HL              ; Cancel increment
1553  0B89 CD C5 0D     IFGO:   CALL    TSTNUM          ; Make sure it's numeric
1554  0B8C CD A4 17             CALL    TSTSGN          ; Test state of expression
1555  0B8F CA EE 0A             JP      Z,REM           ; False - Drop through
1556  0B92 CD 55 09             CALL    GETCHR          ; Get next character
1557  0B95 DA A9 0A             JP      C,GOTO          ; Number - GOTO that line
1558  0B98 C3 3C 09             JP      IFJMP           ; Otherwise do statement
1559  0B9B
1560  0B9B 2B           MRPRNT: DEC     HL              ; DEC 'cos GETCHR INCs
1561  0B9C CD 55 09             CALL    GETCHR          ; Get next character
1562  0B9F CA FD 0B     PRINT1:  JP      Z,PRNTCRLF      ; CRLF if just PRINT
1563  0BA2 C8           PRNTLP: RET     Z               ; End of list - Exit
1564  0BA3 FE A5                CP      ZTAB            ; "TAB(" token?
1565  0BA5 CA 30 0C             JP      Z,DOTAB         ; Yes - Do TAB routine
1566  0BA8 FE A8                CP      ZSPC            ; "SPC(" token?
1567  0BAA CA 30 0C             JP      Z,DOTAB         ; Yes - Do SPC routine
1568  0BAD E5                   PUSH    HL              ; Save code string address
1569  0BAE FE 2C                CP      ','             ; Comma?
1570  0BB0 CA 19 0C             JP      Z,DOCOM         ; Yes - Move to next zone
1571  0BB3 FE 3B                CP      59 ;";"         ; Semi-colon?
1572  0BB5 CA 53 0C             JP      Z,NEXITM        ; Do semi-colon routine
1573  0BB8 C1                   POP     BC              ; Code string address to BC
1574  0BB9 CD D4 0D             CALL    EVAL            ; Evaluate expression
1575  0BBC E5                   PUSH    HL              ; Save code string address
1576  0BBD 3A F2 20             LD      A,(TYPE)        ; Get variable type
1577  0BC0 B7                   OR      A               ; Is it a string variable?
1578  0BC1 C2 E9 0B             JP      NZ,PRNTST       ; Yes - Output string contents
1579  0BC4 CD 49 19             CALL    NUMASC          ; Convert number to text
1580  0BC7 CD 59 12             CALL    CRTST           ; Create temporary string
1581  0BCA 36 20                LD      (HL),' '        ; Followed by a space
1582  0BCC 2A 29 21             LD      HL,(FPREG)      ; Get length of output
1583  0BCF 34                   INC     (HL)            ; Plus 1 for the space
1584  0BD0 2A 29 21             LD      HL,(FPREG)      ; < Not needed >
1585  0BD3 3A 87 20             LD      A,(LWIDTH)      ; Get width of line
1586  0BD6 47                   LD      B,A             ; To B
1587  0BD7 04                   INC     B               ; Width 255 (No limit)?
1588  0BD8 CA E5 0B             JP      Z,PRNTNB        ; Yes - Output number string
1589  0BDB 04                   INC     B               ; Adjust it
1590  0BDC 3A F0 20             LD      A,(CURPOS)      ; Get cursor position
1591  0BDF 86                   ADD     A,(HL)          ; Add length of string
1592  0BE0 3D                   DEC     A               ; Adjust it
1593  0BE1 B8                   CP      B               ; Will output fit on this line?
1594  0BE2 D4 FD 0B             CALL    NC,PRNTCRLF     ; No - CRLF first
1595  0BE5 CD 9E 12     PRNTNB: CALL    PRS1            ; Output string at (HL)
1596  0BE8 AF                   XOR     A               ; Skip CALL by setting 'z' flag
1597  0BE9 C4 9E 12     PRNTST: CALL    NZ,PRS1         ; Output string at (HL)
1598  0BEC E1                   POP     HL              ; Restore code string address
1599  0BED C3 9B 0B             JP      MRPRNT          ; See if more to PRINT
1600  0BF0
1601  0BF0 3A F0 20     STTLIN: LD      A,(CURPOS)      ; Make sure on new line
1602  0BF3 B7                   OR      A               ; Already at start?
1603  0BF4 C8                   RET     Z               ; Yes - Do nothing
1604  0BF5 C3 FD 0B             JP      PRNTCRLF        ; Start a new line
1605  0BF8
1606  0BF8 36 00        ENDINP: LD      (HL),0          ; Mark end of buffer
1607  0BFA 21 A5 20             LD      HL,BUFFER-1     ; Point to buffer
1608  0BFD 3E 0D        PRNTCRLF: LD    A,CR1            ; Load a CR
1609  0BFF CD D6 07             CALL    OUTC            ; Output character
1610  0C02 3E 0A                LD      A,LF1            ; Load a LF
1611  0C04 CD D6 07             CALL    OUTC            ; Output character
1612  0C07 AF           DONULL: XOR     A               ; Set to position 0
1613  0C08 32 F0 20             LD      (CURPOS),A      ; Store it
1614  0C0B 3A 86 20             LD      A,(NULLS)       ; Get number of nulls
1615  0C0E 3D           NULLP:  DEC     A               ; Count them
1616  0C0F C8                   RET     Z               ; Return if done
1617  0C10 F5                   PUSH    AF              ; Save count
1618  0C11 AF                   XOR     A               ; Load a null
1619  0C12 CD D6 07             CALL    OUTC            ; Output it
1620  0C15 F1                   POP     AF              ; Restore count
1621  0C16 C3 0E 0C             JP      NULLP           ; Keep counting
1622  0C19
1623  0C19 3A 88 20     DOCOM:  LD      A,(COMMAN)      ; Get comma width
1624  0C1C 47                   LD      B,A             ; Save in B
1625  0C1D 3A F0 20             LD      A,(CURPOS)      ; Get current position
1626  0C20 B8                   CP      B               ; Within the limit?
1627  0C21 D4 FD 0B             CALL    NC,PRNTCRLF     ; No - output CRLF
1628  0C24 D2 53 0C             JP      NC,NEXITM       ; Get next item
1629  0C27 D6 0E        ZONELP: SUB     14              ; Next zone of 14 characters
1630  0C29 D2 27 0C             JP      NC,ZONELP       ; Repeat if more zones
1631  0C2C 2F                   CPL                     ; Number of spaces to output
1632  0C2D C3 48 0C             JP      ASPCS           ; Output them
1633  0C30
1634  0C30 F5           DOTAB:  PUSH    AF              ; Save token
1635  0C31 CD 20 15             CALL    FNDNUM          ; Evaluate expression
1636  0C34 CD CB 07             CALL    CHKSYN          ; Make sure ")" follows
1637  0C37 29                   .BYTE   ")"
1638  0C38 2B                   DEC     HL              ; Back space on to ")"
1639  0C39 F1                   POP     AF              ; Restore token
1640  0C3A D6 A8                SUB     ZSPC            ; Was it "SPC(" ?
1641  0C3C E5                   PUSH    HL              ; Save code string address
1642  0C3D CA 43 0C             JP      Z,DOSPC         ; Yes - Do 'E' spaces
1643  0C40 3A F0 20             LD      A,(CURPOS)      ; Get current position
1644  0C43 2F           DOSPC:  CPL                     ; Number of spaces to print to
1645  0C44 83                   ADD     A,E             ; Total number to print
1646  0C45 D2 53 0C             JP      NC,NEXITM       ; TAB < Current POS(X)
1647  0C48 3C           ASPCS:  INC     A               ; Output A spaces
1648  0C49 47                   LD      B,A             ; Save number to print
1649  0C4A 3E 20                LD      A,' '           ; Space
1650  0C4C CD D6 07     SPCLP:  CALL    OUTC            ; Output character in A
1651  0C4F 05                   DEC     B               ; Count them
1652  0C50 C2 4C 0C             JP      NZ,SPCLP        ; Repeat if more
1653  0C53 E1           NEXITM: POP     HL              ; Restore code string address
1654  0C54 CD 55 09             CALL    GETCHR          ; Get next character
1655  0C57 C3 A2 0B             JP      PRNTLP          ; More to print
1656  0C5A
1657  0C5A 3F 52 65 64  REDO:   .BYTE   "?Redo from start",CR,LF,0
1657  0C5E 6F 20 66 72
1657  0C62 6F 6D 20 73
1657  0C66 74 61 72 74
1657  0C6A 0D 0A 00
1658  0C6D
1659  0C6D 3A 12 21     BADINP: LD      A,(READFG)      ; READ or INPUT?
1660  0C70 B7                   OR      A
1661  0C71 C2 F7 04             JP      NZ,DATSNR       ; READ - ?SN Error
1662  0C74 C1                   POP     BC              ; Throw away code string addr
1663  0C75 21 5A 0C             LD      HL,REDO         ; "Redo from start" message
1664  0C78 CD 9B 12             CALL    PRS             ; Output string
1665  0C7B C3 48 06             JP      DOAGN           ; Do last INPUT again
1666  0C7E
1667  0C7E CD 06 12     INPUT:  CALL    IDTEST          ; Test for illegal direct
1668  0C81 7E                   LD      A,(HL)          ; Get character after "INPUT"
1669  0C82 FE 22                CP      '"'             ; Is there a prompt string?
1670  0C84 3E 00                LD      A,0             ; Clear A and leave flags
1671  0C86 32 8A 20             LD      (CTLOFG),A      ; Enable output
1672  0C89 C2 98 0C             JP      NZ,NOPMPT       ; No prompt - get input
1673  0C8C CD 5A 12             CALL    QTSTR           ; Get string terminated by '"'
1674  0C8F CD CB 07             CALL    CHKSYN          ; Check for ';' after prompt
1675  0C92 3B                   .BYTE   ';'
1676  0C93 E5                   PUSH    HL              ; Save code string address
1677  0C94 CD 9E 12             CALL    PRS1            ; Output prompt string
1678  0C97 3E                   .BYTE   3EH             ; Skip "PUSH HL"
1679  0C98 E5           NOPMPT: PUSH    HL              ; Save code string address
1680  0C99 CD 4C 06             CALL    PROMPT          ; Get input with "? " prompt
1681  0C9C C1                   POP     BC              ; Restore code string address
1682  0C9D DA A4 09             JP      C,INPBRK        ; Break pressed - Exit
1683  0CA0 23                   INC     HL              ; Next byte
1684  0CA1 7E                   LD      A,(HL)          ; Get it
1685  0CA2 B7                   OR      A               ; End of line?
1686  0CA3 2B                   DEC     HL              ; Back again
1687  0CA4 C5                   PUSH    BC              ; Re-save code string address
1688  0CA5 CA EB 0A             JP      Z,NXTDTA        ; Yes - Find next DATA stmt
1689  0CA8 36 2C                LD      (HL),','        ; Store comma as separator
1690  0CAA C3 B2 0C             JP      NXTITM          ; Get next item
1691  0CAD
1692  0CAD E5           READ:   PUSH    HL              ; Save code string address
1693  0CAE 2A 21 21             LD      HL,(NXTDAT)     ; Next DATA statement
1694  0CB1 F6                   .BYTE   0F6H            ; Flag "READ"
1695  0CB2 AF           NXTITM: XOR     A               ; Flag "INPUT"
1696  0CB3 32 12 21             LD      (READFG),A      ; Save "READ"/"INPUT" flag
1697  0CB6 E3                   EX      (SP),HL         ; Get code str' , Save pointer
1698  0CB7 C3 BE 0C             JP      GTVLUS          ; Get values
1699  0CBA
1700  0CBA CD CB 07     NEDMOR: CALL    CHKSYN          ; Check for comma between items
1701  0CBD 2C                   .BYTE      ','
1702  0CBE CD B8 0F     GTVLUS: CALL    GETVAR          ; Get variable name
1703  0CC1 E3                   EX      (SP),HL         ; Save code str" , Get pointer
1704  0CC2 D5                   PUSH    DE              ; Save variable address
1705  0CC3 7E                   LD      A,(HL)          ; Get next "INPUT"/"DATA" byte
1706  0CC4 FE 2C                CP      ','             ; Comma?
1707  0CC6 CA E6 0C             JP      Z,ANTVLU        ; Yes - Get another value
1708  0CC9 3A 12 21             LD      A,(READFG)      ; Is it READ?
1709  0CCC B7                   OR      A
1710  0CCD C2 53 0D             JP      NZ,FDTLP        ; Yes - Find next DATA stmt
1711  0CD0 3E 3F                LD      A,'?'           ; More INPUT needed
1712  0CD2 CD D6 07             CALL    OUTC            ; Output character
1713  0CD5 CD 4C 06             CALL    PROMPT          ; Get INPUT with prompt
1714  0CD8 D1                   POP     DE              ; Variable address
1715  0CD9 C1                   POP     BC              ; Code string address
1716  0CDA DA A4 09             JP      C,INPBRK        ; Break pressed
1717  0CDD 23                   INC     HL              ; Point to next DATA byte
1718  0CDE 7E                   LD      A,(HL)          ; Get byte
1719  0CDF B7                   OR      A               ; Is it zero (No input) ?
1720  0CE0 2B                   DEC     HL              ; Back space INPUT pointer
1721  0CE1 C5                   PUSH    BC              ; Save code string address
1722  0CE2 CA EB 0A             JP      Z,NXTDTA        ; Find end of buffer
1723  0CE5 D5                   PUSH    DE              ; Save variable address
1724  0CE6 3A F2 20     ANTVLU: LD      A,(TYPE)        ; Check data type
1725  0CE9 B7                   OR      A               ; Is it numeric?
1726  0CEA CA 10 0D             JP      Z,INPBIN        ; Yes - Convert to binary
1727  0CED CD 55 09             CALL    GETCHR          ; Get next character
1728  0CF0 57                   LD      D,A             ; Save input character
1729  0CF1 47                   LD      B,A             ; Again
1730  0CF2 FE 22                CP      '"'             ; Start of literal sting?
1731  0CF4 CA 04 0D             JP      Z,STRENT        ; Yes - Create string entry
1732  0CF7 3A 12 21             LD      A,(READFG)      ; "READ" or "INPUT" ?
1733  0CFA B7                   OR      A
1734  0CFB 57                   LD      D,A             ; Save 00 if "INPUT"
1735  0CFC CA 01 0D             JP      Z,ITMSEP        ; "INPUT" - End with 00
1736  0CFF 16 3A                LD      D,':'           ; "DATA" - End with 00 or ':'
1737  0D01 06 2C        ITMSEP: LD      B,','           ; Item separator
1738  0D03 2B                   DEC     HL              ; Back space for DTSTR
1739  0D04 CD 5D 12     STRENT: CALL    DTSTR           ; Get string terminated by D
1740  0D07 EB                   EX      DE,HL           ; String address to DE
1741  0D08 21 1B 0D             LD      HL,LTSTND       ; Where to go after LETSTR
1742  0D0B E3                   EX      (SP),HL         ; Save HL , get input pointer
1743  0D0C D5                   PUSH    DE              ; Save address of string
1744  0D0D C3 1E 0B             JP      LETSTR          ; Assign string to variable
1745  0D10
1746  0D10 CD 55 09     INPBIN: CALL    GETCHR          ; Get next character
1747  0D13 CD AB 18             CALL    ASCTFP          ; Convert ASCII to FP number
1748  0D16 E3                   EX      (SP),HL         ; Save input ptr, Get var addr
1749  0D17 CD FC 17             CALL    FPTHL           ; Move FPREG to variable
1750  0D1A E1                   POP     HL              ; Restore input pointer
1751  0D1B 2B           LTSTND: DEC     HL              ; DEC 'cos GETCHR INCs
1752  0D1C CD 55 09             CALL    GETCHR          ; Get next character
1753  0D1F CA 27 0D             JP      Z,MORDT         ; End of line - More needed?
1754  0D22 FE 2C                CP      ','             ; Another value?
1755  0D24 C2 6D 0C             JP      NZ,BADINP       ; No - Bad input
1756  0D27 E3           MORDT:  EX      (SP),HL         ; Get code string address
1757  0D28 2B                   DEC     HL              ; DEC 'cos GETCHR INCs
1758  0D29 CD 55 09             CALL    GETCHR          ; Get next character
1759  0D2C C2 BA 0C             JP      NZ,NEDMOR       ; More needed - Get it
1760  0D2F D1                   POP     DE              ; Restore DATA pointer
1761  0D30 3A 12 21             LD      A,(READFG)      ; "READ" or "INPUT" ?
1762  0D33 B7                   OR      A
1763  0D34 EB                   EX      DE,HL           ; DATA pointer to HL
1764  0D35 C2 7B 09             JP      NZ,UPDATA       ; Update DATA pointer if "READ"
1765  0D38 D5                   PUSH    DE              ; Save code string address
1766  0D39 B6                   OR      (HL)            ; More input given?
1767  0D3A 21 42 0D             LD      HL,EXTIG        ; "?Extra ignored" message
1768  0D3D C4 9B 12             CALL    NZ,PRS          ; Output string if extra given
1769  0D40 E1                   POP     HL              ; Restore code string address
1770  0D41 C9                   RET
1771  0D42
1772  0D42 3F 45 78 74  EXTIG:  .BYTE   "?Extra ignored",CR,LF,0
1772  0D46 72 61 20 69
1772  0D4A 67 6E 6F 72
1772  0D4E 65 64 0D 0A
1772  0D52 00
1773  0D53
1774  0D53 CD EC 0A     FDTLP:  CALL    DATA            ; Get next statement
1775  0D56 B7                   OR      A               ; End of line?
1776  0D57 C2 6C 0D             JP      NZ,FANDT        ; No - See if DATA statement
1777  0D5A 23                   INC     HL
1778  0D5B 7E                   LD      A,(HL)          ; End of program?
1779  0D5C 23                   INC     HL
1780  0D5D B6                   OR      (HL)            ; 00 00 Ends program
1781  0D5E 1E 06                LD      E,OD            ; ?OD Error
1782  0D60 CA 11 05             JP      Z,ERROR         ; Yes - Out of DATA
1783  0D63 23                   INC     HL
1784  0D64 5E                   LD      E,(HL)          ; LSB of line number
1785  0D65 23                   INC     HL
1786  0D66 56                   LD      D,(HL)          ; MSB of line number
1787  0D67 EB                   EX      DE,HL
1788  0D68 22 0E 21             LD      (DATLIN),HL     ; Set line of current DATA item
1789  0D6B EB                   EX      DE,HL
1790  0D6C CD 55 09     FANDT:  CALL    GETCHR          ; Get next character
1791  0D6F FE 83                CP      ZDATA           ; "DATA" token
1792  0D71 C2 53 0D             JP      NZ,FDTLP        ; No "DATA" - Keep looking
1793  0D74 C3 E6 0C             JP      ANTVLU          ; Found - Convert input
1794  0D77
1795  0D77 11 00 00     NEXT:   LD      DE,0            ; In case no index given
1796  0D7A C4 B8 0F     NEXT1:  CALL    NZ,GETVAR       ; Get index address
1797  0D7D 22 13 21             LD      (BRKLIN),HL     ; Save code string address
1798  0D80 CD A6 04             CALL    BAKSTK          ; Look for "FOR" block
1799  0D83 C2 03 05             JP      NZ,NFERR        ; No "FOR" - ?NF Error
1800  0D86 F9                   LD      SP,HL           ; Clear nested loops
1801  0D87 D5                   PUSH    DE              ; Save index address
1802  0D88 7E                   LD      A,(HL)          ; Get sign of STEP
1803  0D89 23                   INC     HL
1804  0D8A F5                   PUSH    AF              ; Save sign of STEP
1805  0D8B D5                   PUSH    DE              ; Save index address
1806  0D8C CD E2 17             CALL    PHLTFP          ; Move index value to FPREG
1807  0D8F E3                   EX      (SP),HL         ; Save address of TO value
1808  0D90 E5                   PUSH    HL              ; Save address of index
1809  0D91 CD 4F 15             CALL    ADDPHL          ; Add STEP to index value
1810  0D94 E1                   POP     HL              ; Restore address of index
1811  0D95 CD FC 17             CALL    FPTHL           ; Move value to index variable
1812  0D98 E1                   POP     HL              ; Restore address of TO value
1813  0D99 CD F3 17             CALL    LOADFP          ; Move TO value to BCDE
1814  0D9C E5                   PUSH    HL              ; Save address of line of FOR
1815  0D9D CD 1F 18             CALL    CMPNUM          ; Compare index with TO value
1816  0DA0 E1                   POP     HL              ; Restore address of line num
1817  0DA1 C1                   POP     BC              ; Address of sign of STEP
1818  0DA2 90                   SUB     B               ; Compare with expected sign
1819  0DA3 CD F3 17             CALL    LOADFP          ; BC = Loop stmt,DE = Line num
1820  0DA6 CA B2 0D             JP      Z,KILFOR        ; Loop finished - Terminate it
1821  0DA9 EB                   EX      DE,HL           ; Loop statement line number
1822  0DAA 22 A1 20             LD      (LINEAT),HL     ; Set loop line number
1823  0DAD 69                   LD      L,C             ; Set code string to loop
1824  0DAE 60                   LD      H,B
1825  0DAF C3 11 09             JP      PUTFID          ; Put back "FOR" and continue
1826  0DB2
1827  0DB2 F9           KILFOR: LD      SP,HL           ; Remove "FOR" block
1828  0DB3 2A 13 21             LD      HL,(BRKLIN)     ; Code string after "NEXT"
1829  0DB6 7E                   LD      A,(HL)          ; Get next byte in code string
1830  0DB7 FE 2C                CP      ','             ; More NEXTs ?
1831  0DB9 C2 15 09             JP      NZ,RUNCNT       ; No - Do next statement
1832  0DBC CD 55 09             CALL    GETCHR          ; Position to index name
1833  0DBF CD 7A 0D             CALL    NEXT1           ; Re-enter NEXT routine
1834  0DC2              ; < will not RETurn to here , Exit to RUNCNT or Loop >
1835  0DC2
1836  0DC2 CD D4 0D     GETNUM: CALL    EVAL            ; Get a numeric expression
1837  0DC5 F6           TSTNUM: .BYTE      0F6H            ; Clear carry (numeric)
1838  0DC6 37           TSTSTR: SCF                     ; Set carry (string)
1839  0DC7 3A F2 20     CHKTYP: LD      A,(TYPE)        ; Check types match
1840  0DCA 8F                   ADC     A,A             ; Expected + actual
1841  0DCB B7                   OR      A               ; Clear carry , set parity
1842  0DCC E8                   RET     PE              ; Even parity - Types match
1843  0DCD C3 0F 05             JP      TMERR           ; Different types - Error
1844  0DD0
1845  0DD0 CD CB 07     OPNPAR: CALL    CHKSYN          ; Make sure "(" follows
1846  0DD3 28                   .BYTE   "("
1847  0DD4 2B           EVAL:   DEC     HL              ; Evaluate expression & save
1848  0DD5 16 00                LD      D,0             ; Precedence value
1849  0DD7 D5           EVAL1:  PUSH    DE              ; Save precedence
1850  0DD8 0E 01                LD      C,1
1851  0DDA CD DA 04             CALL    CHKSTK          ; Check for 1 level of stack
1852  0DDD CD 4B 0E             CALL    OPRND           ; Get next expression value
1853  0DE0 22 15 21     EVAL2:  LD      (NXTOPR),HL     ; Save address of next operator
1854  0DE3 2A 15 21     EVAL3:  LD      HL,(NXTOPR)     ; Restore address of next opr
1855  0DE6 C1                   POP     BC              ; Precedence value and operator
1856  0DE7 78                   LD      A,B             ; Get precedence value
1857  0DE8 FE 78                CP      78H             ; "AND" or "OR" ?
1858  0DEA D4 C5 0D             CALL    NC,TSTNUM       ; No - Make sure it's a number
1859  0DED 7E                   LD      A,(HL)          ; Get next operator / function
1860  0DEE 16 00                LD      D,0             ; Clear Last relation
1861  0DF0 D6 B3        RLTLP:  SUB     ZGTR            ; ">" Token
1862  0DF2 DA 0C 0E             JP      C,FOPRND        ; + - * / ^ AND OR - Test it
1863  0DF5 FE 03                CP      ZLTH+1-ZGTR     ; < = >
1864  0DF7 D2 0C 0E             JP      NC,FOPRND       ; Function - Call it
1865  0DFA FE 01                CP      ZEQUAL-ZGTR     ; "="
1866  0DFC 17                   RLA                     ; <- Test for legal
1867  0DFD AA                   XOR     D               ; <- combinations of < = >
1868  0DFE BA                   CP      D               ; <- by combining last token
1869  0DFF 57                   LD      D,A             ; <- with current one
1870  0E00 DA FD 04             JP      C,SNERR         ; Error if "<<' '==" or ">>"
1871  0E03 22 0A 21             LD      (CUROPR),HL     ; Save address of current token
1872  0E06 CD 55 09             CALL    GETCHR          ; Get next character
1873  0E09 C3 F0 0D             JP      RLTLP           ; Treat the two as one
1874  0E0C
1875  0E0C 7A           FOPRND: LD      A,D             ; < = > found ?
1876  0E0D B7                   OR      A
1877  0E0E C2 33 0F             JP      NZ,TSTRED       ; Yes - Test for reduction
1878  0E11 7E                   LD      A,(HL)          ; Get operator token
1879  0E12 22 0A 21             LD      (CUROPR),HL     ; Save operator address
1880  0E15 D6 AC                SUB     ZPLUS           ; Operator or function?
1881  0E17 D8                   RET     C               ; Neither - Exit
1882  0E18 FE 07                CP      ZOR+1-ZPLUS     ; Is it + - * / ^ AND OR ?
1883  0E1A D0                   RET     NC              ; No - Exit
1884  0E1B 5F                   LD      E,A             ; Coded operator
1885  0E1C 3A F2 20             LD      A,(TYPE)        ; Get data type
1886  0E1F 3D                   DEC     A               ; FF = numeric , 00 = string
1887  0E20 B3                   OR      E               ; Combine with coded operator
1888  0E21 7B                   LD      A,E             ; Get coded operator
1889  0E22 CA 91 13             JP      Z,CONCAT        ; String concatenation
1890  0E25 07                   RLCA                    ; Times 2
1891  0E26 83                   ADD     A,E             ; Times 3
1892  0E27 5F                   LD      E,A             ; To DE (D is 0)
1893  0E28 21 EF 03             LD      HL,PRITAB       ; Precedence table
1894  0E2B 19                   ADD     HL,DE           ; To the operator concerned
1895  0E2C 78                   LD      A,B             ; Last operator precedence
1896  0E2D 56                   LD      D,(HL)          ; Get evaluation precedence
1897  0E2E BA                   CP      D               ; Compare with eval precedence
1898  0E2F D0                   RET     NC              ; Exit if higher precedence
1899  0E30 23                   INC     HL              ; Point to routine address
1900  0E31 CD C5 0D             CALL    TSTNUM          ; Make sure it's a number
1901  0E34
1902  0E34 C5           STKTHS: PUSH    BC              ; Save last precedence & token
1903  0E35 01 E3 0D             LD      BC,EVAL3        ; Where to go on prec' break
1904  0E38 C5                   PUSH    BC              ; Save on stack for return
1905  0E39 43                   LD      B,E             ; Save operator
1906  0E3A 4A                   LD      C,D             ; Save precedence
1907  0E3B CD D5 17             CALL    STAKFP          ; Move value to stack
1908  0E3E 58                   LD      E,B             ; Restore operator
1909  0E3F 51                   LD      D,C             ; Restore precedence
1910  0E40 4E                   LD      C,(HL)          ; Get LSB of routine address
1911  0E41 23                   INC     HL
1912  0E42 46                   LD      B,(HL)          ; Get MSB of routine address
1913  0E43 23                   INC     HL
1914  0E44 C5                   PUSH    BC              ; Save routine address
1915  0E45 2A 0A 21             LD      HL,(CUROPR)     ; Address of current operator
1916  0E48 C3 D7 0D             JP      EVAL1           ; Loop until prec' break
1917  0E4B
1918  0E4B AF           OPRND:  XOR     A               ; Get operand routine
1919  0E4C 32 F2 20             LD      (TYPE),A        ; Set numeric expected
1920  0E4F CD 55 09             CALL    GETCHR          ; Get next character
1921  0E52 1E 24                LD      E,MO            ; ?MO Error
1922  0E54 CA 11 05             JP      Z,ERROR         ; No operand - Error
1923  0E57 DA AB 18             JP      C,ASCTFP        ; Number - Get value
1924  0E5A CD F3 09             CALL    CHKLTR          ; See if a letter
1925  0E5D D2 B2 0E             JP      NC,CONVAR       ; Letter - Find variable
1926  0E60 FE 26                CP		'&'				; &H = HEX, &B = BINARY
1927  0E62 20 12                JR		NZ, NOTAMP
1928  0E64 CD 55 09             CALL    GETCHR          ; Get next character
1929  0E67 FE 48                CP      'H'             ; Hex number indicated? [function added]
1930  0E69 CA EF 1C             JP      Z,HEXTFP        ; Convert Hex to FPREG
1931  0E6C FE 42                CP      'B'             ; Binary number indicated? [function added]
1932  0E6E CA 5F 1D             JP      Z,BINTFP        ; Convert Bin to FPREG
1933  0E71 1E 02                LD      E,SN            ; If neither then a ?SN Error
1934  0E73 CA 11 05             JP      Z,ERROR         ;
1935  0E76 FE AC        NOTAMP: CP      ZPLUS           ; '+' Token ?
1936  0E78 CA 4B 0E             JP      Z,OPRND         ; Yes - Look for operand
1937  0E7B FE 2E                CP      '.'             ; '.' ?
1938  0E7D CA AB 18             JP      Z,ASCTFP        ; Yes - Create FP number
1939  0E80 FE AD                CP      ZMINUS          ; '-' Token ?
1940  0E82 CA A1 0E             JP      Z,MINUS         ; Yes - Do minus
1941  0E85 FE 22                CP      '"'             ; Literal string ?
1942  0E87 CA 5A 12             JP      Z,QTSTR         ; Get string terminated by '"'
1943  0E8A FE AA                CP      ZNOT            ; "NOT" Token ?
1944  0E8C CA 93 0F             JP      Z,EVNOT         ; Yes - Eval NOT expression
1945  0E8F FE A7                CP      ZFN             ; "FN" Token ?
1946  0E91 CA BE 11             JP      Z,DOFN          ; Yes - Do FN routine
1947  0E94 D6 B6                SUB     ZSGN            ; Is it a function?
1948  0E96 D2 C3 0E             JP      NC,FNOFST       ; Yes - Evaluate function
1949  0E99 CD D0 0D     EVLPAR: CALL    OPNPAR          ; Evaluate expression in "()"
1950  0E9C CD CB 07             CALL    CHKSYN          ; Make sure ")" follows
1951  0E9F 29                   .BYTE   ")"
1952  0EA0 C9                   RET
1953  0EA1
1954  0EA1 16 7D        MINUS:  LD      D,7DH           ; '-' precedence
1955  0EA3 CD D7 0D             CALL    EVAL1           ; Evaluate until prec' break
1956  0EA6 2A 15 21             LD      HL,(NXTOPR)     ; Get next operator address
1957  0EA9 E5                   PUSH    HL              ; Save next operator address
1958  0EAA CD CD 17             CALL    INVSGN          ; Negate value
1959  0EAD CD C5 0D     RETNUM: CALL    TSTNUM          ; Make sure it's a number
1960  0EB0 E1                   POP     HL              ; Restore next operator address
1961  0EB1 C9                   RET
1962  0EB2
1963  0EB2 CD B8 0F     CONVAR: CALL    GETVAR          ; Get variable address to DE
1964  0EB5 E5           FRMEVL: PUSH    HL              ; Save code string address
1965  0EB6 EB                   EX      DE,HL           ; Variable address to HL
1966  0EB7 22 29 21             LD      (FPREG),HL      ; Save address of variable
1967  0EBA 3A F2 20             LD      A,(TYPE)        ; Get type
1968  0EBD B7                   OR      A               ; Numeric?
1969  0EBE CC E2 17             CALL    Z,PHLTFP        ; Yes - Move contents to FPREG
1970  0EC1 E1                   POP     HL              ; Restore code string address
1971  0EC2 C9                   RET
1972  0EC3
1973  0EC3 06 00        FNOFST: LD      B,0             ; Get address of function
1974  0EC5 07                   RLCA                    ; Double function offset
1975  0EC6 4F                   LD      C,A             ; BC = Offset in function table
1976  0EC7 C5                   PUSH    BC              ; Save adjusted token value
1977  0EC8 CD 55 09             CALL    GETCHR          ; Get next character
1978  0ECB 79                   LD      A,C             ; Get adjusted token value
1979  0ECC FE 31                CP      2*(ZLEFT-ZSGN)-1; Adj' LEFT$,RIGHT$ or MID$ ?
1980  0ECE DA EA 0E             JP      C,FNVAL         ; No - Do function
1981  0ED1 CD D0 0D             CALL    OPNPAR          ; Evaluate expression  (X,...
1982  0ED4 CD CB 07             CALL    CHKSYN          ; Make sure ',' follows
1983  0ED7 2C                   .BYTE      ','
1984  0ED8 CD C6 0D             CALL    TSTSTR          ; Make sure it's a string
1985  0EDB EB                   EX      DE,HL           ; Save code string address
1986  0EDC 2A 29 21             LD      HL,(FPREG)      ; Get address of string
1987  0EDF E3                   EX      (SP),HL         ; Save address of string
1988  0EE0 E5                   PUSH    HL              ; Save adjusted token value
1989  0EE1 EB                   EX      DE,HL           ; Restore code string address
1990  0EE2 CD 23 15             CALL    GETINT          ; Get integer 0-255
1991  0EE5 EB                   EX      DE,HL           ; Save code string address
1992  0EE6 E3                   EX      (SP),HL         ; Save integer,HL = adj' token
1993  0EE7 C3 F2 0E             JP      GOFUNC          ; Jump to string function
1994  0EEA
1995  0EEA CD 99 0E     FNVAL:  CALL    EVLPAR          ; Evaluate expression
1996  0EED E3                   EX      (SP),HL         ; HL = Adjusted token value
1997  0EEE 11 AD 0E             LD      DE,RETNUM       ; Return number from function
1998  0EF1 D5                   PUSH    DE              ; Save on stack
1999  0EF2 01 4E 02     GOFUNC: LD      BC,FNCTAB       ; Function routine addresses
2000  0EF5 09                   ADD     HL,BC           ; Point to right address
2001  0EF6 4E                   LD      C,(HL)          ; Get LSB of address
2002  0EF7 23                   INC     HL              ;
2003  0EF8 66                   LD      H,(HL)          ; Get MSB of address
2004  0EF9 69                   LD      L,C             ; Address to HL
2005  0EFA E9                   JP      (HL)            ; Jump to function
2006  0EFB
2007  0EFB 15           SGNEXP: DEC     D               ; Dee to flag negative exponent
2008  0EFC FE AD                CP      ZMINUS          ; '-' token ?
2009  0EFE C8                   RET     Z               ; Yes - Return
2010  0EFF FE 2D                CP      '-'             ; '-' ASCII ?
2011  0F01 C8                   RET     Z               ; Yes - Return
2012  0F02 14                   INC     D               ; Inc to flag positive exponent
2013  0F03 FE 2B                CP      '+'             ; '+' ASCII ?
2014  0F05 C8                   RET     Z               ; Yes - Return
2015  0F06 FE AC                CP      ZPLUS           ; '+' token ?
2016  0F08 C8                   RET     Z               ; Yes - Return
2017  0F09 2B                   DEC     HL              ; DEC 'cos GETCHR INCs
2018  0F0A C9                   RET                     ; Return "NZ"
2019  0F0B
2020  0F0B F6           POR:    .BYTE      0F6H            ; Flag "OR"
2021  0F0C AF           PAND:   XOR     A               ; Flag "AND"
2022  0F0D F5                   PUSH    AF              ; Save "AND" / "OR" flag
2023  0F0E CD C5 0D             CALL    TSTNUM          ; Make sure it's a number
2024  0F11 CD 07 0A             CALL    DEINT           ; Get integer -32768 to 32767
2025  0F14 F1                   POP     AF              ; Restore "AND" / "OR" flag
2026  0F15 EB                   EX      DE,HL           ; <- Get last
2027  0F16 C1                   POP     BC              ; <-  value
2028  0F17 E3                   EX      (SP),HL         ; <-  from
2029  0F18 EB                   EX      DE,HL           ; <-  stack
2030  0F19 CD E5 17             CALL    FPBCDE          ; Move last value to FPREG
2031  0F1C F5                   PUSH    AF              ; Save "AND" / "OR" flag
2032  0F1D CD 07 0A             CALL    DEINT           ; Get integer -32768 to 32767
2033  0F20 F1                   POP     AF              ; Restore "AND" / "OR" flag
2034  0F21 C1                   POP     BC              ; Get value
2035  0F22 79                   LD      A,C             ; Get LSB
2036  0F23 21 7C 11             LD      HL,ACPASS       ; Address of save AC as current
2037  0F26 C2 2E 0F             JP      NZ,POR1         ; Jump if OR
2038  0F29 A3                   AND     E               ; "AND" LSBs
2039  0F2A 4F                   LD      C,A             ; Save LSB
2040  0F2B 78                   LD      A,B             ; Get MBS
2041  0F2C A2                   AND     D               ; "AND" MSBs
2042  0F2D E9                   JP      (HL)            ; Save AC as current (ACPASS)
2043  0F2E
2044  0F2E B3           POR1:   OR      E               ; "OR" LSBs
2045  0F2F 4F                   LD      C,A             ; Save LSB
2046  0F30 78                   LD      A,B             ; Get MSB
2047  0F31 B2                   OR      D               ; "OR" MSBs
2048  0F32 E9                   JP      (HL)            ; Save AC as current (ACPASS)
2049  0F33
2050  0F33 21 45 0F     TSTRED: LD      HL,CMPLOG       ; Logical compare routine
2051  0F36 3A F2 20             LD      A,(TYPE)        ; Get data type
2052  0F39 1F                   RRA                     ; Carry set = string
2053  0F3A 7A                   LD      A,D             ; Get last precedence value
2054  0F3B 17                   RLA                     ; Times 2 plus carry
2055  0F3C 5F                   LD      E,A             ; To E
2056  0F3D 16 64                LD      D,64H           ; Relational precedence
2057  0F3F 78                   LD      A,B             ; Get current precedence
2058  0F40 BA                   CP      D               ; Compare with last
2059  0F41 D0                   RET     NC              ; Eval if last was rel' or log'
2060  0F42 C3 34 0E             JP      STKTHS          ; Stack this one and get next
2061  0F45
2062  0F45 47 0F        CMPLOG: .WORD   CMPLG1          ; Compare two values / strings
2063  0F47 79           CMPLG1: LD      A,C             ; Get data type
2064  0F48 B7                   OR      A
2065  0F49 1F                   RRA
2066  0F4A C1                   POP     BC              ; Get last expression to BCDE
2067  0F4B D1                   POP     DE
2068  0F4C F5                   PUSH    AF              ; Save status
2069  0F4D CD C7 0D             CALL    CHKTYP          ; Check that types match
2070  0F50 21 89 0F             LD      HL,CMPRES       ; Result to comparison
2071  0F53 E5                   PUSH    HL              ; Save for RETurn
2072  0F54 CA 1F 18             JP      Z,CMPNUM        ; Compare values if numeric
2073  0F57 AF                   XOR     A               ; Compare two strings
2074  0F58 32 F2 20             LD      (TYPE),A        ; Set type to numeric
2075  0F5B D5                   PUSH    DE              ; Save string name
2076  0F5C CD DE 13             CALL    GSTRCU          ; Get current string
2077  0F5F 7E                   LD      A,(HL)          ; Get length of string
2078  0F60 23                   INC     HL
2079  0F61 23                   INC     HL
2080  0F62 4E                   LD      C,(HL)          ; Get LSB of address
2081  0F63 23                   INC     HL
2082  0F64 46                   LD      B,(HL)          ; Get MSB of address
2083  0F65 D1                   POP     DE              ; Restore string name
2084  0F66 C5                   PUSH    BC              ; Save address of string
2085  0F67 F5                   PUSH    AF              ; Save length of string
2086  0F68 CD E2 13             CALL    GSTRDE          ; Get second string
2087  0F6B CD F3 17             CALL    LOADFP          ; Get address of second string
2088  0F6E F1                   POP     AF              ; Restore length of string 1
2089  0F6F 57                   LD      D,A             ; Length to D
2090  0F70 E1                   POP     HL              ; Restore address of string 1
2091  0F71 7B           CMPSTR: LD      A,E             ; Bytes of string 2 to do
2092  0F72 B2                   OR      D               ; Bytes of string 1 to do
2093  0F73 C8                   RET     Z               ; Exit if all bytes compared
2094  0F74 7A                   LD      A,D             ; Get bytes of string 1 to do
2095  0F75 D6 01                SUB     1
2096  0F77 D8                   RET     C               ; Exit if end of string 1
2097  0F78 AF                   XOR     A
2098  0F79 BB                   CP      E               ; Bytes of string 2 to do
2099  0F7A 3C                   INC     A
2100  0F7B D0                   RET     NC              ; Exit if end of string 2
2101  0F7C 15                   DEC     D               ; Count bytes in string 1
2102  0F7D 1D                   DEC     E               ; Count bytes in string 2
2103  0F7E 0A                   LD      A,(BC)          ; Byte in string 2
2104  0F7F BE                   CP      (HL)            ; Compare to byte in string 1
2105  0F80 23                   INC     HL              ; Move up string 1
2106  0F81 03                   INC     BC              ; Move up string 2
2107  0F82 CA 71 0F             JP      Z,CMPSTR        ; Same - Try next bytes
2108  0F85 3F                   CCF                     ; Flag difference (">" or "<")
2109  0F86 C3 AF 17             JP      FLGDIF          ; "<" gives -1 , ">" gives +1
2110  0F89
2111  0F89 3C           CMPRES: INC     A               ; Increment current value
2112  0F8A 8F                   ADC     A,A             ; Double plus carry
2113  0F8B C1                   POP     BC              ; Get other value
2114  0F8C A0                   AND     B               ; Combine them
2115  0F8D C6 FF                ADD     A,-1            ; Carry set if different
2116  0F8F 9F                   SBC     A,A             ; 00 - Equal , FF - Different
2117  0F90 C3 B6 17             JP      FLGREL          ; Set current value & continue
2118  0F93
2119  0F93 16 5A        EVNOT:  LD      D,5AH           ; Precedence value for "NOT"
2120  0F95 CD D7 0D             CALL    EVAL1           ; Eval until precedence break
2121  0F98 CD C5 0D             CALL    TSTNUM          ; Make sure it's a number
2122  0F9B CD 07 0A             CALL    DEINT           ; Get integer -32768 - 32767
2123  0F9E 7B                   LD      A,E             ; Get LSB
2124  0F9F 2F                   CPL                     ; Invert LSB
2125  0FA0 4F                   LD      C,A             ; Save "NOT" of LSB
2126  0FA1 7A                   LD      A,D             ; Get MSB
2127  0FA2 2F                   CPL                     ; Invert MSB
2128  0FA3 CD 7C 11             CALL    ACPASS          ; Save AC as current
2129  0FA6 C1                   POP     BC              ; Clean up stack
2130  0FA7 C3 E3 0D             JP      EVAL3           ; Continue evaluation
2131  0FAA
2132  0FAA 2B           DIMRET: DEC     HL              ; DEC 'cos GETCHR INCs
2133  0FAB CD 55 09             CALL    GETCHR          ; Get next character
2134  0FAE C8                   RET     Z               ; End of DIM statement
2135  0FAF CD CB 07             CALL    CHKSYN          ; Make sure ',' follows
2136  0FB2 2C                   .BYTE      ','
2137  0FB3 01 AA 0F     DIM:    LD      BC,DIMRET       ; Return to "DIMRET"
2138  0FB6 C5                   PUSH    BC              ; Save on stack
2139  0FB7 F6                   .BYTE      0F6H            ; Flag "Create" variable
2140  0FB8 AF           GETVAR: XOR     A               ; Find variable address,to DE
2141  0FB9 32 F1 20             LD      (LCRFLG),A      ; Set locate / create flag
2142  0FBC 46                   LD      B,(HL)          ; Get First byte of name
2143  0FBD CD F3 09     GTFNAM: CALL    CHKLTR          ; See if a letter
2144  0FC0 DA FD 04             JP      C,SNERR         ; ?SN Error if not a letter
2145  0FC3 AF                   XOR     A
2146  0FC4 4F                   LD      C,A             ; Clear second byte of name
2147  0FC5 32 F2 20             LD      (TYPE),A        ; Set type to numeric
2148  0FC8 CD 55 09             CALL    GETCHR          ; Get next character
2149  0FCB DA D4 0F             JP      C,SVNAM2        ; Numeric - Save in name
2150  0FCE CD F3 09             CALL    CHKLTR          ; See if a letter
2151  0FD1 DA E1 0F             JP      C,CHARTY        ; Not a letter - Check type
2152  0FD4 4F           SVNAM2: LD      C,A             ; Save second byte of name
2153  0FD5 CD 55 09     ENDNAM: CALL    GETCHR          ; Get next character
2154  0FD8 DA D5 0F             JP      C,ENDNAM        ; Numeric - Get another
2155  0FDB CD F3 09             CALL    CHKLTR          ; See if a letter
2156  0FDE D2 D5 0F             JP      NC,ENDNAM       ; Letter - Get another
2157  0FE1 D6 24        CHARTY: SUB     '$'             ; String variable?
2158  0FE3 C2 F0 0F             JP      NZ,NOTSTR       ; No - Numeric variable
2159  0FE6 3C                   INC     A               ; A = 1 (string type)
2160  0FE7 32 F2 20             LD      (TYPE),A        ; Set type to string
2161  0FEA 0F                   RRCA                    ; A = 80H , Flag for string
2162  0FEB 81                   ADD     A,C             ; 2nd byte of name has bit 7 on
2163  0FEC 4F                   LD      C,A             ; Resave second byte on name
2164  0FED CD 55 09             CALL    GETCHR          ; Get next character
2165  0FF0 3A 10 21     NOTSTR: LD      A,(FORFLG)      ; Array name needed ?
2166  0FF3 3D                   DEC     A
2167  0FF4 CA 9D 10             JP      Z,ARLDSV        ; Yes - Get array name
2168  0FF7 F2 00 10             JP      P,NSCFOR        ; No array with "FOR" or "FN"
2169  0FFA 7E                   LD      A,(HL)          ; Get byte again
2170  0FFB D6 28                SUB     '('             ; Subscripted variable?
2171  0FFD CA 75 10             JP      Z,SBSCPT        ; Yes - Sort out subscript
2172  1000
2173  1000 AF           NSCFOR: XOR     A               ; Simple variable
2174  1001 32 10 21             LD      (FORFLG),A      ; Clear "FOR" flag
2175  1004 E5                   PUSH    HL              ; Save code string address
2176  1005 50                   LD      D,B             ; DE = Variable name to find
2177  1006 59                   LD      E,C
2178  1007 2A 23 21             LD      HL,(FNRGNM)     ; FN argument name
2179  100A CD C5 07             CALL    CPDEHL          ; Is it the FN argument?
2180  100D 11 25 21             LD      DE,FNARG        ; Point to argument value
2181  1010 CA E5 16             JP      Z,POPHRT        ; Yes - Return FN argument value
2182  1013 2A 1D 21             LD      HL,(VAREND)     ; End of variables
2183  1016 EB                   EX      DE,HL           ; Address of end of search
2184  1017 2A 1B 21             LD      HL,(PROGND)     ; Start of variables address
2185  101A CD C5 07     FNDVAR: CALL    CPDEHL          ; End of variable list table?
2186  101D CA 33 10             JP      Z,CFEVAL        ; Yes - Called from EVAL?
2187  1020 79                   LD      A,C             ; Get second byte of name
2188  1021 96                   SUB     (HL)            ; Compare with name in list
2189  1022 23                   INC     HL              ; Move on to first byte
2190  1023 C2 28 10             JP      NZ,FNTHR        ; Different - Find another
2191  1026 78                   LD      A,B             ; Get first byte of name
2192  1027 96                   SUB     (HL)            ; Compare with name in list
2193  1028 23           FNTHR:  INC     HL              ; Move on to LSB of value
2194  1029 CA 67 10             JP      Z,RETADR        ; Found - Return address
2195  102C 23                   INC     HL              ; <- Skip
2196  102D 23                   INC     HL              ; <- over
2197  102E 23                   INC     HL              ; <- F.P.
2198  102F 23                   INC     HL              ; <- value
2199  1030 C3 1A 10             JP      FNDVAR          ; Keep looking
2200  1033
2201  1033 E1           CFEVAL: POP     HL              ; Restore code string address
2202  1034 E3                   EX      (SP),HL         ; Get return address
2203  1035 D5                   PUSH    DE              ; Save address of variable
2204  1036 11 B5 0E             LD      DE,FRMEVL       ; Return address in EVAL
2205  1039 CD C5 07             CALL    CPDEHL          ; Called from EVAL ?
2206  103C D1                   POP     DE              ; Restore address of variable
2207  103D CA 6A 10             JP      Z,RETNUL        ; Yes - Return null variable
2208  1040 E3                   EX      (SP),HL         ; Put back return
2209  1041 E5                   PUSH    HL              ; Save code string address
2210  1042 C5                   PUSH    BC              ; Save variable name
2211  1043 01 06 00             LD      BC,6            ; 2 byte name plus 4 byte data
2212  1046 2A 1F 21             LD      HL,(ARREND)     ; End of arrays
2213  1049 E5                   PUSH    HL              ; Save end of arrays
2214  104A 09                   ADD     HL,BC           ; Move up 6 bytes
2215  104B C1                   POP     BC              ; Source address in BC
2216  104C E5                   PUSH    HL              ; Save new end address
2217  104D CD C9 04             CALL    MOVUP           ; Move arrays up
2218  1050 E1                   POP     HL              ; Restore new end address
2219  1051 22 1F 21             LD      (ARREND),HL     ; Set new end address
2220  1054 60                   LD      H,B             ; End of variables to HL
2221  1055 69                   LD      L,C
2222  1056 22 1D 21             LD      (VAREND),HL     ; Set new end address
2223  1059
2224  1059 2B           ZEROLP: DEC     HL              ; Back through to zero variable
2225  105A 36 00                LD      (HL),0          ; Zero byte in variable
2226  105C CD C5 07             CALL    CPDEHL          ; Done them all?
2227  105F C2 59 10             JP      NZ,ZEROLP       ; No - Keep on going
2228  1062 D1                   POP     DE              ; Get variable name
2229  1063 73                   LD      (HL),E          ; Store second character
2230  1064 23                   INC     HL
2231  1065 72                   LD      (HL),D          ; Store first character
2232  1066 23                   INC     HL
2233  1067 EB           RETADR: EX      DE,HL           ; Address of variable in DE
2234  1068 E1                   POP     HL              ; Restore code string address
2235  1069 C9                   RET
2236  106A
2237  106A 32 2C 21     RETNUL: LD      (FPEXP),A       ; Set result to zero
2238  106D 21 99 04             LD      HL,ZERBYT       ; Also set a null string
2239  1070 22 29 21             LD      (FPREG),HL      ; Save for EVAL
2240  1073 E1                   POP     HL              ; Restore code string address
2241  1074 C9                   RET
2242  1075
2243  1075 E5           SBSCPT: PUSH    HL              ; Save code string address
2244  1076 2A F1 20             LD      HL,(LCRFLG)     ; Locate/Create and Type
2245  1079 E3                   EX      (SP),HL         ; Save and get code string
2246  107A 57                   LD      D,A             ; Zero number of dimensions
2247  107B D5           SCPTLP: PUSH    DE              ; Save number of dimensions
2248  107C C5                   PUSH    BC              ; Save array name
2249  107D CD FB 09             CALL    FPSINT          ; Get subscript (0-32767)
2250  1080 C1                   POP     BC              ; Restore array name
2251  1081 F1                   POP     AF              ; Get number of dimensions
2252  1082 EB                   EX      DE,HL
2253  1083 E3                   EX      (SP),HL         ; Save subscript value
2254  1084 E5                   PUSH    HL              ; Save LCRFLG and TYPE
2255  1085 EB                   EX      DE,HL
2256  1086 3C                   INC     A               ; Count dimensions
2257  1087 57                   LD      D,A             ; Save in D
2258  1088 7E                   LD      A,(HL)          ; Get next byte in code string
2259  1089 FE 2C                CP      ','             ; Comma (more to come)?
2260  108B CA 7B 10             JP      Z,SCPTLP        ; Yes - More subscripts
2261  108E CD CB 07             CALL    CHKSYN          ; Make sure ")" follows
2262  1091 29                   .BYTE      ")"
2263  1092 22 15 21             LD      (NXTOPR),HL     ; Save code string address
2264  1095 E1                   POP     HL              ; Get LCRFLG and TYPE
2265  1096 22 F1 20             LD      (LCRFLG),HL     ; Restore Locate/create & type
2266  1099 1E 00                LD      E,0             ; Flag not CSAVE* or CLOAD*
2267  109B D5                   PUSH    DE              ; Save number of dimensions (D)
2268  109C 11                   .BYTE      11H             ; Skip "PUSH HL" and "PUSH AF'
2269  109D
2270  109D E5           ARLDSV: PUSH    HL              ; Save code string address
2271  109E F5                   PUSH    AF              ; A = 00 , Flags set = Z,N
2272  109F 2A 1D 21             LD      HL,(VAREND)     ; Start of arrays
2273  10A2 3E                   .BYTE      3EH             ; Skip "ADD HL,DE"
2274  10A3 19           FNDARY: ADD     HL,DE           ; Move to next array start
2275  10A4 EB                   EX      DE,HL
2276  10A5 2A 1F 21             LD      HL,(ARREND)     ; End of arrays
2277  10A8 EB                   EX      DE,HL           ; Current array pointer
2278  10A9 CD C5 07             CALL    CPDEHL          ; End of arrays found?
2279  10AC CA D5 10             JP      Z,CREARY        ; Yes - Create array
2280  10AF 7E                   LD      A,(HL)          ; Get second byte of name
2281  10B0 B9                   CP      C               ; Compare with name given
2282  10B1 23                   INC     HL              ; Move on
2283  10B2 C2 B7 10             JP      NZ,NXTARY       ; Different - Find next array
2284  10B5 7E                   LD      A,(HL)          ; Get first byte of name
2285  10B6 B8                   CP      B               ; Compare with name given
2286  10B7 23           NXTARY: INC     HL              ; Move on
2287  10B8 5E                   LD      E,(HL)          ; Get LSB of next array address
2288  10B9 23                   INC     HL
2289  10BA 56                   LD      D,(HL)          ; Get MSB of next array address
2290  10BB 23                   INC     HL
2291  10BC C2 A3 10             JP      NZ,FNDARY       ; Not found - Keep looking
2292  10BF 3A F1 20             LD      A,(LCRFLG)      ; Found Locate or Create it?
2293  10C2 B7                   OR      A
2294  10C3 C2 06 05             JP      NZ,DDERR        ; Create - ?DD Error
2295  10C6 F1                   POP     AF              ; Locate - Get number of dim'ns
2296  10C7 44                   LD      B,H             ; BC Points to array dim'ns
2297  10C8 4D                   LD      C,L
2298  10C9 CA E5 16             JP      Z,POPHRT        ; Jump if array load/save
2299  10CC 96                   SUB     (HL)            ; Same number of dimensions?
2300  10CD CA 33 11             JP      Z,FINDEL        ; Yes - Find element
2301  10D0 1E 10        BSERR:  LD      E,BS            ; ?BS Error
2302  10D2 C3 11 05             JP      ERROR           ; Output error
2303  10D5
2304  10D5 11 04 00     CREARY: LD      DE,4            ; 4 Bytes per entry
2305  10D8 F1                   POP     AF              ; Array to save or 0 dim'ns?
2306  10D9 CA 1C 0A             JP      Z,FCERR         ; Yes - ?FC Error
2307  10DC 71                   LD      (HL),C          ; Save second byte of name
2308  10DD 23                   INC     HL
2309  10DE 70                   LD      (HL),B          ; Save first byte of name
2310  10DF 23                   INC     HL
2311  10E0 4F                   LD      C,A             ; Number of dimensions to C
2312  10E1 CD DA 04             CALL    CHKSTK          ; Check if enough memory
2313  10E4 23                   INC     HL              ; Point to number of dimensions
2314  10E5 23                   INC     HL
2315  10E6 22 0A 21             LD      (CUROPR),HL     ; Save address of pointer
2316  10E9 71                   LD      (HL),C          ; Set number of dimensions
2317  10EA 23                   INC     HL
2318  10EB 3A F1 20             LD      A,(LCRFLG)      ; Locate of Create?
2319  10EE 17                   RLA                     ; Carry set = Create
2320  10EF 79                   LD      A,C             ; Get number of dimensions
2321  10F0 01 0B 00     CRARLP: LD      BC,10+1         ; Default dimension size 10
2322  10F3 D2 F8 10             JP      NC,DEFSIZ       ; Locate - Set default size
2323  10F6 C1                   POP     BC              ; Get specified dimension size
2324  10F7 03                   INC     BC              ; Include zero element
2325  10F8 71           DEFSIZ: LD      (HL),C          ; Save LSB of dimension size
2326  10F9 23                   INC     HL
2327  10FA 70                   LD      (HL),B          ; Save MSB of dimension size
2328  10FB 23                   INC     HL
2329  10FC F5                   PUSH    AF              ; Save num' of dim'ns an status
2330  10FD E5                   PUSH    HL              ; Save address of dim'n size
2331  10FE CD 90 18             CALL    MLDEBC          ; Multiply DE by BC to find
2332  1101 EB                   EX      DE,HL           ; amount of mem needed (to DE)
2333  1102 E1                   POP     HL              ; Restore address of dimension
2334  1103 F1                   POP     AF              ; Restore number of dimensions
2335  1104 3D                   DEC     A               ; Count them
2336  1105 C2 F0 10             JP      NZ,CRARLP       ; Do next dimension if more
2337  1108 F5                   PUSH    AF              ; Save locate/create flag
2338  1109 42                   LD      B,D             ; MSB of memory needed
2339  110A 4B                   LD      C,E             ; LSB of memory needed
2340  110B EB                   EX      DE,HL
2341  110C 19                   ADD     HL,DE           ; Add bytes to array start
2342  110D DA F2 04             JP      C,OMERR         ; Too big - Error
2343  1110 CD E3 04             CALL    ENFMEM          ; See if enough memory
2344  1113 22 1F 21             LD      (ARREND),HL     ; Save new end of array
2345  1116
2346  1116 2B           ZERARY: DEC     HL              ; Back through array data
2347  1117 36 00                LD      (HL),0          ; Set array element to zero
2348  1119 CD C5 07             CALL    CPDEHL          ; All elements zeroed?
2349  111C C2 16 11             JP      NZ,ZERARY       ; No - Keep on going
2350  111F 03                   INC     BC              ; Number of bytes + 1
2351  1120 57                   LD      D,A             ; A=0
2352  1121 2A 0A 21             LD      HL,(CUROPR)     ; Get address of array
2353  1124 5E                   LD      E,(HL)          ; Number of dimensions
2354  1125 EB                   EX      DE,HL           ; To HL
2355  1126 29                   ADD     HL,HL           ; Two bytes per dimension size
2356  1127 09                   ADD     HL,BC           ; Add number of bytes
2357  1128 EB                   EX      DE,HL           ; Bytes needed to DE
2358  1129 2B                   DEC     HL
2359  112A 2B                   DEC     HL
2360  112B 73                   LD      (HL),E          ; Save LSB of bytes needed
2361  112C 23                   INC     HL
2362  112D 72                   LD      (HL),D          ; Save MSB of bytes needed
2363  112E 23                   INC     HL
2364  112F F1                   POP     AF              ; Locate / Create?
2365  1130 DA 57 11             JP      C,ENDDIM        ; A is 0 , End if create
2366  1133 47           FINDEL: LD      B,A             ; Find array element
2367  1134 4F                   LD      C,A
2368  1135 7E                   LD      A,(HL)          ; Number of dimensions
2369  1136 23                   INC     HL
2370  1137 16                   .BYTE      16H             ; Skip "POP HL"
2371  1138 E1           FNDELP: POP     HL              ; Address of next dim' size
2372  1139 5E                   LD      E,(HL)          ; Get LSB of dim'n size
2373  113A 23                   INC     HL
2374  113B 56                   LD      D,(HL)          ; Get MSB of dim'n size
2375  113C 23                   INC     HL
2376  113D E3                   EX      (SP),HL         ; Save address - Get index
2377  113E F5                   PUSH    AF              ; Save number of dim'ns
2378  113F CD C5 07             CALL    CPDEHL          ; Dimension too large?
2379  1142 D2 D0 10             JP      NC,BSERR        ; Yes - ?BS Error
2380  1145 E5                   PUSH    HL              ; Save index
2381  1146 CD 90 18             CALL    MLDEBC          ; Multiply previous by size
2382  1149 D1                   POP     DE              ; Index supplied to DE
2383  114A 19                   ADD     HL,DE           ; Add index to pointer
2384  114B F1                   POP     AF              ; Number of dimensions
2385  114C 3D                   DEC     A               ; Count them
2386  114D 44                   LD      B,H             ; MSB of pointer
2387  114E 4D                   LD      C,L             ; LSB of pointer
2388  114F C2 38 11             JP      NZ,FNDELP       ; More - Keep going
2389  1152 29                   ADD     HL,HL           ; 4 Bytes per element
2390  1153 29                   ADD     HL,HL
2391  1154 C1                   POP     BC              ; Start of array
2392  1155 09                   ADD     HL,BC           ; Point to element
2393  1156 EB                   EX      DE,HL           ; Address of element to DE
2394  1157 2A 15 21     ENDDIM: LD      HL,(NXTOPR)     ; Got code string address
2395  115A C9                   RET
2396  115B
2397  115B 2A 1F 21     FRE:    LD      HL,(ARREND)     ; Start of free memory
2398  115E EB                   EX      DE,HL           ; To DE
2399  115F 21 00 00             LD      HL,0            ; End of free memory
2400  1162 39                   ADD     HL,SP           ; Current stack value
2401  1163 3A F2 20             LD      A,(TYPE)        ; Dummy argument type
2402  1166 B7                   OR      A
2403  1167 CA 77 11             JP      Z,FRENUM        ; Numeric - Free variable space
2404  116A CD DE 13             CALL    GSTRCU          ; Current string to pool
2405  116D CD DE 12             CALL    GARBGE          ; Garbage collection
2406  1170 2A 9F 20             LD      HL,(STRSPC)     ; Bottom of string space in use
2407  1173 EB                   EX      DE,HL           ; To DE
2408  1174 2A 08 21             LD      HL,(STRBOT)     ; Bottom of string space
2409  1177 7D           FRENUM: LD      A,L             ; Get LSB of end
2410  1178 93                   SUB     E               ; Subtract LSB of beginning
2411  1179 4F                   LD      C,A             ; Save difference if C
2412  117A 7C                   LD      A,H             ; Get MSB of end
2413  117B 9A                   SBC     A,D             ; Subtract MSB of beginning
2414  117C 41           ACPASS: LD      B,C             ; Return integer AC
2415  117D 50           ABPASS: LD      D,B             ; Return integer AB
2416  117E 1E 00                LD      E,0
2417  1180 21 F2 20             LD      HL,TYPE         ; Point to type
2418  1183 73                   LD      (HL),E          ; Set type to numeric
2419  1184 06 90                LD      B,80H+16        ; 16 bit integer
2420  1186 C3 BB 17             JP      RETINT          ; Return the integr
2421  1189
2422  1189 3A F0 20     POS:    LD      A,(CURPOS)      ; Get cursor position
2423  118C 47           PASSA:  LD      B,A             ; Put A into AB
2424  118D AF                   XOR     A               ; Zero A
2425  118E C3 7D 11             JP      ABPASS          ; Return integer AB
2426  1191
2427  1191 CD 14 12     DEF:    CALL    CHEKFN          ; Get "FN" and name
2428  1194 CD 06 12             CALL    IDTEST          ; Test for illegal direct
2429  1197 01 EC 0A             LD      BC,DATA         ; To get next statement
2430  119A C5                   PUSH    BC              ; Save address for RETurn
2431  119B D5                   PUSH    DE              ; Save address of function ptr
2432  119C CD CB 07             CALL    CHKSYN          ; Make sure "(" follows
2433  119F 28                   .BYTE      "("
2434  11A0 CD B8 0F             CALL    GETVAR          ; Get argument variable name
2435  11A3 E5                   PUSH    HL              ; Save code string address
2436  11A4 EB                   EX      DE,HL           ; Argument address to HL
2437  11A5 2B                   DEC     HL
2438  11A6 56                   LD      D,(HL)          ; Get first byte of arg name
2439  11A7 2B                   DEC     HL
2440  11A8 5E                   LD      E,(HL)          ; Get second byte of arg name
2441  11A9 E1                   POP     HL              ; Restore code string address
2442  11AA CD C5 0D             CALL    TSTNUM          ; Make sure numeric argument
2443  11AD CD CB 07             CALL    CHKSYN          ; Make sure ")" follows
2444  11B0 29                   .BYTE      ")"
2445  11B1 CD CB 07             CALL    CHKSYN          ; Make sure "=" follows
2446  11B4 B4                   .BYTE      ZEQUAL          ; "=" token
2447  11B5 44                   LD      B,H             ; Code string address to BC
2448  11B6 4D                   LD      C,L
2449  11B7 E3                   EX      (SP),HL         ; Save code str , Get FN ptr
2450  11B8 71                   LD      (HL),C          ; Save LSB of FN code string
2451  11B9 23                   INC     HL
2452  11BA 70                   LD      (HL),B          ; Save MSB of FN code string
2453  11BB C3 53 12             JP      SVSTAD          ; Save address and do function
2454  11BE
2455  11BE CD 14 12     DOFN:   CALL    CHEKFN          ; Make sure FN follows
2456  11C1 D5                   PUSH    DE              ; Save function pointer address
2457  11C2 CD 99 0E             CALL    EVLPAR          ; Evaluate expression in "()"
2458  11C5 CD C5 0D             CALL    TSTNUM          ; Make sure numeric result
2459  11C8 E3                   EX      (SP),HL         ; Save code str , Get FN ptr
2460  11C9 5E                   LD      E,(HL)          ; Get LSB of FN code string
2461  11CA 23                   INC     HL
2462  11CB 56                   LD      D,(HL)          ; Get MSB of FN code string
2463  11CC 23                   INC     HL
2464  11CD 7A                   LD      A,D             ; And function DEFined?
2465  11CE B3                   OR      E
2466  11CF CA 09 05             JP      Z,UFERR         ; No - ?UF Error
2467  11D2 7E                   LD      A,(HL)          ; Get LSB of argument address
2468  11D3 23                   INC     HL
2469  11D4 66                   LD      H,(HL)          ; Get MSB of argument address
2470  11D5 6F                   LD      L,A             ; HL = Arg variable address
2471  11D6 E5                   PUSH    HL              ; Save it
2472  11D7 2A 23 21             LD      HL,(FNRGNM)     ; Get old argument name
2473  11DA E3                   EX      (SP),HL ;       ; Save old , Get new
2474  11DB 22 23 21             LD      (FNRGNM),HL     ; Set new argument name
2475  11DE 2A 27 21             LD      HL,(FNARG+2)    ; Get LSB,NLSB of old arg value
2476  11E1 E5                   PUSH    HL              ; Save it
2477  11E2 2A 25 21             LD      HL,(FNARG)      ; Get MSB,EXP of old arg value
2478  11E5 E5                   PUSH    HL              ; Save it
2479  11E6 21 25 21             LD      HL,FNARG        ; HL = Value of argument
2480  11E9 D5                   PUSH    DE              ; Save FN code string address
2481  11EA CD FC 17             CALL    FPTHL           ; Move FPREG to argument
2482  11ED E1                   POP     HL              ; Get FN code string address
2483  11EE CD C2 0D             CALL    GETNUM          ; Get value from function
2484  11F1 2B                   DEC     HL              ; DEC 'cos GETCHR INCs
2485  11F2 CD 55 09             CALL    GETCHR          ; Get next character
2486  11F5 C2 FD 04             JP      NZ,SNERR        ; Bad character in FN - Error
2487  11F8 E1                   POP     HL              ; Get MSB,EXP of old arg
2488  11F9 22 25 21             LD      (FNARG),HL      ; Restore it
2489  11FC E1                   POP     HL              ; Get LSB,NLSB of old arg
2490  11FD 22 27 21             LD      (FNARG+2),HL    ; Restore it
2491  1200 E1                   POP     HL              ; Get name of old arg
2492  1201 22 23 21             LD      (FNRGNM),HL     ; Restore it
2493  1204 E1                   POP     HL              ; Restore code string address
2494  1205 C9                   RET
2495  1206
2496  1206 E5           IDTEST: PUSH    HL              ; Save code string address
2497  1207 2A A1 20             LD      HL,(LINEAT)     ; Get current line number
2498  120A 23                   INC     HL              ; -1 means direct statement
2499  120B 7C                   LD      A,H
2500  120C B5                   OR      L
2501  120D E1                   POP     HL              ; Restore code string address
2502  120E C0                   RET     NZ              ; Return if in program
2503  120F 1E 16                LD      E,ID            ; ?ID Error
2504  1211 C3 11 05             JP      ERROR
2505  1214
2506  1214 CD CB 07     CHEKFN: CALL    CHKSYN          ; Make sure FN follows
2507  1217 A7                   .BYTE      ZFN             ; "FN" token
2508  1218 3E 80                LD      A,80H
2509  121A 32 10 21             LD      (FORFLG),A      ; Flag FN name to find
2510  121D B6                   OR      (HL)            ; FN name has bit 7 set
2511  121E 47                   LD      B,A             ; in first byte of name
2512  121F CD BD 0F             CALL    GTFNAM          ; Get FN name
2513  1222 C3 C5 0D             JP      TSTNUM          ; Make sure numeric function
2514  1225
2515  1225 CD C5 0D     STR:    CALL    TSTNUM          ; Make sure it's a number
2516  1228 CD 49 19             CALL    NUMASC          ; Turn number into text
2517  122B CD 59 12     STR1:   CALL    CRTST           ; Create string entry for it
2518  122E CD DE 13             CALL    GSTRCU          ; Current string to pool
2519  1231 01 39 14             LD      BC,TOPOOL       ; Save in string pool
2520  1234 C5                   PUSH    BC              ; Save address on stack
2521  1235
2522  1235 7E           SAVSTR: LD      A,(HL)          ; Get string length
2523  1236 23                   INC     HL
2524  1237 23                   INC     HL
2525  1238 E5                   PUSH    HL              ; Save pointer to string
2526  1239 CD B4 12             CALL    TESTR           ; See if enough string space
2527  123C E1                   POP     HL              ; Restore pointer to string
2528  123D 4E                   LD      C,(HL)          ; Get LSB of address
2529  123E 23                   INC     HL
2530  123F 46                   LD      B,(HL)          ; Get MSB of address
2531  1240 CD 4D 12             CALL    CRTMST          ; Create string entry
2532  1243 E5                   PUSH    HL              ; Save pointer to MSB of addr
2533  1244 6F                   LD      L,A             ; Length of string
2534  1245 CD D1 13             CALL    TOSTRA          ; Move to string area
2535  1248 D1                   POP     DE              ; Restore pointer to MSB
2536  1249 C9                   RET
2537  124A
2538  124A CD B4 12     MKTMST: CALL    TESTR           ; See if enough string space
2539  124D 21 04 21     CRTMST: LD      HL,TMPSTR       ; Temporary string
2540  1250 E5                   PUSH    HL              ; Save it
2541  1251 77                   LD      (HL),A          ; Save length of string
2542  1252 23                   INC     HL
2543  1253 23           SVSTAD: INC     HL
2544  1254 73                   LD      (HL),E          ; Save LSB of address
2545  1255 23                   INC     HL
2546  1256 72                   LD      (HL),D          ; Save MSB of address
2547  1257 E1                   POP     HL              ; Restore pointer
2548  1258 C9                   RET
2549  1259
2550  1259 2B           CRTST:  DEC     HL              ; DEC - INCed after
2551  125A 06 22        QTSTR:  LD      B,'"'           ; Terminating quote
2552  125C 50                   LD      D,B             ; Quote to D
2553  125D E5           DTSTR:  PUSH    HL              ; Save start
2554  125E 0E FF                LD      C,-1            ; Set counter to -1
2555  1260 23           QTSTLP: INC     HL              ; Move on
2556  1261 7E                   LD      A,(HL)          ; Get byte
2557  1262 0C                   INC     C               ; Count bytes
2558  1263 B7                   OR      A               ; End of line?
2559  1264 CA 6F 12             JP      Z,CRTSTE        ; Yes - Create string entry
2560  1267 BA                   CP      D               ; Terminator D found?
2561  1268 CA 6F 12             JP      Z,CRTSTE        ; Yes - Create string entry
2562  126B B8                   CP      B               ; Terminator B found?
2563  126C C2 60 12             JP      NZ,QTSTLP       ; No - Keep looking
2564  126F FE 22        CRTSTE: CP      '"'             ; End with '"'?
2565  1271 CC 55 09             CALL    Z,GETCHR        ; Yes - Get next character
2566  1274 E3                   EX      (SP),HL         ; Starting quote
2567  1275 23                   INC     HL              ; First byte of string
2568  1276 EB                   EX      DE,HL           ; To DE
2569  1277 79                   LD      A,C             ; Get length
2570  1278 CD 4D 12             CALL    CRTMST          ; Create string entry
2571  127B 11 04 21     TSTOPL: LD      DE,TMPSTR       ; Temporary string
2572  127E 2A F6 20             LD      HL,(TMSTPT)     ; Temporary string pool pointer
2573  1281 22 29 21             LD      (FPREG),HL      ; Save address of string ptr
2574  1284 3E 01                LD      A,1
2575  1286 32 F2 20             LD      (TYPE),A        ; Set type to string
2576  1289 CD FF 17             CALL    DETHL4          ; Move string to pool
2577  128C CD C5 07             CALL    CPDEHL          ; Out of string pool?
2578  128F 22 F6 20             LD      (TMSTPT),HL     ; Save new pointer
2579  1292 E1                   POP     HL              ; Restore code string address
2580  1293 7E                   LD      A,(HL)          ; Get next code byte
2581  1294 C0                   RET     NZ              ; Return if pool OK
2582  1295 1E 1E                LD      E,ST            ; ?ST Error
2583  1297 C3 11 05             JP      ERROR           ; String pool overflow
2584  129A
2585  129A 23           PRNUMS: INC     HL              ; Skip leading space
2586  129B CD 59 12     PRS:    CALL    CRTST           ; Create string entry for it
2587  129E CD DE 13     PRS1:   CALL    GSTRCU          ; Current string to pool
2588  12A1 CD F3 17             CALL    LOADFP          ; Move string block to BCDE
2589  12A4 1C                   INC     E               ; Length + 1
2590  12A5 1D           PRSLP:  DEC     E               ; Count characters
2591  12A6 C8                   RET     Z               ; End of string
2592  12A7 0A                   LD      A,(BC)          ; Get byte to output
2593  12A8 CD D6 07             CALL    OUTC            ; Output character in A
2594  12AB FE 0D                CP      CR1              ; Return?
2595  12AD CC 07 0C             CALL    Z,DONULL        ; Yes - Do nulls
2596  12B0 03                   INC     BC              ; Next byte in string
2597  12B1 C3 A5 12             JP      PRSLP           ; More characters to output
2598  12B4
2599  12B4 B7           TESTR:  OR      A               ; Test if enough room
2600  12B5 0E                   .BYTE      0EH             ; No garbage collection done
2601  12B6 F1           GRBDON: POP     AF              ; Garbage collection done
2602  12B7 F5                   PUSH    AF              ; Save status
2603  12B8 2A 9F 20             LD      HL,(STRSPC)     ; Bottom of string space in use
2604  12BB EB                   EX      DE,HL           ; To DE
2605  12BC 2A 08 21             LD      HL,(STRBOT)     ; Bottom of string area
2606  12BF 2F                   CPL                     ; Negate length (Top down)
2607  12C0 4F                   LD      C,A             ; -Length to BC
2608  12C1 06 FF                LD      B,-1            ; BC = -ve length of string
2609  12C3 09                   ADD     HL,BC           ; Add to bottom of space in use
2610  12C4 23                   INC     HL              ; Plus one for 2's complement
2611  12C5 CD C5 07             CALL    CPDEHL          ; Below string RAM area?
2612  12C8 DA D2 12             JP      C,TESTOS        ; Tidy up if not done else err
2613  12CB 22 08 21             LD      (STRBOT),HL     ; Save new bottom of area
2614  12CE 23                   INC     HL              ; Point to first byte of string
2615  12CF EB                   EX      DE,HL           ; Address to DE
2616  12D0 F1           POPAF:  POP     AF              ; Throw away status push
2617  12D1 C9                   RET
2618  12D2
2619  12D2 F1           TESTOS: POP     AF              ; Garbage collect been done?
2620  12D3 1E 1A                LD      E,OS            ; ?OS Error
2621  12D5 CA 11 05             JP      Z,ERROR         ; Yes - Not enough string apace
2622  12D8 BF                   CP      A               ; Flag garbage collect done
2623  12D9 F5                   PUSH    AF              ; Save status
2624  12DA 01 B6 12             LD      BC,GRBDON       ; Garbage collection done
2625  12DD C5                   PUSH    BC              ; Save for RETurn
2626  12DE 2A F4 20     GARBGE: LD      HL,(LSTRAM)     ; Get end of RAM pointer
2627  12E1 22 08 21     GARBLP: LD      (STRBOT),HL     ; Reset string pointer
2628  12E4 21 00 00             LD      HL,0
2629  12E7 E5                   PUSH    HL              ; Flag no string found
2630  12E8 2A 9F 20             LD      HL,(STRSPC)     ; Get bottom of string space
2631  12EB E5                   PUSH    HL              ; Save bottom of string space
2632  12EC 21 F8 20             LD      HL,TMSTPL       ; Temporary string pool
2633  12EF EB           GRBLP:  EX      DE,HL
2634  12F0 2A F6 20             LD      HL,(TMSTPT)     ; Temporary string pool pointer
2635  12F3 EB                   EX      DE,HL
2636  12F4 CD C5 07             CALL    CPDEHL          ; Temporary string pool done?
2637  12F7 01 EF 12             LD      BC,GRBLP        ; Loop until string pool done
2638  12FA C2 43 13             JP      NZ,STPOOL       ; No - See if in string area
2639  12FD 2A 1B 21             LD      HL,(PROGND)     ; Start of simple variables
2640  1300 EB           SMPVAR: EX      DE,HL
2641  1301 2A 1D 21             LD      HL,(VAREND)     ; End of simple variables
2642  1304 EB                   EX      DE,HL
2643  1305 CD C5 07             CALL    CPDEHL          ; All simple strings done?
2644  1308 CA 16 13             JP      Z,ARRLP         ; Yes - Do string arrays
2645  130B 7E                   LD      A,(HL)          ; Get type of variable
2646  130C 23                   INC     HL
2647  130D 23                   INC     HL
2648  130E B7                   OR      A               ; "S" flag set if string
2649  130F CD 46 13             CALL    STRADD          ; See if string in string area
2650  1312 C3 00 13             JP      SMPVAR          ; Loop until simple ones done
2651  1315
2652  1315 C1           GNXARY: POP     BC              ; Scrap address of this array
2653  1316 EB           ARRLP:  EX      DE,HL
2654  1317 2A 1F 21             LD      HL,(ARREND)     ; End of string arrays
2655  131A EB                   EX      DE,HL
2656  131B CD C5 07             CALL    CPDEHL          ; All string arrays done?
2657  131E CA 6C 13             JP      Z,SCNEND        ; Yes - Move string if found
2658  1321 CD F3 17             CALL    LOADFP          ; Get array name to BCDE
2659  1324 7B                   LD      A,E             ; Get type of array
2660  1325 E5                   PUSH    HL              ; Save address of num of dim'ns
2661  1326 09                   ADD     HL,BC           ; Start of next array
2662  1327 B7                   OR      A               ; Test type of array
2663  1328 F2 15 13             JP      P,GNXARY        ; Numeric array - Ignore it
2664  132B 22 0A 21             LD      (CUROPR),HL     ; Save address of next array
2665  132E E1                   POP     HL              ; Get address of num of dim'ns
2666  132F 4E                   LD      C,(HL)          ; BC = Number of dimensions
2667  1330 06 00                LD      B,0
2668  1332 09                   ADD     HL,BC           ; Two bytes per dimension size
2669  1333 09                   ADD     HL,BC
2670  1334 23                   INC     HL              ; Plus one for number of dim'ns
2671  1335 EB           GRBARY: EX      DE,HL
2672  1336 2A 0A 21             LD      HL,(CUROPR)     ; Get address of next array
2673  1339 EB                   EX      DE,HL
2674  133A CD C5 07             CALL    CPDEHL          ; Is this array finished?
2675  133D CA 16 13             JP      Z,ARRLP         ; Yes - Get next one
2676  1340 01 35 13             LD      BC,GRBARY       ; Loop until array all done
2677  1343 C5           STPOOL: PUSH    BC              ; Save return address
2678  1344 F6 80                OR      80H             ; Flag string type
2679  1346 7E           STRADD: LD      A,(HL)          ; Get string length
2680  1347 23                   INC     HL
2681  1348 23                   INC     HL
2682  1349 5E                   LD      E,(HL)          ; Get LSB of string address
2683  134A 23                   INC     HL
2684  134B 56                   LD      D,(HL)          ; Get MSB of string address
2685  134C 23                   INC     HL
2686  134D F0                   RET     P               ; Not a string - Return
2687  134E B7                   OR      A               ; Set flags on string length
2688  134F C8                   RET     Z               ; Null string - Return
2689  1350 44                   LD      B,H             ; Save variable pointer
2690  1351 4D                   LD      C,L
2691  1352 2A 08 21             LD      HL,(STRBOT)     ; Bottom of new area
2692  1355 CD C5 07             CALL    CPDEHL          ; String been done?
2693  1358 60                   LD      H,B             ; Restore variable pointer
2694  1359 69                   LD      L,C
2695  135A D8                   RET     C               ; String done - Ignore
2696  135B E1                   POP     HL              ; Return address
2697  135C E3                   EX      (SP),HL         ; Lowest available string area
2698  135D CD C5 07             CALL    CPDEHL          ; String within string area?
2699  1360 E3                   EX      (SP),HL         ; Lowest available string area
2700  1361 E5                   PUSH    HL              ; Re-save return address
2701  1362 60                   LD      H,B             ; Restore variable pointer
2702  1363 69                   LD      L,C
2703  1364 D0                   RET     NC              ; Outside string area - Ignore
2704  1365 C1                   POP     BC              ; Get return , Throw 2 away
2705  1366 F1                   POP     AF              ;
2706  1367 F1                   POP     AF              ;
2707  1368 E5                   PUSH    HL              ; Save variable pointer
2708  1369 D5                   PUSH    DE              ; Save address of current
2709  136A C5                   PUSH    BC              ; Put back return address
2710  136B C9                   RET                     ; Go to it
2711  136C
2712  136C D1           SCNEND: POP     DE              ; Addresses of strings
2713  136D E1                   POP     HL              ;
2714  136E 7D                   LD      A,L             ; HL = 0 if no more to do
2715  136F B4                   OR      H
2716  1370 C8                   RET     Z               ; No more to do - Return
2717  1371 2B                   DEC     HL
2718  1372 46                   LD      B,(HL)          ; MSB of address of string
2719  1373 2B                   DEC     HL
2720  1374 4E                   LD      C,(HL)          ; LSB of address of string
2721  1375 E5                   PUSH    HL              ; Save variable address
2722  1376 2B                   DEC     HL
2723  1377 2B                   DEC     HL
2724  1378 6E                   LD      L,(HL)          ; HL = Length of string
2725  1379 26 00                LD      H,0
2726  137B 09                   ADD     HL,BC           ; Address of end of string+1
2727  137C 50                   LD      D,B             ; String address to DE
2728  137D 59                   LD      E,C
2729  137E 2B                   DEC     HL              ; Last byte in string
2730  137F 44                   LD      B,H             ; Address to BC
2731  1380 4D                   LD      C,L
2732  1381 2A 08 21             LD      HL,(STRBOT)     ; Current bottom of string area
2733  1384 CD CC 04             CALL    MOVSTR          ; Move string to new address
2734  1387 E1                   POP     HL              ; Restore variable address
2735  1388 71                   LD      (HL),C          ; Save new LSB of address
2736  1389 23                   INC     HL
2737  138A 70                   LD      (HL),B          ; Save new MSB of address
2738  138B 69                   LD      L,C             ; Next string area+1 to HL
2739  138C 60                   LD      H,B
2740  138D 2B                   DEC     HL              ; Next string area address
2741  138E C3 E1 12             JP      GARBLP          ; Look for more strings
2742  1391
2743  1391 C5           CONCAT: PUSH    BC              ; Save prec' opr & code string
2744  1392 E5                   PUSH    HL              ;
2745  1393 2A 29 21             LD      HL,(FPREG)      ; Get first string
2746  1396 E3                   EX      (SP),HL         ; Save first string
2747  1397 CD 4B 0E             CALL    OPRND           ; Get second string
2748  139A E3                   EX      (SP),HL         ; Restore first string
2749  139B CD C6 0D             CALL    TSTSTR          ; Make sure it's a string
2750  139E 7E                   LD      A,(HL)          ; Get length of second string
2751  139F E5                   PUSH    HL              ; Save first string
2752  13A0 2A 29 21             LD      HL,(FPREG)      ; Get second string
2753  13A3 E5                   PUSH    HL              ; Save second string
2754  13A4 86                   ADD     A,(HL)          ; Add length of second string
2755  13A5 1E 1C                LD      E,LS            ; ?LS Error
2756  13A7 DA 11 05             JP      C,ERROR         ; String too long - Error
2757  13AA CD 4A 12             CALL    MKTMST          ; Make temporary string
2758  13AD D1                   POP     DE              ; Get second string to DE
2759  13AE CD E2 13             CALL    GSTRDE          ; Move to string pool if needed
2760  13B1 E3                   EX      (SP),HL         ; Get first string
2761  13B2 CD E1 13             CALL    GSTRHL          ; Move to string pool if needed
2762  13B5 E5                   PUSH    HL              ; Save first string
2763  13B6 2A 06 21             LD      HL,(TMPSTR+2)   ; Temporary string address
2764  13B9 EB                   EX      DE,HL           ; To DE
2765  13BA CD C8 13             CALL    SSTSA           ; First string to string area
2766  13BD CD C8 13             CALL    SSTSA           ; Second string to string area
2767  13C0 21 E0 0D             LD      HL,EVAL2        ; Return to evaluation loop
2768  13C3 E3                   EX      (SP),HL         ; Save return,get code string
2769  13C4 E5                   PUSH    HL              ; Save code string address
2770  13C5 C3 7B 12             JP      TSTOPL          ; To temporary string to pool
2771  13C8
2772  13C8 E1           SSTSA:  POP     HL              ; Return address
2773  13C9 E3                   EX      (SP),HL         ; Get string block,save return
2774  13CA 7E                   LD      A,(HL)          ; Get length of string
2775  13CB 23                   INC     HL
2776  13CC 23                   INC     HL
2777  13CD 4E                   LD      C,(HL)          ; Get LSB of string address
2778  13CE 23                   INC     HL
2779  13CF 46                   LD      B,(HL)          ; Get MSB of string address
2780  13D0 6F                   LD      L,A             ; Length to L
2781  13D1 2C           TOSTRA: INC     L               ; INC - DECed after
2782  13D2 2D           TSALP:  DEC     L               ; Count bytes moved
2783  13D3 C8                   RET     Z               ; End of string - Return
2784  13D4 0A                   LD      A,(BC)          ; Get source
2785  13D5 12                   LD      (DE),A          ; Save destination
2786  13D6 03                   INC     BC              ; Next source
2787  13D7 13                   INC     DE              ; Next destination
2788  13D8 C3 D2 13             JP      TSALP           ; Loop until string moved
2789  13DB
2790  13DB CD C6 0D     GETSTR: CALL    TSTSTR          ; Make sure it's a string
2791  13DE 2A 29 21     GSTRCU: LD      HL,(FPREG)      ; Get current string
2792  13E1 EB           GSTRHL: EX      DE,HL           ; Save DE
2793  13E2 CD FC 13     GSTRDE: CALL    BAKTMP          ; Was it last tmp-str?
2794  13E5 EB                   EX      DE,HL           ; Restore DE
2795  13E6 C0                   RET     NZ              ; No - Return
2796  13E7 D5                   PUSH    DE              ; Save string
2797  13E8 50                   LD      D,B             ; String block address to DE
2798  13E9 59                   LD      E,C
2799  13EA 1B                   DEC     DE              ; Point to length
2800  13EB 4E                   LD      C,(HL)          ; Get string length
2801  13EC 2A 08 21             LD      HL,(STRBOT)     ; Current bottom of string area
2802  13EF CD C5 07             CALL    CPDEHL          ; Last one in string area?
2803  13F2 C2 FA 13             JP      NZ,POPHL        ; No - Return
2804  13F5 47                   LD      B,A             ; Clear B (A=0)
2805  13F6 09                   ADD     HL,BC           ; Remove string from str' area
2806  13F7 22 08 21             LD      (STRBOT),HL     ; Save new bottom of str' area
2807  13FA E1           POPHL:  POP     HL              ; Restore string
2808  13FB C9                   RET
2809  13FC
2810  13FC 2A F6 20     BAKTMP: LD      HL,(TMSTPT)     ; Get temporary string pool top
2811  13FF 2B                   DEC     HL              ; Back
2812  1400 46                   LD      B,(HL)          ; Get MSB of address
2813  1401 2B                   DEC     HL              ; Back
2814  1402 4E                   LD      C,(HL)          ; Get LSB of address
2815  1403 2B                   DEC     HL              ; Back
2816  1404 2B                   DEC     HL              ; Back
2817  1405 CD C5 07             CALL    CPDEHL          ; String last in string pool?
2818  1408 C0                   RET     NZ              ; Yes - Leave it
2819  1409 22 F6 20             LD      (TMSTPT),HL     ; Save new string pool top
2820  140C C9                   RET
2821  140D
2822  140D 01 8C 11     LEN:    LD      BC,PASSA        ; To return integer A
2823  1410 C5                   PUSH    BC              ; Save address
2824  1411 CD DB 13     GETLEN: CALL    GETSTR          ; Get string and its length
2825  1414 AF                   XOR     A
2826  1415 57                   LD      D,A             ; Clear D
2827  1416 32 F2 20             LD      (TYPE),A        ; Set type to numeric
2828  1419 7E                   LD      A,(HL)          ; Get length of string
2829  141A B7                   OR      A               ; Set status flags
2830  141B C9                   RET
2831  141C
2832  141C 01 8C 11     ASC:    LD      BC,PASSA        ; To return integer A
2833  141F C5                   PUSH    BC              ; Save address
2834  1420 CD 11 14     GTFLNM: CALL    GETLEN          ; Get length of string
2835  1423 CA 1C 0A             JP      Z,FCERR         ; Null string - Error
2836  1426 23                   INC     HL
2837  1427 23                   INC     HL
2838  1428 5E                   LD      E,(HL)          ; Get LSB of address
2839  1429 23                   INC     HL
2840  142A 56                   LD      D,(HL)          ; Get MSB of address
2841  142B 1A                   LD      A,(DE)          ; Get first byte of string
2842  142C C9                   RET
2843  142D
2844  142D 3E 01        CHR:    LD      A,1             ; One character string
2845  142F CD 4A 12             CALL    MKTMST          ; Make a temporary string
2846  1432 CD 26 15             CALL    MAKINT          ; Make it integer A
2847  1435 2A 06 21             LD      HL,(TMPSTR+2)   ; Get address of string
2848  1438 73                   LD      (HL),E          ; Save character
2849  1439 C1           TOPOOL: POP     BC              ; Clean up stack
2850  143A C3 7B 12             JP      TSTOPL          ; Temporary string to pool
2851  143D
2852  143D CD D6 14     LEFT:   CALL    LFRGNM          ; Get number and ending ")"
2853  1440 AF                   XOR     A               ; Start at first byte in string
2854  1441 E3           RIGHT1: EX      (SP),HL         ; Save code string,Get string
2855  1442 4F                   LD      C,A             ; Starting position in string
2856  1443 E5           MID1:   PUSH    HL              ; Save string block address
2857  1444 7E                   LD      A,(HL)          ; Get length of string
2858  1445 B8                   CP      B               ; Compare with number given
2859  1446 DA 4B 14             JP      C,ALLFOL        ; All following bytes required
2860  1449 78                   LD      A,B             ; Get new length
2861  144A 11                   .BYTE      11H             ; Skip "LD C,0"
2862  144B 0E 00        ALLFOL: LD      C,0             ; First byte of string
2863  144D C5                   PUSH    BC              ; Save position in string
2864  144E CD B4 12             CALL    TESTR           ; See if enough string space
2865  1451 C1                   POP     BC              ; Get position in string
2866  1452 E1                   POP     HL              ; Restore string block address
2867  1453 E5                   PUSH    HL              ; And re-save it
2868  1454 23                   INC     HL
2869  1455 23                   INC     HL
2870  1456 46                   LD      B,(HL)          ; Get LSB of address
2871  1457 23                   INC     HL
2872  1458 66                   LD      H,(HL)          ; Get MSB of address
2873  1459 68                   LD      L,B             ; HL = address of string
2874  145A 06 00                LD      B,0             ; BC = starting address
2875  145C 09                   ADD     HL,BC           ; Point to that byte
2876  145D 44                   LD      B,H             ; BC = source string
2877  145E 4D                   LD      C,L
2878  145F CD 4D 12             CALL    CRTMST          ; Create a string entry
2879  1462 6F                   LD      L,A             ; Length of new string
2880  1463 CD D1 13             CALL    TOSTRA          ; Move string to string area
2881  1466 D1                   POP     DE              ; Clear stack
2882  1467 CD E2 13             CALL    GSTRDE          ; Move to string pool if needed
2883  146A C3 7B 12             JP      TSTOPL          ; Temporary string to pool
2884  146D
2885  146D CD D6 14     RIGHT:  CALL    LFRGNM          ; Get number and ending ")"
2886  1470 D1                   POP     DE              ; Get string length
2887  1471 D5                   PUSH    DE              ; And re-save
2888  1472 1A                   LD      A,(DE)          ; Get length
2889  1473 90                   SUB     B               ; Move back N bytes
2890  1474 C3 41 14             JP      RIGHT1          ; Go and get sub-string
2891  1477
2892  1477 EB           MID:    EX      DE,HL           ; Get code string address
2893  1478 7E                   LD      A,(HL)          ; Get next byte ',' or ")"
2894  1479 CD DB 14             CALL    MIDNUM          ; Get number supplied
2895  147C 04                   INC     B               ; Is it character zero?
2896  147D 05                   DEC     B
2897  147E CA 1C 0A             JP      Z,FCERR         ; Yes - Error
2898  1481 C5                   PUSH    BC              ; Save starting position
2899  1482 1E FF                LD      E,255           ; All of string
2900  1484 FE 29                CP      ')'             ; Any length given?
2901  1486 CA 90 14             JP      Z,RSTSTR        ; No - Rest of string
2902  1489 CD CB 07             CALL    CHKSYN          ; Make sure ',' follows
2903  148C 2C                   .BYTE      ','
2904  148D CD 23 15             CALL    GETINT          ; Get integer 0-255
2905  1490 CD CB 07     RSTSTR: CALL    CHKSYN          ; Make sure ")" follows
2906  1493 29                   .BYTE      ")"
2907  1494 F1                   POP     AF              ; Restore starting position
2908  1495 E3                   EX      (SP),HL         ; Get string,8ave code string
2909  1496 01 43 14             LD      BC,MID1         ; Continuation of MID$ routine
2910  1499 C5                   PUSH    BC              ; Save for return
2911  149A 3D                   DEC     A               ; Starting position-1
2912  149B BE                   CP      (HL)            ; Compare with length
2913  149C 06 00                LD      B,0             ; Zero bytes length
2914  149E D0                   RET     NC              ; Null string if start past end
2915  149F 4F                   LD      C,A             ; Save starting position-1
2916  14A0 7E                   LD      A,(HL)          ; Get length of string
2917  14A1 91                   SUB     C               ; Subtract start
2918  14A2 BB                   CP      E               ; Enough string for it?
2919  14A3 47                   LD      B,A             ; Save maximum length available
2920  14A4 D8                   RET     C               ; Truncate string if needed
2921  14A5 43                   LD      B,E             ; Set specified length
2922  14A6 C9                   RET                     ; Go and create string
2923  14A7
2924  14A7 CD 11 14     VAL:    CALL    GETLEN          ; Get length of string
2925  14AA CA C4 15             JP      Z,RESZER        ; Result zero
2926  14AD 5F                   LD      E,A             ; Save length
2927  14AE 23                   INC     HL
2928  14AF 23                   INC     HL
2929  14B0 7E                   LD      A,(HL)          ; Get LSB of address
2930  14B1 23                   INC     HL
2931  14B2 66                   LD      H,(HL)          ; Get MSB of address
2932  14B3 6F                   LD      L,A             ; HL = String address
2933  14B4 E5                   PUSH    HL              ; Save string address
2934  14B5 19                   ADD     HL,DE
2935  14B6 46                   LD      B,(HL)          ; Get end of string+1 byte
2936  14B7 72                   LD      (HL),D          ; Zero it to terminate
2937  14B8 E3                   EX      (SP),HL         ; Save string end,get start
2938  14B9 C5                   PUSH    BC              ; Save end+1 byte
2939  14BA 7E                   LD      A,(HL)          ; Get starting byte
2940  14BB FE 24            CP	'$'		; Hex number indicated? [function added]
2941  14BD C2 C5 14         JP	NZ,VAL1
2942  14C0 CD EF 1C         CALL	HEXTFP		; Convert Hex to FPREG
2943  14C3 18 0D            JR	VAL3
2944  14C5 FE 25        VAL1:	CP	'%'		; Binary number indicated? [function added]
2945  14C7 C2 CF 14         JP	NZ,VAL2
2946  14CA CD 5F 1D         CALL	BINTFP		; Convert Bin to FPREG
2947  14CD 18 03            JR	VAL3
2948  14CF CD AB 18     VAL2:   CALL    ASCTFP          ; Convert ASCII string to FP
2949  14D2 C1           VAL3:   POP     BC              ; Restore end+1 byte
2950  14D3 E1                   POP     HL              ; Restore end+1 address
2951  14D4 70                   LD      (HL),B          ; Put back original byte
2952  14D5 C9                   RET
2953  14D6
2954  14D6 EB           LFRGNM: EX      DE,HL           ; Code string address to HL
2955  14D7 CD CB 07             CALL    CHKSYN          ; Make sure ")" follows
2956  14DA 29                   .BYTE      ")"
2957  14DB C1           MIDNUM: POP     BC              ; Get return address
2958  14DC D1                   POP     DE              ; Get number supplied
2959  14DD C5                   PUSH    BC              ; Re-save return address
2960  14DE 43                   LD      B,E             ; Number to B
2961  14DF C9                   RET
2962  14E0
2963  14E0 CD 26 15     INP:    CALL    MAKINT          ; Make it integer A
2964  14E3 32 84 20             LD      (INPORT),A      ; Set input port
2965  14E6 CD 83 20             CALL    INPSUB          ; Get input from port
2966  14E9 C3 8C 11             JP      PASSA           ; Return integer A
2967  14EC
2968  14EC CD 10 15     POUT:   CALL    SETIO           ; Set up port number
2969  14EF C3 4B 20             JP      OUTSUB          ; Output data and return
2970  14F2
2971  14F2 CD 10 15     WAIT:   CALL    SETIO           ; Set up port number
2972  14F5 F5                   PUSH    AF              ; Save AND mask
2973  14F6 1E 00                LD      E,0             ; Assume zero if none given
2974  14F8 2B                   DEC     HL              ; DEC 'cos GETCHR INCs
2975  14F9 CD 55 09             CALL    GETCHR          ; Get next character
2976  14FC CA 06 15             JP      Z,NOXOR         ; No XOR byte given
2977  14FF CD CB 07             CALL    CHKSYN          ; Make sure ',' follows
2978  1502 2C                   .BYTE      ','
2979  1503 CD 23 15             CALL    GETINT          ; Get integer 0-255 to XOR with
2980  1506 C1           NOXOR:  POP     BC              ; Restore AND mask
2981  1507 CD 83 20     WAITLP: CALL    INPSUB          ; Get input
2982  150A AB                   XOR     E               ; Flip selected bits
2983  150B A0                   AND     B               ; Result non-zero?
2984  150C CA 07 15             JP      Z,WAITLP        ; No = keep waiting
2985  150F C9                   RET
2986  1510
2987  1510 CD 23 15     SETIO:  CALL    GETINT          ; Get integer 0-255
2988  1513 32 84 20             LD      (INPORT),A      ; Set input port
2989  1516 32 4C 20             LD      (OTPORT),A      ; Set output port
2990  1519 CD CB 07             CALL    CHKSYN          ; Make sure ',' follows
2991  151C 2C                   .BYTE      ','
2992  151D C3 23 15             JP      GETINT          ; Get integer 0-255 and return
2993  1520
2994  1520 CD 55 09     FNDNUM: CALL    GETCHR          ; Get next character
2995  1523 CD C2 0D     GETINT: CALL    GETNUM          ; Get a number from 0 to 255
2996  1526 CD 01 0A     MAKINT: CALL    DEPINT          ; Make sure value 0 - 255
2997  1529 7A                   LD      A,D             ; Get MSB of number
2998  152A B7                   OR      A               ; Zero?
2999  152B C2 1C 0A             JP      NZ,FCERR        ; No - Error
3000  152E 2B                   DEC     HL              ; DEC 'cos GETCHR INCs
3001  152F CD 55 09             CALL    GETCHR          ; Get next character
3002  1532 7B                   LD      A,E             ; Get number to A
3003  1533 C9                   RET
3004  1534
3005  1534 CD 07 0A     PEEK:   CALL    DEINT           ; Get memory address
3006  1537 1A                   LD      A,(DE)          ; Get byte in memory
3007  1538 C3 8C 11             JP      PASSA           ; Return integer A
3008  153B
3009  153B CD C2 0D     POKE:   CALL    GETNUM          ; Get memory address
3010  153E CD 07 0A             CALL    DEINT           ; Get integer -32768 to 3276
3011  1541 D5                   PUSH    DE              ; Save memory address
3012  1542 CD CB 07             CALL    CHKSYN          ; Make sure ',' follows
3013  1545 2C                   .BYTE      ','
3014  1546 CD 23 15             CALL    GETINT          ; Get integer 0-255
3015  1549 D1                   POP     DE              ; Restore memory address
3016  154A 12                   LD      (DE),A          ; Load it into memory
3017  154B C9                   RET
3018  154C
3019  154C 21 22 1A     ROUND:  LD      HL,HALF         ; Add 0.5 to FPREG
3020  154F CD F3 17     ADDPHL: CALL    LOADFP          ; Load FP at (HL) to BCDE
3021  1552 C3 5E 15             JP      FPADD           ; Add BCDE to FPREG
3022  1555
3023  1555 CD F3 17     SUBPHL: CALL    LOADFP          ; FPREG = -FPREG + number at HL
3024  1558 21                   .BYTE      21H             ; Skip "POP BC" and "POP DE"
3025  1559 C1           PSUB:   POP     BC              ; Get FP number from stack
3026  155A D1                   POP     DE
3027  155B CD CD 17     SUBCDE: CALL    INVSGN          ; Negate FPREG
3028  155E 78           FPADD:  LD      A,B             ; Get FP exponent
3029  155F B7                   OR      A               ; Is number zero?
3030  1560 C8                   RET     Z               ; Yes - Nothing to add
3031  1561 3A 2C 21             LD      A,(FPEXP)       ; Get FPREG exponent
3032  1564 B7                   OR      A               ; Is this number zero?
3033  1565 CA E5 17             JP      Z,FPBCDE        ; Yes - Move BCDE to FPREG
3034  1568 90                   SUB     B               ; BCDE number larger?
3035  1569 D2 78 15             JP      NC,NOSWAP       ; No - Don't swap them
3036  156C 2F                   CPL                     ; Two's complement
3037  156D 3C                   INC     A               ;  FP exponent
3038  156E EB                   EX      DE,HL
3039  156F CD D5 17             CALL    STAKFP          ; Put FPREG on stack
3040  1572 EB                   EX      DE,HL
3041  1573 CD E5 17             CALL    FPBCDE          ; Move BCDE to FPREG
3042  1576 C1                   POP     BC              ; Restore number from stack
3043  1577 D1                   POP     DE
3044  1578 FE 19        NOSWAP: CP      24+1            ; Second number insignificant?
3045  157A D0                   RET     NC              ; Yes - First number is result
3046  157B F5                   PUSH    AF              ; Save number of bits to scale
3047  157C CD 0A 18             CALL    SIGNS           ; Set MSBs & sign of result
3048  157F 67                   LD      H,A             ; Save sign of result
3049  1580 F1                   POP     AF              ; Restore scaling factor
3050  1581 CD 23 16             CALL    SCALE           ; Scale BCDE to same exponent
3051  1584 B4                   OR      H               ; Result to be positive?
3052  1585 21 29 21             LD      HL,FPREG        ; Point to FPREG
3053  1588 F2 9E 15             JP      P,MINCDE        ; No - Subtract FPREG from CDE
3054  158B CD 03 16             CALL    PLUCDE          ; Add FPREG to CDE
3055  158E D2 E4 15             JP      NC,RONDUP       ; No overflow - Round it up
3056  1591 23                   INC     HL              ; Point to exponent
3057  1592 34                   INC     (HL)            ; Increment it
3058  1593 CA 0C 05             JP      Z,OVERR         ; Number overflowed - Error
3059  1596 2E 01                LD      L,1             ; 1 bit to shift right
3060  1598 CD 39 16             CALL    SHRT1           ; Shift result right
3061  159B C3 E4 15             JP      RONDUP          ; Round it up
3062  159E
3063  159E AF           MINCDE: XOR     A               ; Clear A and carry
3064  159F 90                   SUB     B               ; Negate exponent
3065  15A0 47                   LD      B,A             ; Re-save exponent
3066  15A1 7E                   LD      A,(HL)          ; Get LSB of FPREG
3067  15A2 9B                   SBC     A, E            ; Subtract LSB of BCDE
3068  15A3 5F                   LD      E,A             ; Save LSB of BCDE
3069  15A4 23                   INC     HL
3070  15A5 7E                   LD      A,(HL)          ; Get NMSB of FPREG
3071  15A6 9A                   SBC     A,D             ; Subtract NMSB of BCDE
3072  15A7 57                   LD      D,A             ; Save NMSB of BCDE
3073  15A8 23                   INC     HL
3074  15A9 7E                   LD      A,(HL)          ; Get MSB of FPREG
3075  15AA 99                   SBC     A,C             ; Subtract MSB of BCDE
3076  15AB 4F                   LD      C,A             ; Save MSB of BCDE
3077  15AC DC 0F 16     CONPOS: CALL    C,COMPL         ; Overflow - Make it positive
3078  15AF
3079  15AF 68           BNORM:  LD      L,B             ; L = Exponent
3080  15B0 63                   LD      H,E             ; H = LSB
3081  15B1 AF                   XOR     A
3082  15B2 47           BNRMLP: LD      B,A             ; Save bit count
3083  15B3 79                   LD      A,C             ; Get MSB
3084  15B4 B7                   OR      A               ; Is it zero?
3085  15B5 C2 D1 15             JP      NZ,PNORM        ; No - Do it bit at a time
3086  15B8 4A                   LD      C,D             ; MSB = NMSB
3087  15B9 54                   LD      D,H             ; NMSB= LSB
3088  15BA 65                   LD      H,L             ; LSB = VLSB
3089  15BB 6F                   LD      L,A             ; VLSB= 0
3090  15BC 78                   LD      A,B             ; Get exponent
3091  15BD D6 08                SUB     8               ; Count 8 bits
3092  15BF FE E0                CP      -24-8           ; Was number zero?
3093  15C1 C2 B2 15             JP      NZ,BNRMLP       ; No - Keep normalising
3094  15C4 AF           RESZER: XOR     A               ; Result is zero
3095  15C5 32 2C 21     SAVEXP: LD      (FPEXP),A       ; Save result as zero
3096  15C8 C9                   RET
3097  15C9
3098  15C9 05           NORMAL: DEC     B               ; Count bits
3099  15CA 29                   ADD     HL,HL           ; Shift HL left
3100  15CB 7A                   LD      A,D             ; Get NMSB
3101  15CC 17                   RLA                     ; Shift left with last bit
3102  15CD 57                   LD      D,A             ; Save NMSB
3103  15CE 79                   LD      A,C             ; Get MSB
3104  15CF 8F                   ADC     A,A             ; Shift left with last bit
3105  15D0 4F                   LD      C,A             ; Save MSB
3106  15D1 F2 C9 15     PNORM:  JP      P,NORMAL        ; Not done - Keep going
3107  15D4 78                   LD      A,B             ; Number of bits shifted
3108  15D5 5C                   LD      E,H             ; Save HL in EB
3109  15D6 45                   LD      B,L
3110  15D7 B7                   OR      A               ; Any shifting done?
3111  15D8 CA E4 15             JP      Z,RONDUP        ; No - Round it up
3112  15DB 21 2C 21             LD      HL,FPEXP        ; Point to exponent
3113  15DE 86                   ADD     A,(HL)          ; Add shifted bits
3114  15DF 77                   LD      (HL),A          ; Re-save exponent
3115  15E0 D2 C4 15             JP      NC,RESZER       ; Underflow - Result is zero
3116  15E3 C8                   RET     Z               ; Result is zero
3117  15E4 78           RONDUP: LD      A,B             ; Get VLSB of number
3118  15E5 21 2C 21     RONDB:  LD      HL,FPEXP        ; Point to exponent
3119  15E8 B7                   OR      A               ; Any rounding?
3120  15E9 FC F6 15             CALL    M,FPROND        ; Yes - Round number up
3121  15EC 46                   LD      B,(HL)          ; B = Exponent
3122  15ED 23                   INC     HL
3123  15EE 7E                   LD      A,(HL)          ; Get sign of result
3124  15EF E6 80                AND     10000000B       ; Only bit 7 needed
3125  15F1 A9                   XOR     C               ; Set correct sign
3126  15F2 4F                   LD      C,A             ; Save correct sign in number
3127  15F3 C3 E5 17             JP      FPBCDE          ; Move BCDE to FPREG
3128  15F6
3129  15F6 1C           FPROND: INC     E               ; Round LSB
3130  15F7 C0                   RET     NZ              ; Return if ok
3131  15F8 14                   INC     D               ; Round NMSB
3132  15F9 C0                   RET     NZ              ; Return if ok
3133  15FA 0C                   INC     C               ; Round MSB
3134  15FB C0                   RET     NZ              ; Return if ok
3135  15FC 0E 80                LD      C,80H           ; Set normal value
3136  15FE 34                   INC     (HL)            ; Increment exponent
3137  15FF C0                   RET     NZ              ; Return if ok
3138  1600 C3 0C 05             JP      OVERR           ; Overflow error
3139  1603
3140  1603 7E           PLUCDE: LD      A,(HL)          ; Get LSB of FPREG
3141  1604 83                   ADD     A,E             ; Add LSB of BCDE
3142  1605 5F                   LD      E,A             ; Save LSB of BCDE
3143  1606 23                   INC     HL
3144  1607 7E                   LD      A,(HL)          ; Get NMSB of FPREG
3145  1608 8A                   ADC     A,D             ; Add NMSB of BCDE
3146  1609 57                   LD      D,A             ; Save NMSB of BCDE
3147  160A 23                   INC     HL
3148  160B 7E                   LD      A,(HL)          ; Get MSB of FPREG
3149  160C 89                   ADC     A,C             ; Add MSB of BCDE
3150  160D 4F                   LD      C,A             ; Save MSB of BCDE
3151  160E C9                   RET
3152  160F
3153  160F 21 2D 21     COMPL:  LD      HL,SGNRES       ; Sign of result
3154  1612 7E                   LD      A,(HL)          ; Get sign of result
3155  1613 2F                   CPL                     ; Negate it
3156  1614 77                   LD      (HL),A          ; Put it back
3157  1615 AF                   XOR     A
3158  1616 6F                   LD      L,A             ; Set L to zero
3159  1617 90                   SUB     B               ; Negate exponent,set carry
3160  1618 47                   LD      B,A             ; Re-save exponent
3161  1619 7D                   LD      A,L             ; Load zero
3162  161A 9B                   SBC     A,E             ; Negate LSB
3163  161B 5F                   LD      E,A             ; Re-save LSB
3164  161C 7D                   LD      A,L             ; Load zero
3165  161D 9A                   SBC     A,D             ; Negate NMSB
3166  161E 57                   LD      D,A             ; Re-save NMSB
3167  161F 7D                   LD      A,L             ; Load zero
3168  1620 99                   SBC     A,C             ; Negate MSB
3169  1621 4F                   LD      C,A             ; Re-save MSB
3170  1622 C9                   RET
3171  1623
3172  1623 06 00        SCALE:  LD      B,0             ; Clear underflow
3173  1625 D6 08        SCALLP: SUB     8               ; 8 bits (a whole byte)?
3174  1627 DA 32 16             JP      C,SHRITE        ; No - Shift right A bits
3175  162A 43                   LD      B,E             ; <- Shift
3176  162B 5A                   LD      E,D             ; <- right
3177  162C 51                   LD      D,C             ; <- eight
3178  162D 0E 00                LD      C,0             ; <- bits
3179  162F C3 25 16             JP      SCALLP          ; More bits to shift
3180  1632
3181  1632 C6 09        SHRITE: ADD     A,8+1           ; Adjust count
3182  1634 6F                   LD      L,A             ; Save bits to shift
3183  1635 AF           SHRLP:  XOR     A               ; Flag for all done
3184  1636 2D                   DEC     L               ; All shifting done?
3185  1637 C8                   RET     Z               ; Yes - Return
3186  1638 79                   LD      A,C             ; Get MSB
3187  1639 1F           SHRT1:  RRA                     ; Shift it right
3188  163A 4F                   LD      C,A             ; Re-save
3189  163B 7A                   LD      A,D             ; Get NMSB
3190  163C 1F                   RRA                     ; Shift right with last bit
3191  163D 57                   LD      D,A             ; Re-save it
3192  163E 7B                   LD      A,E             ; Get LSB
3193  163F 1F                   RRA                     ; Shift right with last bit
3194  1640 5F                   LD      E,A             ; Re-save it
3195  1641 78                   LD      A,B             ; Get underflow
3196  1642 1F                   RRA                     ; Shift right with last bit
3197  1643 47                   LD      B,A             ; Re-save underflow
3198  1644 C3 35 16             JP      SHRLP           ; More bits to do
3199  1647
3200  1647 00 00 00 81  UNITY:  .BYTE       000H,000H,000H,081H    ; 1.00000
3201  164B
3202  164B 03           LOGTAB: .BYTE      3                       ; Table used by LOG
3203  164C AA 56 19 80          .BYTE      0AAH,056H,019H,080H     ; 0.59898
3204  1650 F1 22 76 80          .BYTE      0F1H,022H,076H,080H     ; 0.96147
3205  1654 45 AA 38 82          .BYTE      045H,0AAH,038H,082H     ; 2.88539
3206  1658
3207  1658 CD A4 17     LOG:    CALL    TSTSGN          ; Test sign of value
3208  165B B7                   OR      A
3209  165C EA 1C 0A             JP      PE,FCERR        ; ?FC Error if <= zero
3210  165F 21 2C 21             LD      HL,FPEXP        ; Point to exponent
3211  1662 7E                   LD      A,(HL)          ; Get exponent
3212  1663 01 35 80             LD      BC,8035H        ; BCDE = SQR(1/2)
3213  1666 11 F3 04             LD      DE,04F3H
3214  1669 90                   SUB     B               ; Scale value to be < 1
3215  166A F5                   PUSH    AF              ; Save scale factor
3216  166B 70                   LD      (HL),B          ; Save new exponent
3217  166C D5                   PUSH    DE              ; Save SQR(1/2)
3218  166D C5                   PUSH    BC
3219  166E CD 5E 15             CALL    FPADD           ; Add SQR(1/2) to value
3220  1671 C1                   POP     BC              ; Restore SQR(1/2)
3221  1672 D1                   POP     DE
3222  1673 04                   INC     B               ; Make it SQR(2)
3223  1674 CD FA 16             CALL    DVBCDE          ; Divide by SQR(2)
3224  1677 21 47 16             LD      HL,UNITY        ; Point to 1.
3225  167A CD 55 15             CALL    SUBPHL          ; Subtract FPREG from 1
3226  167D 21 4B 16             LD      HL,LOGTAB       ; Coefficient table
3227  1680 CD EC 1A             CALL    SUMSER          ; Evaluate sum of series
3228  1683 01 80 80             LD      BC,8080H        ; BCDE = -0.5
3229  1686 11 00 00             LD      DE,0000H
3230  1689 CD 5E 15             CALL    FPADD           ; Subtract 0.5 from FPREG
3231  168C F1                   POP     AF              ; Restore scale factor
3232  168D CD 1F 19             CALL    RSCALE          ; Re-scale number
3233  1690 01 31 80     MULLN2: LD      BC,8031H        ; BCDE = Ln(2)
3234  1693 11 18 72             LD      DE,7218H
3235  1696 21                   .BYTE      21H             ; Skip "POP BC" and "POP DE"
3236  1697
3237  1697 C1           MULT:   POP     BC              ; Get number from stack
3238  1698 D1                   POP     DE
3239  1699 CD A4 17     FPMULT: CALL    TSTSGN          ; Test sign of FPREG
3240  169C C8                   RET     Z               ; Return zero if zero
3241  169D 2E 00                LD      L,0             ; Flag add exponents
3242  169F CD 62 17             CALL    ADDEXP          ; Add exponents
3243  16A2 79                   LD      A,C             ; Get MSB of multiplier
3244  16A3 32 3B 21             LD      (MULVAL),A      ; Save MSB of multiplier
3245  16A6 EB                   EX      DE,HL
3246  16A7 22 3C 21             LD      (MULVAL+1),HL   ; Save rest of multiplier
3247  16AA 01 00 00             LD      BC,0            ; Partial product (BCDE) = zero
3248  16AD 50                   LD      D,B
3249  16AE 58                   LD      E,B
3250  16AF 21 AF 15             LD      HL,BNORM        ; Address of normalise
3251  16B2 E5                   PUSH    HL              ; Save for return
3252  16B3 21 BB 16             LD      HL,MULT8        ; Address of 8 bit multiply
3253  16B6 E5                   PUSH    HL              ; Save for NMSB,MSB
3254  16B7 E5                   PUSH    HL              ;
3255  16B8 21 29 21             LD      HL,FPREG        ; Point to number
3256  16BB 7E           MULT8:  LD      A,(HL)          ; Get LSB of number
3257  16BC 23                   INC     HL              ; Point to NMSB
3258  16BD B7                   OR      A               ; Test LSB
3259  16BE CA E7 16             JP      Z,BYTSFT        ; Zero - shift to next byte
3260  16C1 E5                   PUSH    HL              ; Save address of number
3261  16C2 2E 08                LD      L,8             ; 8 bits to multiply by
3262  16C4 1F           MUL8LP: RRA                     ; Shift LSB right
3263  16C5 67                   LD      H,A             ; Save LSB
3264  16C6 79                   LD      A,C             ; Get MSB
3265  16C7 D2 D5 16             JP      NC,NOMADD       ; Bit was zero - Don't add
3266  16CA E5                   PUSH    HL              ; Save LSB and count
3267  16CB 2A 3C 21             LD      HL,(MULVAL+1)   ; Get LSB and NMSB
3268  16CE 19                   ADD     HL,DE           ; Add NMSB and LSB
3269  16CF EB                   EX      DE,HL           ; Leave sum in DE
3270  16D0 E1                   POP     HL              ; Restore MSB and count
3271  16D1 3A 3B 21             LD      A,(MULVAL)      ; Get MSB of multiplier
3272  16D4 89                   ADC     A,C             ; Add MSB
3273  16D5 1F           NOMADD: RRA                     ; Shift MSB right
3274  16D6 4F                   LD      C,A             ; Re-save MSB
3275  16D7 7A                   LD      A,D             ; Get NMSB
3276  16D8 1F                   RRA                     ; Shift NMSB right
3277  16D9 57                   LD      D,A             ; Re-save NMSB
3278  16DA 7B                   LD      A,E             ; Get LSB
3279  16DB 1F                   RRA                     ; Shift LSB right
3280  16DC 5F                   LD      E,A             ; Re-save LSB
3281  16DD 78                   LD      A,B             ; Get VLSB
3282  16DE 1F                   RRA                     ; Shift VLSB right
3283  16DF 47                   LD      B,A             ; Re-save VLSB
3284  16E0 2D                   DEC     L               ; Count bits multiplied
3285  16E1 7C                   LD      A,H             ; Get LSB of multiplier
3286  16E2 C2 C4 16             JP      NZ,MUL8LP       ; More - Do it
3287  16E5 E1           POPHRT: POP     HL              ; Restore address of number
3288  16E6 C9                   RET
3289  16E7
3290  16E7 43           BYTSFT: LD      B,E             ; Shift partial product left
3291  16E8 5A                   LD      E,D
3292  16E9 51                   LD      D,C
3293  16EA 4F                   LD      C,A
3294  16EB C9                   RET
3295  16EC
3296  16EC CD D5 17     DIV10:  CALL    STAKFP          ; Save FPREG on stack
3297  16EF 01 20 84             LD      BC,8420H        ; BCDE = 10.
3298  16F2 11 00 00             LD      DE,0000H
3299  16F5 CD E5 17             CALL    FPBCDE          ; Move 10 to FPREG
3300  16F8
3301  16F8 C1           DIV:    POP     BC              ; Get number from stack
3302  16F9 D1                   POP     DE
3303  16FA CD A4 17     DVBCDE: CALL    TSTSGN          ; Test sign of FPREG
3304  16FD CA 00 05             JP      Z,DZERR         ; Error if division by zero
3305  1700 2E FF                LD      L,-1            ; Flag subtract exponents
3306  1702 CD 62 17             CALL    ADDEXP          ; Subtract exponents
3307  1705 34                   INC     (HL)            ; Add 2 to exponent to adjust
3308  1706 34                   INC     (HL)
3309  1707 2B                   DEC     HL              ; Point to MSB
3310  1708 7E                   LD      A,(HL)          ; Get MSB of dividend
3311  1709 32 57 20             LD      (DIV3),A        ; Save for subtraction
3312  170C 2B                   DEC     HL
3313  170D 7E                   LD      A,(HL)          ; Get NMSB of dividend
3314  170E 32 53 20             LD      (DIV2),A        ; Save for subtraction
3315  1711 2B                   DEC     HL
3316  1712 7E                   LD      A,(HL)          ; Get MSB of dividend
3317  1713 32 4F 20             LD      (DIV1),A        ; Save for subtraction
3318  1716 41                   LD      B,C             ; Get MSB
3319  1717 EB                   EX      DE,HL           ; NMSB,LSB to HL
3320  1718 AF                   XOR     A
3321  1719 4F                   LD      C,A             ; Clear MSB of quotient
3322  171A 57                   LD      D,A             ; Clear NMSB of quotient
3323  171B 5F                   LD      E,A             ; Clear LSB of quotient
3324  171C 32 5A 20             LD      (DIV4),A        ; Clear overflow count
3325  171F E5           DIVLP:  PUSH    HL              ; Save divisor
3326  1720 C5                   PUSH    BC
3327  1721 7D                   LD      A,L             ; Get LSB of number
3328  1722 CD 4E 20             CALL    DIVSUP          ; Subt' divisor from dividend
3329  1725 DE 00                SBC     A,0             ; Count for overflows
3330  1727 3F                   CCF
3331  1728 D2 32 17             JP      NC,RESDIV       ; Restore divisor if borrow
3332  172B 32 5A 20             LD      (DIV4),A        ; Re-save overflow count
3333  172E F1                   POP     AF              ; Scrap divisor
3334  172F F1                   POP     AF
3335  1730 37                   SCF                     ; Set carry to
3336  1731 D2                   .BYTE      0D2H            ; Skip "POP BC" and "POP HL"
3337  1732
3338  1732 C1           RESDIV: POP     BC              ; Restore divisor
3339  1733 E1                   POP     HL
3340  1734 79                   LD      A,C             ; Get MSB of quotient
3341  1735 3C                   INC     A
3342  1736 3D                   DEC     A
3343  1737 1F                   RRA                     ; Bit 0 to bit 7
3344  1738 FA E5 15             JP      M,RONDB         ; Done - Normalise result
3345  173B 17                   RLA                     ; Restore carry
3346  173C 7B                   LD      A,E             ; Get LSB of quotient
3347  173D 17                   RLA                     ; Double it
3348  173E 5F                   LD      E,A             ; Put it back
3349  173F 7A                   LD      A,D             ; Get NMSB of quotient
3350  1740 17                   RLA                     ; Double it
3351  1741 57                   LD      D,A             ; Put it back
3352  1742 79                   LD      A,C             ; Get MSB of quotient
3353  1743 17                   RLA                     ; Double it
3354  1744 4F                   LD      C,A             ; Put it back
3355  1745 29                   ADD     HL,HL           ; Double NMSB,LSB of divisor
3356  1746 78                   LD      A,B             ; Get MSB of divisor
3357  1747 17                   RLA                     ; Double it
3358  1748 47                   LD      B,A             ; Put it back
3359  1749 3A 5A 20             LD      A,(DIV4)        ; Get VLSB of quotient
3360  174C 17                   RLA                     ; Double it
3361  174D 32 5A 20             LD      (DIV4),A        ; Put it back
3362  1750 79                   LD      A,C             ; Get MSB of quotient
3363  1751 B2                   OR      D               ; Merge NMSB
3364  1752 B3                   OR      E               ; Merge LSB
3365  1753 C2 1F 17             JP      NZ,DIVLP        ; Not done - Keep dividing
3366  1756 E5                   PUSH    HL              ; Save divisor
3367  1757 21 2C 21             LD      HL,FPEXP        ; Point to exponent
3368  175A 35                   DEC     (HL)            ; Divide by 2
3369  175B E1                   POP     HL              ; Restore divisor
3370  175C C2 1F 17             JP      NZ,DIVLP        ; Ok - Keep going
3371  175F C3 0C 05             JP      OVERR           ; Overflow error
3372  1762
3373  1762 78           ADDEXP: LD      A,B             ; Get exponent of dividend
3374  1763 B7                   OR      A               ; Test it
3375  1764 CA 86 17             JP      Z,OVTST3        ; Zero - Result zero
3376  1767 7D                   LD      A,L             ; Get add/subtract flag
3377  1768 21 2C 21             LD      HL,FPEXP        ; Point to exponent
3378  176B AE                   XOR     (HL)            ; Add or subtract it
3379  176C 80                   ADD     A,B             ; Add the other exponent
3380  176D 47                   LD      B,A             ; Save new exponent
3381  176E 1F                   RRA                     ; Test exponent for overflow
3382  176F A8                   XOR     B
3383  1770 78                   LD      A,B             ; Get exponent
3384  1771 F2 85 17             JP      P,OVTST2        ; Positive - Test for overflow
3385  1774 C6 80                ADD     A,80H           ; Add excess 128
3386  1776 77                   LD      (HL),A          ; Save new exponent
3387  1777 CA E5 16             JP      Z,POPHRT        ; Zero - Result zero
3388  177A CD 0A 18             CALL    SIGNS           ; Set MSBs and sign of result
3389  177D 77                   LD      (HL),A          ; Save new exponent
3390  177E 2B                   DEC     HL              ; Point to MSB
3391  177F C9                   RET
3392  1780
3393  1780 CD A4 17     OVTST1: CALL    TSTSGN          ; Test sign of FPREG
3394  1783 2F                   CPL                     ; Invert sign
3395  1784 E1                   POP     HL              ; Clean up stack
3396  1785 B7           OVTST2: OR      A               ; Test if new exponent zero
3397  1786 E1           OVTST3: POP     HL              ; Clear off return address
3398  1787 F2 C4 15             JP      P,RESZER        ; Result zero
3399  178A C3 0C 05             JP      OVERR           ; Overflow error
3400  178D
3401  178D CD F0 17     MLSP10: CALL    BCDEFP          ; Move FPREG to BCDE
3402  1790 78                   LD      A,B             ; Get exponent
3403  1791 B7                   OR      A               ; Is it zero?
3404  1792 C8                   RET     Z               ; Yes - Result is zero
3405  1793 C6 02                ADD     A,2             ; Multiply by 4
3406  1795 DA 0C 05             JP      C,OVERR         ; Overflow - ?OV Error
3407  1798 47                   LD      B,A             ; Re-save exponent
3408  1799 CD 5E 15             CALL    FPADD           ; Add BCDE to FPREG (Times 5)
3409  179C 21 2C 21             LD      HL,FPEXP        ; Point to exponent
3410  179F 34                   INC     (HL)            ; Double number (Times 10)
3411  17A0 C0                   RET     NZ              ; Ok - Return
3412  17A1 C3 0C 05             JP      OVERR           ; Overflow error
3413  17A4
3414  17A4 3A 2C 21     TSTSGN: LD      A,(FPEXP)       ; Get sign of FPREG
3415  17A7 B7                   OR      A
3416  17A8 C8                   RET     Z               ; RETurn if number is zero
3417  17A9 3A 2B 21             LD      A,(FPREG+2)     ; Get MSB of FPREG
3418  17AC FE                   .BYTE      0FEH            ; Test sign
3419  17AD 2F           RETREL: CPL                     ; Invert sign
3420  17AE 17                   RLA                     ; Sign bit to carry
3421  17AF 9F           FLGDIF: SBC     A,A             ; Carry to all bits of A
3422  17B0 C0                   RET     NZ              ; Return -1 if negative
3423  17B1 3C                   INC     A               ; Bump to +1
3424  17B2 C9                   RET                     ; Positive - Return +1
3425  17B3
3426  17B3 CD A4 17     SGN:    CALL    TSTSGN          ; Test sign of FPREG
3427  17B6 06 88        FLGREL: LD      B,80H+8         ; 8 bit integer in exponent
3428  17B8 11 00 00             LD      DE,0            ; Zero NMSB and LSB
3429  17BB 21 2C 21     RETINT: LD      HL,FPEXP        ; Point to exponent
3430  17BE 4F                   LD      C,A             ; CDE = MSB,NMSB and LSB
3431  17BF 70                   LD      (HL),B          ; Save exponent
3432  17C0 06 00                LD      B,0             ; CDE = integer to normalise
3433  17C2 23                   INC     HL              ; Point to sign of result
3434  17C3 36 80                LD      (HL),80H        ; Set sign of result
3435  17C5 17                   RLA                     ; Carry = sign of integer
3436  17C6 C3 AC 15             JP      CONPOS          ; Set sign of result
3437  17C9
3438  17C9 CD A4 17     ABS:    CALL    TSTSGN          ; Test sign of FPREG
3439  17CC F0                   RET     P               ; Return if positive
3440  17CD 21 2B 21     INVSGN: LD      HL,FPREG+2      ; Point to MSB
3441  17D0 7E                   LD      A,(HL)          ; Get sign of mantissa
3442  17D1 EE 80                XOR     80H             ; Invert sign of mantissa
3443  17D3 77                   LD      (HL),A          ; Re-save sign of mantissa
3444  17D4 C9                   RET
3445  17D5
3446  17D5 EB           STAKFP: EX      DE,HL           ; Save code string address
3447  17D6 2A 29 21             LD      HL,(FPREG)      ; LSB,NLSB of FPREG
3448  17D9 E3                   EX      (SP),HL         ; Stack them,get return
3449  17DA E5                   PUSH    HL              ; Re-save return
3450  17DB 2A 2B 21             LD      HL,(FPREG+2)    ; MSB and exponent of FPREG
3451  17DE E3                   EX      (SP),HL         ; Stack them,get return
3452  17DF E5                   PUSH    HL              ; Re-save return
3453  17E0 EB                   EX      DE,HL           ; Restore code string address
3454  17E1 C9                   RET
3455  17E2
3456  17E2 CD F3 17     PHLTFP: CALL    LOADFP          ; Number at HL to BCDE
3457  17E5 EB           FPBCDE: EX      DE,HL           ; Save code string address
3458  17E6 22 29 21             LD      (FPREG),HL      ; Save LSB,NLSB of number
3459  17E9 60                   LD      H,B             ; Exponent of number
3460  17EA 69                   LD      L,C             ; MSB of number
3461  17EB 22 2B 21             LD      (FPREG+2),HL    ; Save MSB and exponent
3462  17EE EB                   EX      DE,HL           ; Restore code string address
3463  17EF C9                   RET
3464  17F0
3465  17F0 21 29 21     BCDEFP: LD      HL,FPREG        ; Point to FPREG
3466  17F3 5E           LOADFP: LD      E,(HL)          ; Get LSB of number
3467  17F4 23                   INC     HL
3468  17F5 56                   LD      D,(HL)          ; Get NMSB of number
3469  17F6 23                   INC     HL
3470  17F7 4E                   LD      C,(HL)          ; Get MSB of number
3471  17F8 23                   INC     HL
3472  17F9 46                   LD      B,(HL)          ; Get exponent of number
3473  17FA 23           INCHL:  INC     HL              ; Used for conditional "INC HL"
3474  17FB C9                   RET
3475  17FC
3476  17FC 11 29 21     FPTHL:  LD      DE,FPREG        ; Point to FPREG
3477  17FF 06 04        DETHL4: LD      B,4             ; 4 bytes to move
3478  1801 1A           DETHLB: LD      A,(DE)          ; Get source
3479  1802 77                   LD      (HL),A          ; Save destination
3480  1803 13                   INC     DE              ; Next source
3481  1804 23                   INC     HL              ; Next destination
3482  1805 05                   DEC     B               ; Count bytes
3483  1806 C2 01 18             JP      NZ,DETHLB       ; Loop if more
3484  1809 C9                   RET
3485  180A
3486  180A 21 2B 21     SIGNS:  LD      HL,FPREG+2      ; Point to MSB of FPREG
3487  180D 7E                   LD      A,(HL)          ; Get MSB
3488  180E 07                   RLCA                    ; Old sign to carry
3489  180F 37                   SCF                     ; Set MSBit
3490  1810 1F                   RRA                     ; Set MSBit of MSB
3491  1811 77                   LD      (HL),A          ; Save new MSB
3492  1812 3F                   CCF                     ; Complement sign
3493  1813 1F                   RRA                     ; Old sign to carry
3494  1814 23                   INC     HL
3495  1815 23                   INC     HL
3496  1816 77                   LD      (HL),A          ; Set sign of result
3497  1817 79                   LD      A,C             ; Get MSB
3498  1818 07                   RLCA                    ; Old sign to carry
3499  1819 37                   SCF                     ; Set MSBit
3500  181A 1F                   RRA                     ; Set MSBit of MSB
3501  181B 4F                   LD      C,A             ; Save MSB
3502  181C 1F                   RRA
3503  181D AE                   XOR     (HL)            ; New sign of result
3504  181E C9                   RET
3505  181F
3506  181F 78           CMPNUM: LD      A,B             ; Get exponent of number
3507  1820 B7                   OR      A
3508  1821 CA A4 17             JP      Z,TSTSGN        ; Zero - Test sign of FPREG
3509  1824 21 AD 17             LD      HL,RETREL       ; Return relation routine
3510  1827 E5                   PUSH    HL              ; Save for return
3511  1828 CD A4 17             CALL    TSTSGN          ; Test sign of FPREG
3512  182B 79                   LD      A,C             ; Get MSB of number
3513  182C C8                   RET     Z               ; FPREG zero - Number's MSB
3514  182D 21 2B 21             LD      HL,FPREG+2      ; MSB of FPREG
3515  1830 AE                   XOR     (HL)            ; Combine signs
3516  1831 79                   LD      A,C             ; Get MSB of number
3517  1832 F8                   RET     M               ; Exit if signs different
3518  1833 CD 39 18             CALL    CMPFP           ; Compare FP numbers
3519  1836 1F                   RRA                     ; Get carry to sign
3520  1837 A9                   XOR     C               ; Combine with MSB of number
3521  1838 C9                   RET
3522  1839
3523  1839 23           CMPFP:  INC     HL              ; Point to exponent
3524  183A 78                   LD      A,B             ; Get exponent
3525  183B BE                   CP      (HL)            ; Compare exponents
3526  183C C0                   RET     NZ              ; Different
3527  183D 2B                   DEC     HL              ; Point to MBS
3528  183E 79                   LD      A,C             ; Get MSB
3529  183F BE                   CP      (HL)            ; Compare MSBs
3530  1840 C0                   RET     NZ              ; Different
3531  1841 2B                   DEC     HL              ; Point to NMSB
3532  1842 7A                   LD      A,D             ; Get NMSB
3533  1843 BE                   CP      (HL)            ; Compare NMSBs
3534  1844 C0                   RET     NZ              ; Different
3535  1845 2B                   DEC     HL              ; Point to LSB
3536  1846 7B                   LD      A,E             ; Get LSB
3537  1847 96                   SUB     (HL)            ; Compare LSBs
3538  1848 C0                   RET     NZ              ; Different
3539  1849 E1                   POP     HL              ; Drop RETurn
3540  184A E1                   POP     HL              ; Drop another RETurn
3541  184B C9                   RET
3542  184C
3543  184C 47           FPINT:  LD      B,A             ; <- Move
3544  184D 4F                   LD      C,A             ; <- exponent
3545  184E 57                   LD      D,A             ; <- to all
3546  184F 5F                   LD      E,A             ; <- bits
3547  1850 B7                   OR      A               ; Test exponent
3548  1851 C8                   RET     Z               ; Zero - Return zero
3549  1852 E5                   PUSH    HL              ; Save pointer to number
3550  1853 CD F0 17             CALL    BCDEFP          ; Move FPREG to BCDE
3551  1856 CD 0A 18             CALL    SIGNS           ; Set MSBs & sign of result
3552  1859 AE                   XOR     (HL)            ; Combine with sign of FPREG
3553  185A 67                   LD      H,A             ; Save combined signs
3554  185B FC 70 18             CALL    M,DCBCDE        ; Negative - Decrement BCDE
3555  185E 3E 98                LD      A,80H+24        ; 24 bits
3556  1860 90                   SUB     B               ; Bits to shift
3557  1861 CD 23 16             CALL    SCALE           ; Shift BCDE
3558  1864 7C                   LD      A,H             ; Get combined sign
3559  1865 17                   RLA                     ; Sign to carry
3560  1866 DC F6 15             CALL    C,FPROND        ; Negative - Round number up
3561  1869 06 00                LD      B,0             ; Zero exponent
3562  186B DC 0F 16             CALL    C,COMPL         ; If negative make positive
3563  186E E1                   POP     HL              ; Restore pointer to number
3564  186F C9                   RET
3565  1870
3566  1870 1B           DCBCDE: DEC     DE              ; Decrement BCDE
3567  1871 7A                   LD      A,D             ; Test LSBs
3568  1872 A3                   AND     E
3569  1873 3C                   INC     A
3570  1874 C0                   RET     NZ              ; Exit if LSBs not FFFF
3571  1875 0B                   DEC     BC              ; Decrement MSBs
3572  1876 C9                   RET
3573  1877
3574  1877 21 2C 21     INT:    LD      HL,FPEXP        ; Point to exponent
3575  187A 7E                   LD      A,(HL)          ; Get exponent
3576  187B FE 98                CP      80H+24          ; Integer accuracy only?
3577  187D 3A 29 21             LD      A,(FPREG)       ; Get LSB
3578  1880 D0                   RET     NC              ; Yes - Already integer
3579  1881 7E                   LD      A,(HL)          ; Get exponent
3580  1882 CD 4C 18             CALL    FPINT           ; F.P to integer
3581  1885 36 98                LD      (HL),80H+24     ; Save 24 bit integer
3582  1887 7B                   LD      A,E             ; Get LSB of number
3583  1888 F5                   PUSH    AF              ; Save LSB
3584  1889 79                   LD      A,C             ; Get MSB of number
3585  188A 17                   RLA                     ; Sign to carry
3586  188B CD AC 15             CALL    CONPOS          ; Set sign of result
3587  188E F1                   POP     AF              ; Restore LSB of number
3588  188F C9                   RET
3589  1890
3590  1890 21 00 00     MLDEBC: LD      HL,0            ; Clear partial product
3591  1893 78                   LD      A,B             ; Test multiplier
3592  1894 B1                   OR      C
3593  1895 C8                   RET     Z               ; Return zero if zero
3594  1896 3E 10                LD      A,16            ; 16 bits
3595  1898 29           MLDBLP: ADD     HL,HL           ; Shift P.P left
3596  1899 DA D0 10             JP      C,BSERR         ; ?BS Error if overflow
3597  189C EB                   EX      DE,HL
3598  189D 29                   ADD     HL,HL           ; Shift multiplier left
3599  189E EB                   EX      DE,HL
3600  189F D2 A6 18             JP      NC,NOMLAD       ; Bit was zero - No add
3601  18A2 09                   ADD     HL,BC           ; Add multiplicand
3602  18A3 DA D0 10             JP      C,BSERR         ; ?BS Error if overflow
3603  18A6 3D           NOMLAD: DEC     A               ; Count bits
3604  18A7 C2 98 18             JP      NZ,MLDBLP       ; More
3605  18AA C9                   RET
3606  18AB
3607  18AB FE 2D        ASCTFP: CP      '-'             ; Negative?
3608  18AD F5                   PUSH    AF              ; Save it and flags
3609  18AE CA B7 18             JP      Z,CNVNUM        ; Yes - Convert number
3610  18B1 FE 2B                CP      '+'             ; Positive?
3611  18B3 CA B7 18             JP      Z,CNVNUM        ; Yes - Convert number
3612  18B6 2B                   DEC     HL              ; DEC 'cos GETCHR INCs
3613  18B7 CD C4 15     CNVNUM: CALL    RESZER          ; Set result to zero
3614  18BA 47                   LD      B,A             ; Digits after point counter
3615  18BB 57                   LD      D,A             ; Sign of exponent
3616  18BC 5F                   LD      E,A             ; Exponent of ten
3617  18BD 2F                   CPL
3618  18BE 4F                   LD      C,A             ; Before or after point flag
3619  18BF CD 55 09     MANLP:  CALL    GETCHR          ; Get next character
3620  18C2 DA 08 19             JP      C,ADDIG         ; Digit - Add to number
3621  18C5 FE 2E                CP      '.'
3622  18C7 CA E3 18             JP      Z,DPOINT        ; '.' - Flag point
3623  18CA FE 45                CP      'E'
3624  18CC C2 E7 18             JP      NZ,CONEXP       ; Not 'E' - Scale number
3625  18CF CD 55 09             CALL    GETCHR          ; Get next character
3626  18D2 CD FB 0E             CALL    SGNEXP          ; Get sign of exponent
3627  18D5 CD 55 09     EXPLP:  CALL    GETCHR          ; Get next character
3628  18D8 DA 2A 19             JP      C,EDIGIT        ; Digit - Add to exponent
3629  18DB 14                   INC     D               ; Is sign negative?
3630  18DC C2 E7 18             JP      NZ,CONEXP       ; No - Scale number
3631  18DF AF                   XOR     A
3632  18E0 93                   SUB     E               ; Negate exponent
3633  18E1 5F                   LD      E,A             ; And re-save it
3634  18E2 0C                   INC     C               ; Flag end of number
3635  18E3 0C           DPOINT: INC     C               ; Flag point passed
3636  18E4 CA BF 18             JP      Z,MANLP         ; Zero - Get another digit
3637  18E7 E5           CONEXP: PUSH    HL              ; Save code string address
3638  18E8 7B                   LD      A,E             ; Get exponent
3639  18E9 90                   SUB     B               ; Subtract digits after point
3640  18EA F4 00 19     SCALMI: CALL    P,SCALPL        ; Positive - Multiply number
3641  18ED F2 F6 18             JP      P,ENDCON        ; Positive - All done
3642  18F0 F5                   PUSH    AF              ; Save number of times to /10
3643  18F1 CD EC 16             CALL    DIV10           ; Divide by 10
3644  18F4 F1                   POP     AF              ; Restore count
3645  18F5 3C                   INC     A               ; Count divides
3646  18F6
3647  18F6 C2 EA 18     ENDCON: JP      NZ,SCALMI       ; More to do
3648  18F9 D1                   POP     DE              ; Restore code string address
3649  18FA F1                   POP     AF              ; Restore sign of number
3650  18FB CC CD 17             CALL    Z,INVSGN        ; Negative - Negate number
3651  18FE EB                   EX      DE,HL           ; Code string address to HL
3652  18FF C9                   RET
3653  1900
3654  1900 C8           SCALPL: RET     Z               ; Exit if no scaling needed
3655  1901 F5           MULTEN: PUSH    AF              ; Save count
3656  1902 CD 8D 17             CALL    MLSP10          ; Multiply number by 10
3657  1905 F1                   POP     AF              ; Restore count
3658  1906 3D                   DEC     A               ; Count multiplies
3659  1907 C9                   RET
3660  1908
3661  1908 D5           ADDIG:  PUSH    DE              ; Save sign of exponent
3662  1909 57                   LD      D,A             ; Save digit
3663  190A 78                   LD      A,B             ; Get digits after point
3664  190B 89                   ADC     A,C             ; Add one if after point
3665  190C 47                   LD      B,A             ; Re-save counter
3666  190D C5                   PUSH    BC              ; Save point flags
3667  190E E5                   PUSH    HL              ; Save code string address
3668  190F D5                   PUSH    DE              ; Save digit
3669  1910 CD 8D 17             CALL    MLSP10          ; Multiply number by 10
3670  1913 F1                   POP     AF              ; Restore digit
3671  1914 D6 30                SUB     '0'             ; Make it absolute
3672  1916 CD 1F 19             CALL    RSCALE          ; Re-scale number
3673  1919 E1                   POP     HL              ; Restore code string address
3674  191A C1                   POP     BC              ; Restore point flags
3675  191B D1                   POP     DE              ; Restore sign of exponent
3676  191C C3 BF 18             JP      MANLP           ; Get another digit
3677  191F
3678  191F CD D5 17     RSCALE: CALL    STAKFP          ; Put number on stack
3679  1922 CD B6 17             CALL    FLGREL          ; Digit to add to FPREG
3680  1925 C1           PADD:   POP     BC              ; Restore number
3681  1926 D1                   POP     DE
3682  1927 C3 5E 15             JP      FPADD           ; Add BCDE to FPREG and return
3683  192A
3684  192A 7B           EDIGIT: LD      A,E             ; Get digit
3685  192B 07                   RLCA                    ; Times 2
3686  192C 07                   RLCA                    ; Times 4
3687  192D 83                   ADD     A,E             ; Times 5
3688  192E 07                   RLCA                    ; Times 10
3689  192F 86                   ADD     A,(HL)          ; Add next digit
3690  1930 D6 30                SUB     '0'             ; Make it absolute
3691  1932 5F                   LD      E,A             ; Save new digit
3692  1933 C3 D5 18             JP      EXPLP           ; Look for another digit
3693  1936
3694  1936 E5           LINEIN: PUSH    HL              ; Save code string address
3695  1937 21 95 04             LD      HL,INMSG        ; Output " in "
3696  193A CD 9B 12             CALL    PRS             ; Output string at HL
3697  193D E1                   POP     HL              ; Restore code string address
3698  193E EB           PRNTHL: EX      DE,HL           ; Code string address to DE
3699  193F AF                   XOR     A
3700  1940 06 98                LD      B,80H+24        ; 24 bits
3701  1942 CD BB 17             CALL    RETINT          ; Return the integer
3702  1945 21 9A 12             LD      HL,PRNUMS       ; Print number string
3703  1948 E5                   PUSH    HL              ; Save for return
3704  1949 21 2E 21     NUMASC: LD      HL,PBUFF        ; Convert number to ASCII
3705  194C E5                   PUSH    HL              ; Save for return
3706  194D CD A4 17             CALL    TSTSGN          ; Test sign of FPREG
3707  1950 36 20                LD      (HL),' '        ; Space at start
3708  1952 F2 57 19             JP      P,SPCFST        ; Positive - Space to start
3709  1955 36 2D                LD      (HL),'-'        ; '-' sign at start
3710  1957 23           SPCFST: INC     HL              ; First byte of number
3711  1958 36 30                LD      (HL),'0'        ; '0' if zero
3712  195A CA 0D 1A             JP      Z,JSTZER        ; Return '0' if zero
3713  195D E5                   PUSH    HL              ; Save buffer address
3714  195E FC CD 17             CALL    M,INVSGN        ; Negate FPREG if negative
3715  1961 AF                   XOR     A               ; Zero A
3716  1962 F5                   PUSH    AF              ; Save it
3717  1963 CD 13 1A             CALL    RNGTST          ; Test number is in range
3718  1966 01 43 91     SIXDIG: LD      BC,9143H        ; BCDE - 99999.9
3719  1969 11 F8 4F             LD      DE,4FF8H
3720  196C CD 1F 18             CALL    CMPNUM          ; Compare numbers
3721  196F B7                   OR      A
3722  1970 E2 84 19             JP      PO,INRNG        ; > 99999.9 - Sort it out
3723  1973 F1                   POP     AF              ; Restore count
3724  1974 CD 01 19             CALL    MULTEN          ; Multiply by ten
3725  1977 F5                   PUSH    AF              ; Re-save count
3726  1978 C3 66 19             JP      SIXDIG          ; Test it again
3727  197B
3728  197B CD EC 16     GTSIXD: CALL    DIV10           ; Divide by 10
3729  197E F1                   POP     AF              ; Get count
3730  197F 3C                   INC     A               ; Count divides
3731  1980 F5                   PUSH    AF              ; Re-save count
3732  1981 CD 13 1A             CALL    RNGTST          ; Test number is in range
3733  1984 CD 4C 15     INRNG:  CALL    ROUND           ; Add 0.5 to FPREG
3734  1987 3C                   INC     A
3735  1988 CD 4C 18             CALL    FPINT           ; F.P to integer
3736  198B CD E5 17             CALL    FPBCDE          ; Move BCDE to FPREG
3737  198E 01 06 03             LD      BC,0306H        ; 1E+06 to 1E-03 range
3738  1991 F1                   POP     AF              ; Restore count
3739  1992 81                   ADD     A,C             ; 6 digits before point
3740  1993 3C                   INC     A               ; Add one
3741  1994 FA A0 19             JP      M,MAKNUM        ; Do it in 'E' form if < 1E-02
3742  1997 FE 08                CP      6+1+1           ; More than 999999 ?
3743  1999 D2 A0 19             JP      NC,MAKNUM       ; Yes - Do it in 'E' form
3744  199C 3C                   INC     A               ; Adjust for exponent
3745  199D 47                   LD      B,A             ; Exponent of number
3746  199E 3E 02                LD      A,2             ; Make it zero after
3747  19A0
3748  19A0 3D           MAKNUM: DEC     A               ; Adjust for digits to do
3749  19A1 3D                   DEC     A
3750  19A2 E1                   POP     HL              ; Restore buffer address
3751  19A3 F5                   PUSH    AF              ; Save count
3752  19A4 11 26 1A             LD      DE,POWERS       ; Powers of ten
3753  19A7 05                   DEC     B               ; Count digits before point
3754  19A8 C2 B1 19             JP      NZ,DIGTXT       ; Not zero - Do number
3755  19AB 36 2E                LD      (HL),'.'        ; Save point
3756  19AD 23                   INC     HL              ; Move on
3757  19AE 36 30                LD      (HL),'0'        ; Save zero
3758  19B0 23                   INC     HL              ; Move on
3759  19B1 05           DIGTXT: DEC     B               ; Count digits before point
3760  19B2 36 2E                LD      (HL),'.'        ; Save point in case
3761  19B4 CC FA 17             CALL    Z,INCHL         ; Last digit - move on
3762  19B7 C5                   PUSH    BC              ; Save digits before point
3763  19B8 E5                   PUSH    HL              ; Save buffer address
3764  19B9 D5                   PUSH    DE              ; Save powers of ten
3765  19BA CD F0 17             CALL    BCDEFP          ; Move FPREG to BCDE
3766  19BD E1                   POP     HL              ; Powers of ten table
3767  19BE 06 2F                LD      B, '0'-1        ; ASCII '0' - 1
3768  19C0 04           TRYAGN: INC     B               ; Count subtractions
3769  19C1 7B                   LD      A,E             ; Get LSB
3770  19C2 96                   SUB     (HL)            ; Subtract LSB
3771  19C3 5F                   LD      E,A             ; Save LSB
3772  19C4 23                   INC     HL
3773  19C5 7A                   LD      A,D             ; Get NMSB
3774  19C6 9E                   SBC     A,(HL)          ; Subtract NMSB
3775  19C7 57                   LD      D,A             ; Save NMSB
3776  19C8 23                   INC     HL
3777  19C9 79                   LD      A,C             ; Get MSB
3778  19CA 9E                   SBC     A,(HL)          ; Subtract MSB
3779  19CB 4F                   LD      C,A             ; Save MSB
3780  19CC 2B                   DEC     HL              ; Point back to start
3781  19CD 2B                   DEC     HL
3782  19CE D2 C0 19             JP      NC,TRYAGN       ; No overflow - Try again
3783  19D1 CD 03 16             CALL    PLUCDE          ; Restore number
3784  19D4 23                   INC     HL              ; Start of next number
3785  19D5 CD E5 17             CALL    FPBCDE          ; Move BCDE to FPREG
3786  19D8 EB                   EX      DE,HL           ; Save point in table
3787  19D9 E1                   POP     HL              ; Restore buffer address
3788  19DA 70                   LD      (HL),B          ; Save digit in buffer
3789  19DB 23                   INC     HL              ; And move on
3790  19DC C1                   POP     BC              ; Restore digit count
3791  19DD 0D                   DEC     C               ; Count digits
3792  19DE C2 B1 19             JP      NZ,DIGTXT       ; More - Do them
3793  19E1 05                   DEC     B               ; Any decimal part?
3794  19E2 CA F1 19             JP      Z,DOEBIT        ; No - Do 'E' bit
3795  19E5 2B           SUPTLZ: DEC     HL              ; Move back through buffer
3796  19E6 7E                   LD      A,(HL)          ; Get character
3797  19E7 FE 30                CP      '0'             ; '0' character?
3798  19E9 CA E5 19             JP      Z,SUPTLZ        ; Yes - Look back for more
3799  19EC FE 2E                CP      '.'             ; A decimal point?
3800  19EE C4 FA 17             CALL    NZ,INCHL        ; Move back over digit
3801  19F1
3802  19F1 F1           DOEBIT: POP     AF              ; Get 'E' flag
3803  19F2 CA 10 1A             JP      Z,NOENED        ; No 'E' needed - End buffer
3804  19F5 36 45                LD      (HL),'E'        ; Put 'E' in buffer
3805  19F7 23                   INC     HL              ; And move on
3806  19F8 36 2B                LD      (HL),'+'        ; Put '+' in buffer
3807  19FA F2 01 1A             JP      P,OUTEXP        ; Positive - Output exponent
3808  19FD 36 2D                LD      (HL),'-'        ; Put '-' in buffer
3809  19FF 2F                   CPL                     ; Negate exponent
3810  1A00 3C                   INC     A
3811  1A01 06 2F        OUTEXP: LD      B,'0'-1         ; ASCII '0' - 1
3812  1A03 04           EXPTEN: INC     B               ; Count subtractions
3813  1A04 D6 0A                SUB     10              ; Tens digit
3814  1A06 D2 03 1A             JP      NC,EXPTEN       ; More to do
3815  1A09 C6 3A                ADD     A,'0'+10        ; Restore and make ASCII
3816  1A0B 23                   INC     HL              ; Move on
3817  1A0C 70                   LD      (HL),B          ; Save MSB of exponent
3818  1A0D 23           JSTZER: INC     HL              ;
3819  1A0E 77                   LD      (HL),A          ; Save LSB of exponent
3820  1A0F 23                   INC     HL
3821  1A10 71           NOENED: LD      (HL),C          ; Mark end of buffer
3822  1A11 E1                   POP     HL              ; Restore code string address
3823  1A12 C9                   RET
3824  1A13
3825  1A13 01 74 94     RNGTST: LD      BC,9474H        ; BCDE = 999999.
3826  1A16 11 F7 23             LD      DE,23F7H
3827  1A19 CD 1F 18             CALL    CMPNUM          ; Compare numbers
3828  1A1C B7                   OR      A
3829  1A1D E1                   POP     HL              ; Return address to HL
3830  1A1E E2 7B 19             JP      PO,GTSIXD       ; Too big - Divide by ten
3831  1A21 E9                   JP      (HL)            ; Otherwise return to caller
3832  1A22
3833  1A22 00 00 00 80  HALF:   .BYTE      00H,00H,00H,80H ; 0.5
3834  1A26
3835  1A26 A0 86 01     POWERS: .BYTE      0A0H,086H,001H  ; 100000
3836  1A29 10 27 00             .BYTE      010H,027H,000H  ;  10000
3837  1A2C E8 03 00             .BYTE      0E8H,003H,000H  ;   1000
3838  1A2F 64 00 00             .BYTE      064H,000H,000H  ;    100
3839  1A32 0A 00 00             .BYTE      00AH,000H,000H  ;     10
3840  1A35 01 00 00             .BYTE      001H,000H,000H  ;      1
3841  1A38
3842  1A38 21 CD 17     NEGAFT: LD  HL,INVSGN           ; Negate result
3843  1A3B E3                   EX      (SP),HL         ; To be done after caller
3844  1A3C E9                   JP      (HL)            ; Return to caller
3845  1A3D
3846  1A3D CD D5 17     SQR:    CALL    STAKFP          ; Put value on stack
3847  1A40 21 22 1A             LD      HL,HALF         ; Set power to 1/2
3848  1A43 CD E2 17             CALL    PHLTFP          ; Move 1/2 to FPREG
3849  1A46
3850  1A46 C1           POWER:  POP     BC              ; Get base
3851  1A47 D1                   POP     DE
3852  1A48 CD A4 17             CALL    TSTSGN          ; Test sign of power
3853  1A4B 78                   LD      A,B             ; Get exponent of base
3854  1A4C CA 8B 1A             JP      Z,EXP           ; Make result 1 if zero
3855  1A4F F2 56 1A             JP      P,POWER1        ; Positive base - Ok
3856  1A52 B7                   OR      A               ; Zero to negative power?
3857  1A53 CA 00 05             JP      Z,DZERR         ; Yes - ?/0 Error
3858  1A56 B7           POWER1: OR      A               ; Base zero?
3859  1A57 CA C5 15             JP      Z,SAVEXP        ; Yes - Return zero
3860  1A5A D5                   PUSH    DE              ; Save base
3861  1A5B C5                   PUSH    BC
3862  1A5C 79                   LD      A,C             ; Get MSB of base
3863  1A5D F6 7F                OR      01111111B       ; Get sign status
3864  1A5F CD F0 17             CALL    BCDEFP          ; Move power to BCDE
3865  1A62 F2 73 1A             JP      P,POWER2        ; Positive base - Ok
3866  1A65 D5                   PUSH    DE              ; Save power
3867  1A66 C5                   PUSH    BC
3868  1A67 CD 77 18             CALL    INT             ; Get integer of power
3869  1A6A C1                   POP     BC              ; Restore power
3870  1A6B D1                   POP     DE
3871  1A6C F5                   PUSH    AF              ; MSB of base
3872  1A6D CD 1F 18             CALL    CMPNUM          ; Power an integer?
3873  1A70 E1                   POP     HL              ; Restore MSB of base
3874  1A71 7C                   LD      A,H             ; but don't affect flags
3875  1A72 1F                   RRA                     ; Exponent odd or even?
3876  1A73 E1           POWER2: POP     HL              ; Restore MSB and exponent
3877  1A74 22 2B 21             LD      (FPREG+2),HL    ; Save base in FPREG
3878  1A77 E1                   POP     HL              ; LSBs of base
3879  1A78 22 29 21             LD      (FPREG),HL      ; Save in FPREG
3880  1A7B DC 38 1A             CALL    C,NEGAFT        ; Odd power - Negate result
3881  1A7E CC CD 17             CALL    Z,INVSGN        ; Negative base - Negate it
3882  1A81 D5                   PUSH    DE              ; Save power
3883  1A82 C5                   PUSH    BC
3884  1A83 CD 58 16             CALL    LOG             ; Get LOG of base
3885  1A86 C1                   POP     BC              ; Restore power
3886  1A87 D1                   POP     DE
3887  1A88 CD 99 16             CALL    FPMULT          ; Multiply LOG by power
3888  1A8B
3889  1A8B CD D5 17     EXP:    CALL    STAKFP          ; Put value on stack
3890  1A8E 01 38 81             LD      BC,08138H       ; BCDE = 1/Ln(2)
3891  1A91 11 3B AA             LD      DE,0AA3BH
3892  1A94 CD 99 16             CALL    FPMULT          ; Multiply value by 1/LN(2)
3893  1A97 3A 2C 21             LD      A,(FPEXP)       ; Get exponent
3894  1A9A FE 88                CP      80H+8           ; Is it in range?
3895  1A9C D2 80 17             JP      NC,OVTST1       ; No - Test for overflow
3896  1A9F CD 77 18             CALL    INT             ; Get INT of FPREG
3897  1AA2 C6 80                ADD     A,80H           ; For excess 128
3898  1AA4 C6 02                ADD     A,2             ; Exponent > 126?
3899  1AA6 DA 80 17             JP      C,OVTST1        ; Yes - Test for overflow
3900  1AA9 F5                   PUSH    AF              ; Save scaling factor
3901  1AAA 21 47 16             LD      HL,UNITY        ; Point to 1.
3902  1AAD CD 4F 15             CALL    ADDPHL          ; Add 1 to FPREG
3903  1AB0 CD 90 16             CALL    MULLN2          ; Multiply by LN(2)
3904  1AB3 F1                   POP     AF              ; Restore scaling factor
3905  1AB4 C1                   POP     BC              ; Restore exponent
3906  1AB5 D1                   POP     DE
3907  1AB6 F5                   PUSH    AF              ; Save scaling factor
3908  1AB7 CD 5B 15             CALL    SUBCDE          ; Subtract exponent from FPREG
3909  1ABA CD CD 17             CALL    INVSGN          ; Negate result
3910  1ABD 21 CB 1A             LD      HL,EXPTAB       ; Coefficient table
3911  1AC0 CD FB 1A             CALL    SMSER1          ; Sum the series
3912  1AC3 11 00 00             LD      DE,0            ; Zero LSBs
3913  1AC6 C1                   POP     BC              ; Scaling factor
3914  1AC7 4A                   LD      C,D             ; Zero MSB
3915  1AC8 C3 99 16             JP      FPMULT          ; Scale result to correct value
3916  1ACB
3917  1ACB 08           EXPTAB: .BYTE      8                       ; Table used by EXP
3918  1ACC 40 2E 94 74          .BYTE      040H,02EH,094H,074H     ; -1/7! (-1/5040)
3919  1AD0 70 4F 2E 77          .BYTE      070H,04FH,02EH,077H     ;  1/6! ( 1/720)
3920  1AD4 6E 02 88 7A          .BYTE      06EH,002H,088H,07AH     ; -1/5! (-1/120)
3921  1AD8 E6 A0 2A 7C          .BYTE      0E6H,0A0H,02AH,07CH     ;  1/4! ( 1/24)
3922  1ADC 50 AA AA 7E          .BYTE      050H,0AAH,0AAH,07EH     ; -1/3! (-1/6)
3923  1AE0 FF FF 7F 7F          .BYTE      0FFH,0FFH,07FH,07FH     ;  1/2! ( 1/2)
3924  1AE4 00 00 80 81          .BYTE      000H,000H,080H,081H     ; -1/1! (-1/1)
3925  1AE8 00 00 00 81          .BYTE      000H,000H,000H,081H     ;  1/0! ( 1/1)
3926  1AEC
3927  1AEC CD D5 17     SUMSER: CALL    STAKFP          ; Put FPREG on stack
3928  1AEF 11 97 16             LD      DE,MULT         ; Multiply by "X"
3929  1AF2 D5                   PUSH    DE              ; To be done after
3930  1AF3 E5                   PUSH    HL              ; Save address of table
3931  1AF4 CD F0 17             CALL    BCDEFP          ; Move FPREG to BCDE
3932  1AF7 CD 99 16             CALL    FPMULT          ; Square the value
3933  1AFA E1                   POP     HL              ; Restore address of table
3934  1AFB CD D5 17     SMSER1: CALL    STAKFP          ; Put value on stack
3935  1AFE 7E                   LD      A,(HL)          ; Get number of coefficients
3936  1AFF 23                   INC     HL              ; Point to start of table
3937  1B00 CD E2 17             CALL    PHLTFP          ; Move coefficient to FPREG
3938  1B03 06                   .BYTE      06H             ; Skip "POP AF"
3939  1B04 F1           SUMLP:  POP     AF              ; Restore count
3940  1B05 C1                   POP     BC              ; Restore number
3941  1B06 D1                   POP     DE
3942  1B07 3D                   DEC     A               ; Cont coefficients
3943  1B08 C8                   RET     Z               ; All done
3944  1B09 D5                   PUSH    DE              ; Save number
3945  1B0A C5                   PUSH    BC
3946  1B0B F5                   PUSH    AF              ; Save count
3947  1B0C E5                   PUSH    HL              ; Save address in table
3948  1B0D CD 99 16             CALL    FPMULT          ; Multiply FPREG by BCDE
3949  1B10 E1                   POP     HL              ; Restore address in table
3950  1B11 CD F3 17             CALL    LOADFP          ; Number at HL to BCDE
3951  1B14 E5                   PUSH    HL              ; Save address in table
3952  1B15 CD 5E 15             CALL    FPADD           ; Add coefficient to FPREG
3953  1B18 E1                   POP     HL              ; Restore address in table
3954  1B19 C3 04 1B             JP      SUMLP           ; More coefficients
3955  1B1C
3956  1B1C CD A4 17     RND:    CALL    TSTSGN          ; Test sign of FPREG
3957  1B1F 21 5E 20             LD      HL,SEED+2       ; Random number seed
3958  1B22 FA 7D 1B             JP      M,RESEED        ; Negative - Re-seed
3959  1B25 21 7F 20             LD      HL,LSTRND       ; Last random number
3960  1B28 CD E2 17             CALL    PHLTFP          ; Move last RND to FPREG
3961  1B2B 21 5E 20             LD      HL,SEED+2       ; Random number seed
3962  1B2E C8                   RET     Z               ; Return if RND(0)
3963  1B2F 86                   ADD     A,(HL)          ; Add (SEED)+2)
3964  1B30 E6 07                AND     00000111B       ; 0 to 7
3965  1B32 06 00                LD      B,0
3966  1B34 77                   LD      (HL),A          ; Re-save seed
3967  1B35 23                   INC     HL              ; Move to coefficient table
3968  1B36 87                   ADD     A,A             ; 4 bytes
3969  1B37 87                   ADD     A,A             ; per entry
3970  1B38 4F                   LD      C,A             ; BC = Offset into table
3971  1B39 09                   ADD     HL,BC           ; Point to coefficient
3972  1B3A CD F3 17             CALL    LOADFP          ; Coefficient to BCDE
3973  1B3D CD 99 16             CALL    FPMULT  ;       ; Multiply FPREG by coefficient
3974  1B40 3A 5D 20             LD      A,(SEED+1)      ; Get (SEED+1)
3975  1B43 3C                   INC     A               ; Add 1
3976  1B44 E6 03                AND     00000011B       ; 0 to 3
3977  1B46 06 00                LD      B,0
3978  1B48 FE 01                CP      1               ; Is it zero?
3979  1B4A 88                   ADC     A,B             ; Yes - Make it 1
3980  1B4B 32 5D 20             LD      (SEED+1),A      ; Re-save seed
3981  1B4E 21 81 1B             LD      HL,RNDTAB-4     ; Addition table
3982  1B51 87                   ADD     A,A             ; 4 bytes
3983  1B52 87                   ADD     A,A             ; per entry
3984  1B53 4F                   LD      C,A             ; BC = Offset into table
3985  1B54 09                   ADD     HL,BC           ; Point to value
3986  1B55 CD 4F 15             CALL    ADDPHL          ; Add value to FPREG
3987  1B58 CD F0 17     RND1:   CALL    BCDEFP          ; Move FPREG to BCDE
3988  1B5B 7B                   LD      A,E             ; Get LSB
3989  1B5C 59                   LD      E,C             ; LSB = MSB
3990  1B5D EE 4F                XOR     01001111B       ; Fiddle around
3991  1B5F 4F                   LD      C,A             ; New MSB
3992  1B60 36 80                LD      (HL),80H        ; Set exponent
3993  1B62 2B                   DEC     HL              ; Point to MSB
3994  1B63 46                   LD      B,(HL)          ; Get MSB
3995  1B64 36 80                LD      (HL),80H        ; Make value -0.5
3996  1B66 21 5C 20             LD      HL,SEED         ; Random number seed
3997  1B69 34                   INC     (HL)            ; Count seed
3998  1B6A 7E                   LD      A,(HL)          ; Get seed
3999  1B6B D6 AB                SUB     171             ; Do it modulo 171
4000  1B6D C2 74 1B             JP      NZ,RND2         ; Non-zero - Ok
4001  1B70 77                   LD      (HL),A          ; Zero seed
4002  1B71 0C                   INC     C               ; Fillde about
4003  1B72 15                   DEC     D               ; with the
4004  1B73 1C                   INC     E               ; number
4005  1B74 CD AF 15     RND2:   CALL    BNORM           ; Normalise number
4006  1B77 21 7F 20             LD      HL,LSTRND       ; Save random number
4007  1B7A C3 FC 17             JP      FPTHL           ; Move FPREG to last and return
4008  1B7D
4009  1B7D 77           RESEED: LD      (HL),A          ; Re-seed random numbers
4010  1B7E 2B                   DEC     HL
4011  1B7F 77                   LD      (HL),A
4012  1B80 2B                   DEC     HL
4013  1B81 77                   LD      (HL),A
4014  1B82 C3 58 1B             JP      RND1            ; Return RND seed
4015  1B85
4016  1B85 68 B1 46 68  RNDTAB: .BYTE   068H,0B1H,046H,068H     ; Table used by RND
4017  1B89 99 E9 92 69          .BYTE   099H,0E9H,092H,069H
4018  1B8D 10 D1 75 68          .BYTE   010H,0D1H,075H,068H
4019  1B91
4020  1B91 21 DB 1B     COS:    LD      HL,HALFPI       ; Point to PI/2
4021  1B94 CD 4F 15             CALL    ADDPHL          ; Add it to PPREG
4022  1B97 CD D5 17     SIN:    CALL    STAKFP          ; Put angle on stack
4023  1B9A 01 49 83             LD      BC,8349H        ; BCDE = 2 PI
4024  1B9D 11 DB 0F             LD      DE,0FDBH
4025  1BA0 CD E5 17             CALL    FPBCDE          ; Move 2 PI to FPREG
4026  1BA3 C1                   POP     BC              ; Restore angle
4027  1BA4 D1                   POP     DE
4028  1BA5 CD FA 16             CALL    DVBCDE          ; Divide angle by 2 PI
4029  1BA8 CD D5 17             CALL    STAKFP          ; Put it on stack
4030  1BAB CD 77 18             CALL    INT             ; Get INT of result
4031  1BAE C1                   POP     BC              ; Restore number
4032  1BAF D1                   POP     DE
4033  1BB0 CD 5B 15             CALL    SUBCDE          ; Make it 0 <= value < 1
4034  1BB3 21 DF 1B             LD      HL,QUARTR       ; Point to 0.25
4035  1BB6 CD 55 15             CALL    SUBPHL          ; Subtract value from 0.25
4036  1BB9 CD A4 17             CALL    TSTSGN          ; Test sign of value
4037  1BBC 37                   SCF                     ; Flag positive
4038  1BBD F2 C7 1B             JP      P,SIN1          ; Positive - Ok
4039  1BC0 CD 4C 15             CALL    ROUND           ; Add 0.5 to value
4040  1BC3 CD A4 17             CALL    TSTSGN          ; Test sign of value
4041  1BC6 B7                   OR      A               ; Flag negative
4042  1BC7 F5           SIN1:   PUSH    AF              ; Save sign
4043  1BC8 F4 CD 17             CALL    P,INVSGN        ; Negate value if positive
4044  1BCB 21 DF 1B             LD      HL,QUARTR       ; Point to 0.25
4045  1BCE CD 4F 15             CALL    ADDPHL          ; Add 0.25 to value
4046  1BD1 F1                   POP     AF              ; Restore sign
4047  1BD2 D4 CD 17             CALL    NC,INVSGN       ; Negative - Make positive
4048  1BD5 21 E3 1B             LD      HL,SINTAB       ; Coefficient table
4049  1BD8 C3 EC 1A             JP      SUMSER          ; Evaluate sum of series
4050  1BDB
4051  1BDB DB 0F 49 81  HALFPI: .BYTE   0DBH,00FH,049H,081H     ; 1.5708 (PI/2)
4052  1BDF
4053  1BDF 00 00 00 7F  QUARTR: .BYTE   000H,000H,000H,07FH     ; 0.25
4054  1BE3
4055  1BE3 05           SINTAB: .BYTE   5                       ; Table used by SIN
4056  1BE4 BA D7 1E 86          .BYTE   0BAH,0D7H,01EH,086H     ; 39.711
4057  1BE8 64 26 99 87          .BYTE   064H,026H,099H,087H     ;-76.575
4058  1BEC 58 34 23 87          .BYTE   058H,034H,023H,087H     ; 81.602
4059  1BF0 E0 5D A5 86          .BYTE   0E0H,05DH,0A5H,086H     ;-41.342
4060  1BF4 DA 0F 49 83          .BYTE   0DAH,00FH,049H,083H     ;  6.2832
4061  1BF8
4062  1BF8 CD D5 17     TAN:    CALL    STAKFP          ; Put angle on stack
4063  1BFB CD 97 1B             CALL    SIN             ; Get SIN of angle
4064  1BFE C1                   POP     BC              ; Restore angle
4065  1BFF E1                   POP     HL
4066  1C00 CD D5 17             CALL    STAKFP          ; Save SIN of angle
4067  1C03 EB                   EX      DE,HL           ; BCDE = Angle
4068  1C04 CD E5 17             CALL    FPBCDE          ; Angle to FPREG
4069  1C07 CD 91 1B             CALL    COS             ; Get COS of angle
4070  1C0A C3 F8 16             JP      DIV             ; TAN = SIN / COS
4071  1C0D
4072  1C0D CD A4 17     ATN:    CALL    TSTSGN          ; Test sign of value
4073  1C10 FC 38 1A             CALL    M,NEGAFT        ; Negate result after if -ve
4074  1C13 FC CD 17             CALL    M,INVSGN        ; Negate value if -ve
4075  1C16 3A 2C 21             LD      A,(FPEXP)       ; Get exponent
4076  1C19 FE 81                CP      81H             ; Number less than 1?
4077  1C1B DA 2A 1C             JP      C,ATN1          ; Yes - Get arc tangnt
4078  1C1E 01 00 81             LD      BC,8100H        ; BCDE = 1
4079  1C21 51                   LD      D,C
4080  1C22 59                   LD      E,C
4081  1C23 CD FA 16             CALL    DVBCDE          ; Get reciprocal of number
4082  1C26 21 55 15             LD      HL,SUBPHL       ; Sub angle from PI/2
4083  1C29 E5                   PUSH    HL              ; Save for angle > 1
4084  1C2A 21 34 1C     ATN1:   LD      HL,ATNTAB       ; Coefficient table
4085  1C2D CD EC 1A             CALL    SUMSER          ; Evaluate sum of series
4086  1C30 21 DB 1B             LD      HL,HALFPI       ; PI/2 - angle in case > 1
4087  1C33 C9                   RET                     ; Number > 1 - Sub from PI/2
4088  1C34
4089  1C34 09           ATNTAB: .BYTE   9                       ; Table used by ATN
4090  1C35 4A D7 3B 78          .BYTE   04AH,0D7H,03BH,078H     ; 1/17
4091  1C39 02 6E 84 7B          .BYTE   002H,06EH,084H,07BH     ;-1/15
4092  1C3D FE C1 2F 7C          .BYTE   0FEH,0C1H,02FH,07CH     ; 1/13
4093  1C41 74 31 9A 7D          .BYTE   074H,031H,09AH,07DH     ;-1/11
4094  1C45 84 3D 5A 7D          .BYTE   084H,03DH,05AH,07DH     ; 1/9
4095  1C49 C8 7F 91 7E          .BYTE   0C8H,07FH,091H,07EH     ;-1/7
4096  1C4D E4 BB 4C 7E          .BYTE   0E4H,0BBH,04CH,07EH     ; 1/5
4097  1C51 6C AA AA 7F          .BYTE   06CH,0AAH,0AAH,07FH     ;-1/3
4098  1C55 00 00 00 81          .BYTE   000H,000H,000H,081H     ; 1/1
4099  1C59
4100  1C59
4101  1C59 C9           ARET:   RET                     ; A RETurn instruction
4102  1C5A
4103  1C5A D7           GETINP: RST	    10H             ;input a character
4104  1C5B C9                   RET
4105  1C5C
4106  1C5C              CLS:
4107  1C5C 3E 0C                LD      A,CS1            ; ASCII Clear screen
4108  1C5E C3 96 1D             JP      MONOUT          ; Output character
4109  1C61
4110  1C61 CD 23 15     WIDTH:  CALL    GETINT          ; Get integer 0-255
4111  1C64 7B                   LD      A,E             ; Width to A
4112  1C65 32 87 20             LD      (LWIDTH),A      ; Set width
4113  1C68 C9                   RET
4114  1C69
4115  1C69 CD C2 0D     LINES:  CALL    GETNUM          ; Get a number
4116  1C6C CD 07 0A             CALL    DEINT           ; Get integer -32768 to 32767
4117  1C6F ED 53 8B 20          LD      (LINESC),DE     ; Set lines counter
4118  1C73 ED 53 8D 20          LD      (LINESN),DE     ; Set lines number
4119  1C77 C9                   RET
4120  1C78
4121  1C78 CD 07 0A     DEEK:   CALL    DEINT           ; Get integer -32768 to 32767
4122  1C7B D5                   PUSH    DE              ; Save number
4123  1C7C E1                   POP     HL              ; Number to HL
4124  1C7D 46                   LD      B,(HL)          ; Get LSB of contents
4125  1C7E 23                   INC     HL
4126  1C7F 7E                   LD      A,(HL)          ; Get MSB of contents
4127  1C80 C3 7D 11             JP      ABPASS          ; Return integer AB
4128  1C83
4129  1C83 CD C2 0D     DOKE:   CALL    GETNUM          ; Get a number
4130  1C86 CD 07 0A             CALL    DEINT           ; Get integer -32768 to 32767
4131  1C89 D5                   PUSH    DE              ; Save address
4132  1C8A CD CB 07             CALL    CHKSYN          ; Make sure ',' follows
4133  1C8D 2C                   .BYTE      ','
4134  1C8E CD C2 0D             CALL    GETNUM          ; Get a number
4135  1C91 CD 07 0A             CALL    DEINT           ; Get integer -32768 to 32767
4136  1C94 E3                   EX      (SP),HL         ; Save value,get address
4137  1C95 73                   LD      (HL),E          ; Save LSB of value
4138  1C96 23                   INC     HL
4139  1C97 72                   LD      (HL),D          ; Save MSB of value
4140  1C98 E1                   POP     HL              ; Restore code string address
4141  1C99 C9                   RET
4142  1C9A
4143  1C9A
4144  1C9A              ; HEX$(nn) Convert 16 bit number to Hexadecimal string
4145  1C9A
4146  1C9A CD C5 0D     HEX: 	CALL	TSTNUM          ; Verify it's a number
4147  1C9D CD 07 0A             CALL	DEINT           ; Get integer -32768 to 32767
4148  1CA0 C5                   PUSH	BC              ; Save contents of BC
4149  1CA1 21 2E 21             LD	    HL,PBUFF
4150  1CA4 7A                   LD	    A,D             ; Get high order into A
4151  1CA5 FE 00                CP      $0
4152  1CA7 28 0C        		JR      Z,HEX2          ; Skip output if both high digits are zero
4153  1CA9 CD D2 1C             CALL    BYT2ASC         ; Convert D to ASCII
4154  1CAC 78           		LD      A,B
4155  1CAD FE 30        		CP      '0'
4156  1CAF 28 02        		JR      Z,HEX1          ; Don't store high digit if zero
4157  1CB1 70                   LD	    (HL),B          ; Store it to PBUFF
4158  1CB2 23                   INC	    HL              ; Next location
4159  1CB3 71           HEX1:   LD	    (HL),C          ; Store C to PBUFF+1
4160  1CB4 23                   INC     HL              ; Next location
4161  1CB5 7B           HEX2:   LD	    A,E             ; Get lower byte
4162  1CB6 CD D2 1C             CALL    BYT2ASC         ; Convert E to ASCII
4163  1CB9 7A           		LD      A,D
4164  1CBA FE 00                CP      $0
4165  1CBC 20 05        		JR      NZ,HEX3         ; If upper byte was not zero then always print lower byte
4166  1CBE 78           		LD      A,B
4167  1CBF FE 30        		CP      '0'             ; If high digit of lower byte is zero then don't print
4168  1CC1 28 02        		JR      Z,HEX4
4169  1CC3 70           HEX3:   LD      (HL),B          ; to PBUFF+2
4170  1CC4 23                   INC     HL              ; Next location
4171  1CC5 71           HEX4:   LD      (HL),C          ; to PBUFF+3
4172  1CC6 23                   INC     HL              ; PBUFF+4 to zero
4173  1CC7 AF                   XOR     A               ; Terminating character
4174  1CC8 77                   LD      (HL),A          ; Store zero to terminate
4175  1CC9 23                   INC     HL              ; Make sure PBUFF is terminated
4176  1CCA 77                   LD      (HL),A          ; Store the double zero there
4177  1CCB C1                   POP     BC              ; Get BC back
4178  1CCC 21 2E 21             LD      HL,PBUFF        ; Reset to start of PBUFF
4179  1CCF C3 2B 12             JP      STR1            ; Convert the PBUFF to a string and return it
4180  1CD2
4181  1CD2 47           BYT2ASC	LD      B,A             ; Save original value
4182  1CD3 E6 0F                AND     $0F             ; Strip off upper nybble
4183  1CD5 FE 0A                CP      $0A             ; 0-9?
4184  1CD7 38 02                JR      C,ADD30         ; If A-F, add 7 more
4185  1CD9 C6 07                ADD     A,$07           ; Bring value up to ASCII A-F
4186  1CDB C6 30        ADD30	ADD     A,$30           ; And make ASCII
4187  1CDD 4F                   LD      C,A             ; Save converted char to C
4188  1CDE 78                   LD      A,B             ; Retrieve original value
4189  1CDF 0F                   RRCA                    ; and Rotate it right
4190  1CE0 0F                   RRCA
4191  1CE1 0F                   RRCA
4192  1CE2 0F                   RRCA
4193  1CE3 E6 0F                AND     $0F             ; Mask off upper nybble
4194  1CE5 FE 0A                CP      $0A             ; 0-9? < A hex?
4195  1CE7 38 02                JR      C,ADD301        ; Skip Add 7
4196  1CE9 C6 07                ADD     A,$07           ; Bring it up to ASCII A-F
4197  1CEB C6 30        ADD301	ADD     A,$30           ; And make it full ASCII
4198  1CED 47                   LD      B,A             ; Store high order byte
4199  1CEE C9                   RET
4200  1CEF
4201  1CEF              ; Convert "&Hnnnn" to FPREG
4202  1CEF              ; Gets a character from (HL) checks for Hexadecimal ASCII numbers "&Hnnnn"
4203  1CEF              ; Char is in A, NC if char is ;<=>?@ A-z, CY is set if 0-9
4204  1CEF EB           HEXTFP  EX      DE,HL           ; Move code string pointer to DE
4205  1CF0 21 00 00             LD      HL,$0000        ; Zero out the value
4206  1CF3 CD 08 1D             CALL    GETHEX          ; Check the number for valid hex
4207  1CF6 DA 28 1D             JP      C,HXERR         ; First value wasn't hex, HX error
4208  1CF9 18 05                JR      HEXLP1          ; Convert first character
4209  1CFB CD 08 1D     HEXLP   CALL    GETHEX          ; Get second and addtional characters
4210  1CFE 38 1F                JR      C,HEXIT         ; Exit if not a hex character
4211  1D00 29           HEXLP1  ADD     HL,HL           ; Rotate 4 bits to the left
4212  1D01 29                   ADD     HL,HL
4213  1D02 29                   ADD     HL,HL
4214  1D03 29                   ADD     HL,HL
4215  1D04 B5                   OR      L               ; Add in D0-D3 into L
4216  1D05 6F                   LD      L,A             ; Save new value
4217  1D06 18 F3                JR      HEXLP           ; And continue until all hex characters are in
4218  1D08
4219  1D08 13           GETHEX  INC     DE              ; Next location
4220  1D09 1A                   LD      A,(DE)          ; Load character at pointer
4221  1D0A FE 20                CP      ' '
4222  1D0C CA 08 1D             JP      Z,GETHEX        ; Skip spaces
4223  1D0F D6 30                SUB     $30             ; Get absolute value
4224  1D11 D8                   RET     C               ; < "0", error
4225  1D12 FE 0A                CP      $0A
4226  1D14 38 05                JR      C,NOSUB7        ; Is already in the range 0-9
4227  1D16 D6 07                SUB     $07             ; Reduce to A-F
4228  1D18 FE 0A                CP      $0A             ; Value should be $0A-$0F at this point
4229  1D1A D8                   RET     C               ; CY set if was :            ; < = > ? @
4230  1D1B FE 10        NOSUB7  CP      $10             ; > Greater than "F"?
4231  1D1D 3F                   CCF
4232  1D1E C9                   RET                     ; CY set if it wasn't valid hex
4233  1D1F
4234  1D1F EB           HEXIT   EX      DE,HL           ; Value into DE, Code string into HL
4235  1D20 7A                   LD      A,D             ; Load DE into AC
4236  1D21 4B                   LD      C,E             ; For prep to
4237  1D22 E5                   PUSH    HL
4238  1D23 CD 7C 11             CALL    ACPASS          ; ACPASS to set AC as integer into FPREG
4239  1D26 E1                   POP     HL
4240  1D27 C9                   RET
4241  1D28
4242  1D28 DD 5C        HXERR:  LD      E,HX            ; ?HEX Error
4243  1D2A C3 11 05             JP      ERROR
4244  1D2D
4245  1D2D              ; BIN$(NN) Convert integer to a 1-16 char binary string
4246  1D2D CD C5 0D     BIN:    CALL    TSTNUM          ; Verify it's a number
4247  1D30 CD 07 0A             CALL    DEINT           ; Get integer -32768 to 32767
4248  1D33 C5           BIN2:   PUSH    BC              ; Save contents of BC
4249  1D34 21 2E 21             LD      HL,PBUFF
4250  1D37 06 11                LD      B,17            ; One higher than max char count
4251  1D39              ZEROSUP:                        ; Suppress leading zeros
4252  1D39 05                   DEC     B               ; Max 16 chars
4253  1D3A 78                   LD      A,B
4254  1D3B FE 01                CP      $01
4255  1D3D 28 08                JR      Z,BITOUT        ; Always output at least one character
4256  1D3F CB 13                RL      E
4257  1D41 CB 12                RL      D
4258  1D43 30 F4                JR      NC,ZEROSUP
4259  1D45 18 04                JR      BITOUT2
4260  1D47              BITOUT:
4261  1D47 CB 13                RL      E
4262  1D49 CB 12                RL      D               ; Top bit now in carry
4263  1D4B              BITOUT2:
4264  1D4B 3E 30                LD      A,'0'           ; Char for '0'
4265  1D4D CE 00                ADC     A,0             ; If carry set then '0' --> '1'
4266  1D4F 77                   LD      (HL),A
4267  1D50 23                   INC     HL
4268  1D51 05                   DEC     B
4269  1D52 20 F3                JR      NZ,BITOUT
4270  1D54 AF                   XOR     A               ; Terminating character
4271  1D55 77                   LD      (HL),A          ; Store zero to terminate
4272  1D56 23                   INC     HL              ; Make sure PBUFF is terminated
4273  1D57 77                   LD      (HL),A          ; Store the double zero there
4274  1D58 C1                   POP     BC
4275  1D59 21 2E 21             LD      HL,PBUFF
4276  1D5C C3 2B 12             JP      STR1
4277  1D5F
4278  1D5F              ; Convert "&Bnnnn" to FPREG
4279  1D5F              ; Gets a character from (HL) checks for Binary ASCII numbers "&Bnnnn"
4280  1D5F EB           BINTFP: EX      DE,HL           ; Move code string pointer to DE
4281  1D60 21 00 00             LD      HL,$0000        ; Zero out the value
4282  1D63 CD 7C 1D             CALL    CHKBIN          ; Check the number for valid bin
4283  1D66 DA 8A 1D             JP      C,BINERR        ; First value wasn't bin, HX error
4284  1D69 D6 30        BINIT:  SUB     '0'
4285  1D6B 29                   ADD     HL,HL           ; Rotate HL left
4286  1D6C B5                   OR      L
4287  1D6D 6F                   LD      L,A
4288  1D6E CD 7C 1D             CALL    CHKBIN          ; Get second and addtional characters
4289  1D71 30 F6                JR      NC,BINIT        ; Process if a bin character
4290  1D73 EB                   EX      DE,HL           ; Value into DE, Code string into HL
4291  1D74 7A                   LD      A,D             ; Load DE into AC
4292  1D75 4B                   LD      C,E             ; For prep to
4293  1D76 E5                   PUSH    HL
4294  1D77 CD 7C 11             CALL    ACPASS          ; ACPASS to set AC as integer into FPREG
4295  1D7A E1                   POP     HL
4296  1D7B C9                   RET
4297  1D7C
4298  1D7C              ; Char is in A, NC if char is 0 or 1
4299  1D7C 13           CHKBIN: INC     DE
4300  1D7D 1A                   LD      A,(DE)
4301  1D7E FE 20                CP      ' '
4302  1D80 CA 7C 1D             JP      Z,CHKBIN        ; Skip spaces
4303  1D83 FE 30                CP      '0'             ; Set C if < '0'
4304  1D85 D8                   RET     C
4305  1D86 FE 32                CP      '2'
4306  1D88 3F                   CCF                     ; Set C if > '1'
4307  1D89 C9                   RET
4308  1D8A
4309  1D8A 1E 28        BINERR: LD      E,BN            ; ?BIN Error
4310  1D8C C3 11 05             JP      ERROR
4311  1D8F
4312  1D8F
4313  1D8F              JJUMP1:
4314  1D8F DD 21 FF FF          LD      IX,-1           ; Flag cold start
4315  1D93 C3 61 01             JP      CSTART          ; Go and initialise
4316  1D96
4317  1D96              MONOUT:
4318  1D96 C3 08 00             JP      $0008           ; output a char
4319  1D99
4320  1D99
4321  1D99              MONITR:
4322  1D99 C3 00 00             JP      $0000           ; Restart (Normally Monitor Start)
4323  1D9C
4324  1D9C
4325  1D9C 3E 00        INITST: LD      A,0             ; Clear break flag
4326  1D9E 32 92 20             LD      (BRKFLG),A
4327  1DA1 C3 A8 00             JP      INIT
4328  1DA4
4329  1DA4 ED 45        ARETN:  RETN                    ; Return from NMI
4330  1DA6
4331  1DA6
4332  1DA6 F5           TSTBIT: PUSH    AF              ; Save bit mask
4333  1DA7 A0                   AND     B               ; Get common bits
4334  1DA8 C1                   POP     BC              ; Restore bit mask
4335  1DA9 B8                   CP      B               ; Same bit set?
4336  1DAA 3E 00                LD      A,0             ; Return 0 in A
4337  1DAC C9                   RET
4338  1DAD
4339  1DAD CD D6 07     OUTNCR: CALL    OUTC            ; Output character in A
4340  1DB0 C3 FD 0B             JP      PRNTCRLF        ; Output CRLF
4341  1DB3
4342  1DB3              ;**********************************************************************************
4343  1DB3              ;
4344  1DB3              ; Z80-MBC2 uBIOS for Basic - S210718 - HW ref: A040618
4345  1DB3              ;
4346  1DB3              ; Adapted from Grant Searle great work!
4347  1DB3              ;
4348  1DB3              ;
4349  1DB3              ; NOTE: all changes in the following code are marked with this string "Z80-MBC2:" in the comment
4350  1DB3              ;       (the basic.asm file is not modified)
4351  1DB3              ;
4352  1DB3              ;**********************************************************************************
4353  1DB3              ;==================================================================================
4354  1DB3              ; Contents of this file are copyright Grant Searle
4355  1DB3              ;
4356  1DB3              ; You have permission to use this for NON COMMERCIAL USE ONLY
4357  1DB3              ; If you wish to use it elsewhere, please include an acknowledgement to myself.
4358  1DB3              ;
4359  1DB3              ; http://searle.hostei.com/grant/index.html
4360  1DB3              ;
4361  1DB3              ; eMail: home.micros01@btinternet.com
4362  1DB3              ;
4363  1DB3              ; If the above don't work, please perform an Internet search to see if I have
4364  1DB3              ; updated the web page hosting service.
4365  1DB3              ;
4366  1DB3              ;==================================================================================
4367  1DB3
4368  1DB3              ; Minimum 6850 ACIA interrupt driven serial I/O to run modified NASCOM Basic 4.7
4369  1DB3              ; Full input buffering with incoming data hardware handshaking
4370  1DB3              ; Handshake shows full before the buffer is totally filled to allow run-on from the sender
4371  1DB3
4372  1DB3              SER_BUFSIZE     .EQU     3FH
4373  1DB3              SER_FULLSIZE    .EQU     30H
4374  1DB3              SER_EMPTYSIZE   .EQU     5
4375  1DB3
4376  1DB3              RTS_HIGH        .EQU     0D6H
4377  1DB3              RTS_LOW         .EQU     096H
4378  1DB3
4379  1DB3              serBuf          .EQU     $2000
4380  1DB3              serInPtr        .EQU     serBuf+SER_BUFSIZE
4381  1DB3              serRdPtr        .EQU     serInPtr+2
4382  1DB3              serBufUsed      .EQU     serRdPtr+2
4383  1DB3              basicStarted    .EQU     serBufUsed+1
4384  1DB3              TEMPSTACK       .EQU     $20ED ; Top of BASIC line input buffer so is "free ram" when BASIC resets
4385  1DB3
4386  1DB3              CR              .EQU     0DH
4387  1DB3              LF              .EQU     0AH
4388  1DB3              CS              .EQU     0CH             ; Clear screen
4389  1DB3
4390  1DB3                              .ORG $0000
4391  0000              ;------------------------------------------------------------------------------
4392  0000              ; Reset
4393  0000
4394  0000 F3           RST00           DI                       ;Disable interrupts
4395  0001 C3 A8 00                     JP       INIT            ;Initialize Hardware and go
4396  0004
4397  0004              ;------------------------------------------------------------------------------
4398  0004              ; TX a character over RS232
4399  0004
4400  0004                              .ORG     0008H
4401  0008 C3 91 00     RST08            JP      TXA
4402  000B
4403  000B              ;------------------------------------------------------------------------------
4404  000B              ; RX a character over RS232 Channel A [Console], hold here until char ready.
4405  000B
4406  000B                              .ORG 0010H
4407  0010 C3 6A 00     RST10            JP      RXA
4408  0013
4409  0013              ;------------------------------------------------------------------------------
4410  0013              ; Check serial status
4411  0013
4412  0013                              .ORG 0018H
4413  0018 C3 9A 00     RST18            JP      CKINCHAR
4414  001B
4415  001B              ;------------------------------------------------------------------------------
4416  001B              ; RST 38 - INTERRUPT VECTOR [ for IM 1 ]
4417  001B
4418  001B                              .ORG     0038H
4419  0038 18 00        RST38            JR      serialInt
4420  003A
4421  003A              ;------------------------------------------------------------------------------
4422  003A F5           serialInt:      PUSH     AF
4423  003B E5                           PUSH     HL
4424  003C
4425  003C                              ;IN       A,($80)         ; Z80-MBC2: No buffer full to check here
4426  003C                              ;AND      $01             ; Check if interupt due to read buffer full
4427  003C                              ;JR       Z,rts0          ; if not, ignore
4428  003C
4429  003C DB 01                        IN       A,($01)         ; Z80-MBC2: Changed port addr from $81 to $01
4430  003E F5                           PUSH     AF
4431  003F 3A 43 20                     LD       A,(serBufUsed)
4432  0042 FE 3F                        CP       SER_BUFSIZE     ; If full then ignore
4433  0044 20 03                        JR       NZ,notFull
4434  0046 F1                           POP      AF
4435  0047 18 1C                        JR       rts0
4436  0049
4437  0049 2A 3F 20     notFull:        LD       HL,(serInPtr)
4438  004C 23                           INC      HL
4439  004D 7D                           LD       A,L             ; Only need to check low byte becasuse buffer<256 bytes
4440  004E FE 3F                        CP       (serBuf+SER_BUFSIZE) & $FF
4441  0050 20 03                        JR       NZ, notWrap
4442  0052 21 00 20                     LD       HL,serBuf
4443  0055 22 3F 20     notWrap:        LD       (serInPtr),HL
4444  0058 F1                           POP      AF
4445  0059 77                           LD       (HL),A
4446  005A 3A 43 20                     LD       A,(serBufUsed)
4447  005D 3C                           INC      A
4448  005E 32 43 20                     LD       (serBufUsed),A
4449  0061 FE 30                        CP       SER_FULLSIZE
4450  0063 38 00                        JR       C,rts0
4451  0065                              ;LD       A,RTS_HIGH     ; Z80-MBC2: No RTS HW handshackig here
4452  0065                              ;OUT      ($80),A
4453  0065 E1           rts0:           POP      HL
4454  0066 F1                           POP      AF
4455  0067 FB                           EI
4456  0068 ED 4D                        RETI
4457  006A
4458  006A              ;------------------------------------------------------------------------------
4459  006A              RXA:
4460  006A 3A 43 20     waitForChar:    LD       A,(serBufUsed)
4461  006D FE 00                        CP       $00
4462  006F 28 F9                        JR       Z, waitForChar
4463  0071 E5                           PUSH     HL
4464  0072 2A 41 20                     LD       HL,(serRdPtr)
4465  0075 23                           INC      HL
4466  0076 7D                           LD       A,L             ; Only need to check low byte becasuse buffer<256 bytes
4467  0077 FE 3F                        CP       (serBuf+SER_BUFSIZE) & $FF
4468  0079 20 03                        JR       NZ, notRdWrap
4469  007B 21 00 20                     LD       HL,serBuf
4470  007E F3           notRdWrap:      DI
4471  007F 22 41 20                     LD       (serRdPtr),HL
4472  0082 3A 43 20                     LD       A,(serBufUsed)
4473  0085 3D                           DEC      A
4474  0086 32 43 20                     LD       (serBufUsed),A
4475  0089 FE 05                        CP       SER_EMPTYSIZE
4476  008B 30 00                        JR       NC,rts1
4477  008D                              ;LD       A,RTS_LOW       ; Z80-MBC2: No RTS HW handshackig here
4478  008D                              ;OUT      ($80),A
4479  008D              rts1:
4480  008D 7E                           LD       A,(HL)
4481  008E FB                           EI
4482  008F E1                           POP      HL
4483  0090 C9                           RET                      ; Char ready in A
4484  0091
4485  0091              ;------------------------------------------------------------------------------
4486  0091              TXA:
4487  0091 F5           conout1:        PUSH     AF              ; Store character
4488  0092              				;IN       A,($80)         ; Z80-MBC2: No TX status needed here ;Status byte
4489  0092                              ;BIT      1,A             ; Set Zero flag if still transmitting character
4490  0092                              ;JR       Z,conout1       ; Loop until flag signals ready
4491  0092 3E 01                        LD       A,$01           ; Z80-MBC2: (Added) A = Serial TX Operation Code
4492  0094 D3 01                        OUT      ($01),A         ; Z80-MBC2: (Added) Write the Serial TX Opcode to IOS
4493  0096 F1                           POP      AF              ; Retrieve character
4494  0097 D3 00                        OUT      ($00),A         ; Z80-MBC2: Changed port addr from $81 to $01 ; Output the character
4495  0099 C9                           RET
4496  009A
4497  009A              ;------------------------------------------------------------------------------
4498  009A 3A 43 20     CKINCHAR        LD       A,(serBufUsed)
4499  009D FE 00                        CP       $0
4500  009F C9                           RET
4501  00A0
4502  00A0 7E           PRINT:          LD       A,(HL)          ; Get character
4503  00A1 B7                           OR       A               ; Is it $00 ?
4504  00A2 C8                           RET      Z               ; Then RETurn on terminator
4505  00A3 CF                           RST      08H             ; Print it
4506  00A4 23                           INC      HL              ; Next Character
4507  00A5 18 F9                        JR       PRINT           ; Continue until $00
4508  00A7 C9                           RET
4509  00A8              ;------------------------------------------------------------------------------
4510  00A8              INIT:
4511  00A8 21 ED 20                    LD        HL,TEMPSTACK    ; Temp stack
4512  00AB F9                          LD        SP,HL           ; Set up a temporary stack
4513  00AC 21 00 20                    LD        HL,serBuf
4514  00AF 22 3F 20                    LD        (serInPtr),HL
4515  00B2 22 41 20                    LD        (serRdPtr),HL
4516  00B5 AF                          XOR       A               ;0 to accumulator
4517  00B6 32 43 20                    LD        (serBufUsed),A
4518  00B9                             ;LD        A,RTS_LOW       ; Z80-MBC2: Nothing to initialize
4519  00B9                             ;OUT       ($80),A         ; Initialise ACIA
4520  00B9 ED 56                       IM        1
4521  00BB FB                          EI
4522  00BC 21 F5 00                    LD        HL,SIGNON1      ; Sign-on message
4523  00BF CD A0 00                    CALL      PRINT           ; Output string
4524  00C2 3A 44 20                    LD        A,(basicStarted); Check the BASIC STARTED flag
4525  00C5 FE 59                       CP        'Y'             ; to see if this is power-up
4526  00C7 20 16                       JR        NZ,COLDSTART    ; If not BASIC started then always do cold start
4527  00C9 21 2B 01                    LD        HL,SIGNON2      ; Cold/warm message
4528  00CC CD A0 00                    CALL      PRINT           ; Output string
4529  00CF              CORW:
4530  00CF CD 6A 00                    CALL      RXA
4531  00D2 E6 DF                       AND       %11011111       ; lower to uppercase
4532  00D4 FE 43                       CP        'C'
4533  00D6 20 0F                       JR        NZ, CHECKWARM
4534  00D8 CF                          RST       08H
4535  00D9 3E 0D                       LD        A,$0D
4536  00DB CF                          RST       08H
4537  00DC 3E 0A                       LD        A,$0A
4538  00DE CF                          RST       08H
4539  00DF 3E 59        COLDSTART:     LD        A,'Y'           ; Set the BASIC STARTED flag
4540  00E1 32 44 20                    LD        (basicStarted),A
4541  00E4 C3 50 01                    JP        $0150           ; Start BASIC COLD
4542  00E7              CHECKWARM:
4543  00E7 FE 57                       CP        'W'
4544  00E9 20 E4                       JR        NZ, CORW
4545  00EB CF                          RST       08H
4546  00EC 3E 0D                       LD        A,$0D
4547  00EE CF                          RST       08H
4548  00EF 3E 0A                       LD        A,$0A
4549  00F1 CF                          RST       08H
4550  00F2 C3 53 01                    JP        $0153           ; Start BASIC WARM
4551  00F5
4552  00F5              SIGNON1:       ;.BYTE     CS              ; Z80-MBC2: Changed SIGNON1 string
4553  00F5 75 42 49 4F                 .BYTE     "uBIOS - S210718 (Adapted from Z80 SBC by G. Searle)",CR,LF,0
4553  00F9 53 20 2D 20
4553  00FD 53 32 31 30
4553  0101 37 31 38 20
4553  0105 28 41 64 61
4553  0109 70 74 65 64
4553  010D 20 66 72 6F
4553  0111 6D 20 5A 38
4553  0115 30 20 53 42
4553  0119 43 20 62 79
4553  011D 20 47 2E 20
4553  0121 53 65 61 72
4553  0125 6C 65 29 0D
4553  0129 0A 00
4554  012B 0D 0A        SIGNON2:       .BYTE     CR,LF            ; Z80-MBC2: Changed SIGNON2 string
4555  012D 75 42 49 4F                 .BYTE     "uBIOS: Cold or warm start (C/W)?",0
4555  0131 53 3A 20 43
4555  0135 6F 6C 64 20
4555  0139 6F 72 20 77
4555  013D 61 72 6D 20
4555  0141 73 74 61 72
4555  0145 74 20 28 43
4555  0149 2F 57 29 3F
4555  014D 00
4556  014E
4557  014E                             .org      $14f            ; Z80-MBC2: Last byte for this uBIOS (BASIC starts next one)!
4558  014F 00           LastByte:      .byte     $00
4559  0150
4560  0150                             .END
# file closed: basic.asm
